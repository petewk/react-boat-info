{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\nexports.registerDragonSupport = registerDragonSupport;","map":{"version":3,"names":["lexical","require","registerDragonSupport","editor","origin","window","location","handler","event","rootElement","getRootElement","document","activeElement","data","parsedData","JSON","parse","e","protocol","type","payload","functionId","args","elementStart","elementLength","text","selStart","selLength","formatCommand","update","selection","$getSelection","$isRangeSelection","anchor","anchorNode","getNode","setSelStart","setSelEnd","$isTextNode","setTextNodeRange","insertRawText","anchorNodeTextLength","getTextContentSize","stopImmediatePropagation","addEventListener","removeEventListener","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/dragon/LexicalDragon.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/dragon */\r\nfunction registerDragonSupport(editor) {\r\n  const origin = window.location.origin;\r\n  const handler = event => {\r\n    if (event.origin !== origin) {\r\n      return;\r\n    }\r\n    const rootElement = editor.getRootElement();\r\n    if (document.activeElement !== rootElement) {\r\n      return;\r\n    }\r\n    const data = event.data;\r\n    if (typeof data === 'string') {\r\n      let parsedData;\r\n      try {\r\n        parsedData = JSON.parse(data);\r\n      } catch (e) {\r\n        return;\r\n      }\r\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\r\n        const payload = parsedData.payload;\r\n        if (payload && payload.functionId === 'makeChanges') {\r\n          const args = payload.args;\r\n          if (args) {\r\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\r\n            editor.update(() => {\r\n              const selection = lexical.$getSelection();\r\n              if (lexical.$isRangeSelection(selection)) {\r\n                const anchor = selection.anchor;\r\n                let anchorNode = anchor.getNode();\r\n                let setSelStart = 0;\r\n                let setSelEnd = 0;\r\n                if (lexical.$isTextNode(anchorNode)) {\r\n                  // set initial selection\r\n                  if (elementStart >= 0 && elementLength >= 0) {\r\n                    setSelStart = elementStart;\r\n                    setSelEnd = elementStart + elementLength;\r\n                    // If the offset is more than the end, make it the end\r\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\r\n                  }\r\n                }\r\n                if (setSelStart !== setSelEnd || text !== '') {\r\n                  selection.insertRawText(text);\r\n                  anchorNode = anchor.getNode();\r\n                }\r\n                if (lexical.$isTextNode(anchorNode)) {\r\n                  // set final selection\r\n                  setSelStart = selStart;\r\n                  setSelEnd = selStart + selLength;\r\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\r\n                  // If the offset is more than the end, make it the end\r\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\r\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\r\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\r\n                }\r\n\r\n                // block the chrome extension from handling this event\r\n                event.stopImmediatePropagation();\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n  window.addEventListener('message', handler, true);\r\n  return () => {\r\n    window.removeEventListener('message', handler, true);\r\n  };\r\n}\r\n\r\nexports.registerDragonSupport = registerDragonSupport;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}