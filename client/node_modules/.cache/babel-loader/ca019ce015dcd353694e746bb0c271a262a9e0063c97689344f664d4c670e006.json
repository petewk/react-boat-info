{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classNames[_key - 1] = arguments[_key];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element) {\n  for (var _len2 = arguments.length, classNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classNames[_key2 - 1] = arguments[_key2];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * Lexical File Reader with:\r\n *  1. MIME type support\r\n *  2. batched results (HistoryPlugin compatibility)\r\n *  3. Order aware (respects the order when multiple Files are passed)\r\n *\r\n * const filesResult = await mediaFileReader(files, ['image/']);\r\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\r\n *   src: file.result,\r\n * }));\r\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\nfunction mergeRegister() {\n  for (var _len3 = arguments.length, func = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    func[_key3] = arguments[_key3];\n  }\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;","map":{"version":3,"names":["selection","require","lexical","addClassNamesToElement","element","classNames","forEach","className","classesToAdd","split","filter","n","classList","add","removeClassNamesFromElement","remove","isMimeType","file","acceptableMimeTypes","acceptableType","type","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","value","next","fileReader","FileReader","addEventListener","result","push","readAsDataURL","$dfs","startingNode","endingNode","nodes","start","$getRoot","getLatest","end","$isElementNode","getLastDescendant","node","depth","$getDepth","is","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","Error","__key","findFn","curr","mergeRegister","func","f","registerNestedElementResolver","editor","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","i","length","child","parentNode","childNode","elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","append","canBeEmpty","registerNodeTransform","$restoreEditorState","editorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","clone","$cloneWithProperties","$isTextNode","__text","set","_dirtyType","selection$1","_selection","$setSelection","$insertNodeToNearestRoot","$getSelection","$isRangeSelection","focus","focusNode","getNode","focusOffset","offset","$isRootOrShadowRoot","focusChild","getChildAtIndex","insertBefore","selectNext","splitNode","splitOffset","getParentOrThrow","getIndexWithinParent","splitText","rightTree","$splitNode","selectStart","$isNodeSelection","DEPRECATED_$isGridSelection","getNodes","getTopLevelElementOrThrow","root","paragraphNode","$createParagraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","isHTMLAnchorElement","x","isHTMLElement","tagName","nodeType","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/utils/LexicalUtils.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar selection = require('@lexical/selection');\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/utils */\r\nfunction addClassNamesToElement(element, ...classNames) {\r\n  classNames.forEach(className => {\r\n    if (typeof className === 'string') {\r\n      const classesToAdd = className.split(' ').filter(n => n !== '');\r\n      element.classList.add(...classesToAdd);\r\n    }\r\n  });\r\n}\r\nfunction removeClassNamesFromElement(element, ...classNames) {\r\n  classNames.forEach(className => {\r\n    if (typeof className === 'string') {\r\n      element.classList.remove(...className.split(' '));\r\n    }\r\n  });\r\n}\r\nfunction isMimeType(file, acceptableMimeTypes) {\r\n  for (const acceptableType of acceptableMimeTypes) {\r\n    if (file.type.startsWith(acceptableType)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Lexical File Reader with:\r\n *  1. MIME type support\r\n *  2. batched results (HistoryPlugin compatibility)\r\n *  3. Order aware (respects the order when multiple Files are passed)\r\n *\r\n * const filesResult = await mediaFileReader(files, ['image/']);\r\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\r\n *   src: file.result,\r\n * }));\r\n */\r\nfunction mediaFileReader(files, acceptableMimeTypes) {\r\n  const filesIterator = files[Symbol.iterator]();\r\n  return new Promise((resolve, reject) => {\r\n    const processed = [];\r\n    const handleNextFile = () => {\r\n      const {\r\n        done,\r\n        value: file\r\n      } = filesIterator.next();\r\n      if (done) {\r\n        return resolve(processed);\r\n      }\r\n      const fileReader = new FileReader();\r\n      fileReader.addEventListener('error', reject);\r\n      fileReader.addEventListener('load', () => {\r\n        const result = fileReader.result;\r\n        if (typeof result === 'string') {\r\n          processed.push({\r\n            file,\r\n            result\r\n          });\r\n        }\r\n        handleNextFile();\r\n      });\r\n      if (isMimeType(file, acceptableMimeTypes)) {\r\n        fileReader.readAsDataURL(file);\r\n      } else {\r\n        handleNextFile();\r\n      }\r\n    };\r\n    handleNextFile();\r\n  });\r\n}\r\nfunction $dfs(startingNode, endingNode) {\r\n  const nodes = [];\r\n  const start = (startingNode || lexical.$getRoot()).getLatest();\r\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\r\n  let node = start;\r\n  let depth = $getDepth(node);\r\n  while (node !== null && !node.is(end)) {\r\n    nodes.push({\r\n      depth,\r\n      node\r\n    });\r\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\r\n      node = node.getFirstChild();\r\n      depth++;\r\n    } else {\r\n      // Find immediate sibling or nearest parent sibling\r\n      let sibling = null;\r\n      while (sibling === null && node !== null) {\r\n        sibling = node.getNextSibling();\r\n        if (sibling === null) {\r\n          node = node.getParent();\r\n          depth--;\r\n        } else {\r\n          node = sibling;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (node !== null && node.is(end)) {\r\n    nodes.push({\r\n      depth,\r\n      node\r\n    });\r\n  }\r\n  return nodes;\r\n}\r\nfunction $getDepth(node) {\r\n  let innerNode = node;\r\n  let depth = 0;\r\n  while ((innerNode = innerNode.getParent()) !== null) {\r\n    depth++;\r\n  }\r\n  return depth;\r\n}\r\nfunction $getNearestNodeOfType(node, klass) {\r\n  let parent = node;\r\n  while (parent != null) {\r\n    if (parent instanceof klass) {\r\n      return parent;\r\n    }\r\n    parent = parent.getParent();\r\n  }\r\n  return null;\r\n}\r\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\r\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\r\n  if (!lexical.$isElementNode(blockNode)) {\r\n    {\r\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\r\n    }\r\n  }\r\n  return blockNode;\r\n}\r\nfunction $findMatchingParent(startingNode, findFn) {\r\n  let curr = startingNode;\r\n  while (curr !== lexical.$getRoot() && curr != null) {\r\n    if (findFn(curr)) {\r\n      return curr;\r\n    }\r\n    curr = curr.getParent();\r\n  }\r\n  return null;\r\n}\r\nfunction mergeRegister(...func) {\r\n  return () => {\r\n    func.forEach(f => f());\r\n  };\r\n}\r\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\r\n  const $isTargetNode = node => {\r\n    return node instanceof targetNode;\r\n  };\r\n  const $findMatch = node => {\r\n    // First validate we don't have any children that are of the target,\r\n    // as we need to handle them first.\r\n    const children = node.getChildren();\r\n    for (let i = 0; i < children.length; i++) {\r\n      const child = children[i];\r\n      if ($isTargetNode(child)) {\r\n        return null;\r\n      }\r\n    }\r\n    let parentNode = node;\r\n    let childNode = node;\r\n    while (parentNode !== null) {\r\n      childNode = parentNode;\r\n      parentNode = parentNode.getParent();\r\n      if ($isTargetNode(parentNode)) {\r\n        return {\r\n          child: childNode,\r\n          parent: parentNode\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n  const elementNodeTransform = node => {\r\n    const match = $findMatch(node);\r\n    if (match !== null) {\r\n      const {\r\n        child,\r\n        parent\r\n      } = match;\r\n\r\n      // Simple path, we can move child out and siblings into a new parent.\r\n\r\n      if (child.is(node)) {\r\n        handleOverlap(parent, node);\r\n        const nextSiblings = child.getNextSiblings();\r\n        const nextSiblingsLength = nextSiblings.length;\r\n        parent.insertAfter(child);\r\n        if (nextSiblingsLength !== 0) {\r\n          const newParent = cloneNode(parent);\r\n          child.insertAfter(newParent);\r\n          for (let i = 0; i < nextSiblingsLength; i++) {\r\n            newParent.append(nextSiblings[i]);\r\n          }\r\n        }\r\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\r\n          parent.remove();\r\n        }\r\n      }\r\n    }\r\n  };\r\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\r\n}\r\nfunction $restoreEditorState(editor, editorState) {\r\n  const FULL_RECONCILE = 2;\r\n  const nodeMap = new Map();\r\n  const activeEditorState = editor._pendingEditorState;\r\n  for (const [key, node] of editorState._nodeMap) {\r\n    const clone = selection.$cloneWithProperties(node);\r\n    if (lexical.$isTextNode(clone)) {\r\n      clone.__text = node.__text;\r\n    }\r\n    nodeMap.set(key, clone);\r\n  }\r\n  if (activeEditorState) {\r\n    activeEditorState._nodeMap = nodeMap;\r\n  }\r\n  editor._dirtyType = FULL_RECONCILE;\r\n  const selection$1 = editorState._selection;\r\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\r\n}\r\nfunction $insertNodeToNearestRoot(node) {\r\n  const selection = lexical.$getSelection();\r\n  if (lexical.$isRangeSelection(selection)) {\r\n    const {\r\n      focus\r\n    } = selection;\r\n    const focusNode = focus.getNode();\r\n    const focusOffset = focus.offset;\r\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\r\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\r\n      if (focusChild == null) {\r\n        focusNode.append(node);\r\n      } else {\r\n        focusChild.insertBefore(node);\r\n      }\r\n      node.selectNext();\r\n    } else {\r\n      let splitNode;\r\n      let splitOffset;\r\n      if (lexical.$isTextNode(focusNode)) {\r\n        splitNode = focusNode.getParentOrThrow();\r\n        splitOffset = focusNode.getIndexWithinParent();\r\n        if (focusOffset > 0) {\r\n          splitOffset += 1;\r\n          focusNode.splitText(focusOffset);\r\n        }\r\n      } else {\r\n        splitNode = focusNode;\r\n        splitOffset = focusOffset;\r\n      }\r\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\r\n      rightTree.insertBefore(node);\r\n      rightTree.selectStart();\r\n    }\r\n  } else {\r\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\r\n      const nodes = selection.getNodes();\r\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\r\n    } else {\r\n      const root = lexical.$getRoot();\r\n      root.append(node);\r\n    }\r\n    const paragraphNode = lexical.$createParagraphNode();\r\n    node.insertAfter(paragraphNode);\r\n    paragraphNode.select();\r\n  }\r\n  return node.getLatest();\r\n}\r\nfunction $wrapNodeInElement(node, createElementNode) {\r\n  const elementNode = createElementNode();\r\n  node.replace(elementNode);\r\n  elementNode.append(node);\r\n  return elementNode;\r\n}\r\nfunction isHTMLAnchorElement(x) {\r\n  return isHTMLElement(x) && x.tagName === 'A';\r\n}\r\nfunction isHTMLElement(x) {\r\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\r\n  return x.nodeType === 1;\r\n}\r\n\r\nexports.$splitNode = lexical.$splitNode;\r\nexports.$dfs = $dfs;\r\nexports.$findMatchingParent = $findMatchingParent;\r\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\r\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\r\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\r\nexports.$restoreEditorState = $restoreEditorState;\r\nexports.$wrapNodeInElement = $wrapNodeInElement;\r\nexports.addClassNamesToElement = addClassNamesToElement;\r\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\r\nexports.isHTMLElement = isHTMLElement;\r\nexports.isMimeType = isMimeType;\r\nexports.mediaFileReader = mediaFileReader;\r\nexports.mergeRegister = mergeRegister;\r\nexports.registerNestedElementResolver = registerNestedElementResolver;\r\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}