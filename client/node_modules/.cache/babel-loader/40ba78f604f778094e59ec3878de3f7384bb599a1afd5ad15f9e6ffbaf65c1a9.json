{"ast":null,"code":"import _createClass from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nvar encodedTlds = 'aaa1rp3barth4b_ott3vie4c1le2ogado5udhabi7c_ademy5centure6ountant_s9o1tor4d_s1ult4e_g1ro2tna4f_l1rica5g_akhan5ency5i_g1rbus3force5tel5kdn3l_faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m_azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o_l2partments8p_le4q_uarelle8r_ab1mco4chi3my2pa2t_e3s_da2ia2sociates9t_hleta5torney7u_ction5di_ble3o3spost5thor3o_s4vianca6w_s2x_a2z_ure5ba_by2idu3namex3narepublic11d1k2r_celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b_c1t1va3cg1n2d1e_ats2uty4er2ntley5rlin4st_buy5t2f1g1h_arti5i_ble3d1ke2ng_o3o1z2j1lack_friday9ockbuster8g1omberg7ue3m_s1w2n_pparibas9o_ats3ehringer8fa2m1nd2o_k_ing5sch2tik2on4t1utique6x2r_adesco6idgestone9oadway5ker3ther5ussels7s1t1uild_ers6siness6y1zz3v1w1y1z_h3ca_b1fe2l_l1vinklein9m_era3p2non3petown5ital_one8r_avan4ds2e_er_s4s2sa1e1h1ino4t_ering5holic7ba1n1re2s2c1d1enter4o1rn3f_a1d2g1h_anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i_priani6rcle4sco3tadel4i_c2y_eats7k1l_aims4eaning6ick2nic1que6othing5ud3ub_med6m1n1o_ach3des3ffee4llege4ogne5m_cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking_channel11l1p2rsica5untry4pon_s4rses6pa2r_edit_card4union9icket5own3s1uise_s6u_isinella9v1w1x1y_mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e_al_er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si_gn4v2hl2iamonds6et2gital5rect_ory7scount3ver5h2y2j1k1m1np2o_cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c_o2deka3u_cation8e1g1mail3erck5nergy4gineer_ing9terprises10pson4quipment8r_icsson6ni3s_q1tate5t_isalat7u_rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n_s2rm_ers5shion4t3edex3edback6rrari3ero6i_at2delity5o2lm2nal1nce1ial7re_stone6mdale6sh_ing5t_ness6j1k1lickr3ghts4r2orist4wers5y2m1o_o_d_network8tball6rd1ex2sale4um3undation8x2r_ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n_d2rniture7tbol5yi3ga_l_lery3o1up4me_s3p1rden4y2b_iz3d_n2e_a1nt_ing5orge5f1g_ee3h1i_ft_s3ves2ing5l_ass3e1obal2o4m_ail3bh2o1x2n1odaddy5ld_point6f2o_dyear5g_le4p1t1v2p1q1r_ainger5phics5tis4een3ipe3ocery4up4s1t1u_ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc_bank7ealth_care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k_t2m1n1ockey4ldings5iday5medepot5goods5s_ense7nda3rse3spital5t_ing5t_eles2s3mail5use3w2r1sbc3t1u_ghes5yatt3undai7ibm2cbc2e1u2d1e_ee3fm2kano4l1m_amat4db2mo_bilien9n_c1dustries8finiti5o2g1k1stitute6urance4e4t_ernational10uit4vestments10o1piranga7q1r_ish4s_maili5t_anbul7t_au2v3jaguar4va3cb2e_ep2tzt3welry6io2ll2m_p2nj2o_bs1urg4t1y2p_morgan6rs3uegos4niper7kaufen5ddi3e_rryhotels6logistics9properties14fh2g1h1i_a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p_mg2n2r_d1ed3uokgroup8w1y_oto4z2la_caixa5mborghini8er3ncaster5ia3d_rover6xess5salle5t_ino3robe5w_yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i_dl2fe_insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan_s3cker3us3l1ndon4tte1o3ve3pl_financial11r1s1t_d_a3u_ndbeck6xe1ury5v1y2ma_cys3drid4if1son4keup4n_agement7go3p1rket_ing3s4riott5shalls7serati6ttel5ba2c_kinsey7d1e_d_ia3et2lbourne7me1orial6n_u2rckmsd7g1h1iami3crosoft7l1ni1t2t_subishi9k1l_b1s2m_a2n1o_bi_le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to_rcycles9v_ie4p1q1r1s_d2t_n1r2u_seum3ic3tual5v1w1x1y1z2na_b1goya4me2tura4vy3ba2c1e_c1t_bank4flix4work5ustar5w_s2xt_direct7us4f_l2g_o2hk2i_co2ke1on3nja3ssan1y5l1o_kia3rthwesternmutual14on4w_ruz3tv4p1r_a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan_group9dnavy5lo3m_ega4ne1g1l_ine5oo2pen3racle3nge4g_anic5igins6saka4tsuka4t2vh3pa_ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e_t2f_izer5g1h_armacy6d1ilips5one2to_graphy6s4ysio5ics1tet2ures6d1n_g1k2oneer5zza4k1l_ace2y_station9umbing5s3m1n_c2ohl2ker3litie5rn2st3r_america6xi3ess3ime3o_d_uctions8f1gressive8mo2perties3y5tection8u_dential9s1t1ub2w_c2y2qa1pon3uebec3st5racing4dio4e_ad1lestate6tor2y4cipes5d_stone5umbrella9hab3ise_n3t2liance6n_t_als5pair3ort3ublican8st_aurant8view_s5xroth6ich_ardli6oh3l1o1p2o_cher3ks3deo3gers4om3s_vp3u_gby3hr2n2w_e2yukyu6sa_arland6fe_ty4kura4le1on3msclub4ung5ndvik_coromant12ofi4p1rl2s1ve2xo3b_i1s2c_a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e_arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x_y3fr2g1h_angrila6rp2w2ell3ia1ksha5oes2p_ping5uji3w_time7i_lk2na1gles5te3j1k_i_n2y_pe4l_ing4m_art3ile4n_cf3o_ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa_ce3ort2t3r_l2s1t_ada2ples4r1tebank4farm7c_group6ockholm6rage3e3ream4udio2y3yle4u_cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y_dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x_i3c_i2d_k2eam2ch_nology8l1masek5nnis4va3f1g1h_d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j_maxx4x2k_maxx5l1m_all4n1o_day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r_ade1ing4ining5vel_channel7ers_insurance16ust3v2t1ube2i1nes3shu4v_s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va_cations7na1guard7c1e_gas3ntures6risign5mögensberater2ung14sicherung10t2g1i_ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u_elos6wales2mart4ter4ng_gou5tch_es6eather_channel12bcam3er2site5d_ding5ibo2r3f1hoswho6ien2ki2lliamhill9n_dows4e1ners6me2olterskluwer11odside6rk_s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u_tube6t1un3za_ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nvar encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत_म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里_大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\r\n * @template A\r\n * @template B\r\n * @param {A} target\r\n * @param {B} properties\r\n * @return {A & B}\r\n */\nvar assign = function assign(target, properties) {\n  for (var key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\r\n * Finite State Machine generation utilities\r\n */\n\n/**\r\n * @template T\r\n * @typedef {{ [group: string]: T[] }} Collections\r\n */\n\n/**\r\n * @typedef {{ [group: string]: true }} Flags\r\n */\n\n// Keys in scanner Collections instances\nvar numeric = 'numeric';\nvar ascii = 'ascii';\nvar alpha = 'alpha';\nvar asciinumeric = 'asciinumeric';\nvar alphanumeric = 'alphanumeric';\nvar domain = 'domain';\nvar emoji = 'emoji';\nvar scheme = 'scheme';\nvar slashscheme = 'slashscheme';\nvar whitespace = 'whitespace';\n\n/**\r\n * @template T\r\n * @param {string} name\r\n * @param {Collections<T>} groups to register in\r\n * @returns {T[]} Current list of tokens in the given collection\r\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\r\n * @template T\r\n * @param {T} t token to add\r\n * @param {Collections<T>} groups\r\n * @param {Flags} flags\r\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (var k in flags) {\n    var group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\r\n * @template T\r\n * @param {T} t token to check\r\n * @param {Collections<T>} groups\r\n * @returns {Flags} group flags that contain this token\r\n */\nfunction flagsForToken(t, groups) {\n  var result = {};\n  for (var c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\r\n * @template T\r\n * @typedef {null | T } Transition\r\n */\n\n/**\r\n * Define a basic state machine state. j is the list of character transitions,\r\n * jr is the list of regex-match transitions, jd is the default state to\r\n * transition to t is the accepting token type, if any. If this is the terminal\r\n * state, then it does not emit a token.\r\n *\r\n * The template type T represents the type of the token this state accepts. This\r\n * should be a string (such as of the token exports in `text.js`) or a\r\n * MultiToken subclass (from `multi.js`)\r\n *\r\n * @template T\r\n * @param {T} [token] Token that this state emits\r\n */\nfunction State(token) {\n  if (token === void 0) {\n    token = null;\n  }\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\r\n * Scanner token groups\r\n * @type Collections<string>\r\n */\nState.groups = {};\nState.prototype = {\n  accepts: function accepts() {\n    return !!this.t;\n  },\n  /**\r\n   * Follow an existing transition from the given input to the next state.\r\n   * Does not mutate.\r\n   * @param {string} input character or token type to transition on\r\n   * @returns {?State<T>} the next state, if any\r\n   */\n  go: function go(input) {\n    var state = this;\n    var nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (var i = 0; i < state.jr.length; i++) {\n      var regex = state.jr[i][0];\n      var _nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (_nextState && regex.test(input)) {\n        return _nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\r\n   * Whether the state has a transition for the given input. Set the second\r\n   * argument to true to only look for an exact match (and not a default or\r\n   * regular-expression-based transition)\r\n   * @param {string} input\r\n   * @param {boolean} exactOnly\r\n   */\n  has: function has(input, exactOnly) {\n    if (exactOnly === void 0) {\n      exactOnly = false;\n    }\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\r\n   * Short for \"transition all\"; create a transition from the array of items\r\n   * in the given list to the same final resulting state.\r\n   * @param {string | string[]} inputs Group of inputs to transition on\r\n   * @param {Transition<T> | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   */\n  ta: function ta(inputs, next, flags, groups) {\n    for (var i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\r\n   * Short for \"take regexp transition\"; defines a transition for this state\r\n   * when it encounters a token which matches the given regular expression\r\n   * @param {RegExp} regexp Regular expression transition (populate first)\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\n  tr: function tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    var nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\r\n   * Short for \"take transitions\", will take as many sequential transitions as\r\n   * the length of the given input and returns the\r\n   * resulting final state.\r\n   * @param {string | string[]} input\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\n  ts: function ts(input, next, flags, groups) {\n    var state = this;\n    var len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (var i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\r\n   * Short for \"take transition\", this is a method for building/working with\r\n   * state machines.\r\n   *\r\n   * If a state already exists for the given input, returns it.\r\n   *\r\n   * If a token is specified, that state will emit that token when reached by\r\n   * the linkify engine.\r\n   *\r\n   * If no state exists, it will be initialized with some default transitions\r\n   * that resemble existing default transitions.\r\n   *\r\n   * If a state is given for the second argument, that state will be\r\n   * transitioned to on the given input regardless of what that input\r\n   * previously did.\r\n   *\r\n   * Specify a token group flags to define groups that this token belongs to.\r\n   * The token will be added to corresponding entires in the given groups\r\n   * object.\r\n   *\r\n   * @param {string} input character, token type to transition on\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\n  tt: function tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    var state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    var t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    var nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          var allFlags = assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\nvar ta = function ta(state, input, next, flags, groups) {\n  return state.ta(input, next, flags, groups);\n};\n\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {RegExp} regexp\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\nvar tr = function tr(state, regexp, next, flags, groups) {\n  return state.tr(regexp, next, flags, groups);\n};\n\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\nvar ts = function ts(state, input, next, flags, groups) {\n  return state.ts(input, next, flags, groups);\n};\n\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string} input\r\n * @param {T | State<T>} [next]\r\n * @param {Collections<T>} [groups]\r\n * @param {Flags} [flags]\r\n */\nvar tt = function tt(state, input, next, flags, groups) {\n  return state.tt(input, next, flags, groups);\n};\n\n/******************************************************************************\r\nText Tokens\r\nIdentifiers for token outputs from the regexp scanner\r\n******************************************************************************/\n\n// A valid web domain token\nvar WORD = 'WORD'; // only contains a-z\nvar UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\n\n// Special case of word\nvar LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nvar TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nvar UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nvar SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nvar SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nvar NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nvar WS = 'WS';\n\n// New line (unix style)\nvar NL$1 = 'NL'; // \\n\n\n// Opening/closing bracket classes\nvar OPENBRACE = 'OPENBRACE'; // {\nvar OPENBRACKET = 'OPENBRACKET'; // [\nvar OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nvar OPENPAREN = 'OPENPAREN'; // (\nvar CLOSEBRACE = 'CLOSEBRACE'; // }\nvar CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nvar CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nvar CLOSEPAREN = 'CLOSEPAREN'; // )\n\n// Various symbols\nvar AMPERSAND = 'AMPERSAND'; // &\nvar APOSTROPHE = 'APOSTROPHE'; // '\nvar ASTERISK = 'ASTERISK'; // *\nvar AT = 'AT'; // @\nvar BACKSLASH = 'BACKSLASH'; // \\\nvar BACKTICK = 'BACKTICK'; // `\nvar CARET = 'CARET'; // ^\nvar COLON = 'COLON'; // :\nvar COMMA = 'COMMA'; // ,\nvar DOLLAR = 'DOLLAR'; // $\nvar DOT = 'DOT'; // .\nvar EQUALS = 'EQUALS'; // =\nvar EXCLAMATION = 'EXCLAMATION'; // !\nvar HYPHEN = 'HYPHEN'; // -\nvar PERCENT = 'PERCENT'; // %\nvar PIPE = 'PIPE'; // |\nvar PLUS = 'PLUS'; // +\nvar POUND = 'POUND'; // #\nvar QUERY = 'QUERY'; // ?\nvar QUOTE = 'QUOTE'; // \"\n\nvar SEMI = 'SEMI'; // ;\nvar SLASH = 'SLASH'; // /\nvar TILDE = 'TILDE'; // ~\nvar UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nvar EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nvar SYM = 'SYM';\nvar tk = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WORD: WORD,\n  UWORD: UWORD,\n  LOCALHOST: LOCALHOST,\n  TLD: TLD,\n  UTLD: UTLD,\n  SCHEME: SCHEME,\n  SLASH_SCHEME: SLASH_SCHEME,\n  NUM: NUM,\n  WS: WS,\n  NL: NL$1,\n  OPENBRACE: OPENBRACE,\n  OPENBRACKET: OPENBRACKET,\n  OPENANGLEBRACKET: OPENANGLEBRACKET,\n  OPENPAREN: OPENPAREN,\n  CLOSEBRACE: CLOSEBRACE,\n  CLOSEBRACKET: CLOSEBRACKET,\n  CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n  CLOSEPAREN: CLOSEPAREN,\n  AMPERSAND: AMPERSAND,\n  APOSTROPHE: APOSTROPHE,\n  ASTERISK: ASTERISK,\n  AT: AT,\n  BACKSLASH: BACKSLASH,\n  BACKTICK: BACKTICK,\n  CARET: CARET,\n  COLON: COLON,\n  COMMA: COMMA,\n  DOLLAR: DOLLAR,\n  DOT: DOT,\n  EQUALS: EQUALS,\n  EXCLAMATION: EXCLAMATION,\n  HYPHEN: HYPHEN,\n  PERCENT: PERCENT,\n  PIPE: PIPE,\n  PLUS: PLUS,\n  POUND: POUND,\n  QUERY: QUERY,\n  QUOTE: QUOTE,\n  SEMI: SEMI,\n  SLASH: SLASH,\n  TILDE: TILDE,\n  UNDERSCORE: UNDERSCORE,\n  EMOJI: EMOJI$1,\n  SYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nvar ASCII_LETTER = /[a-z]/;\nvar LETTER = /(?:[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD887][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF39\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD888[\\uDC00-\\uDFAF])/; // Any Unicode character with letter data type\nvar EMOJI = /(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC5\\uDECE-\\uDEDB\\uDEE0-\\uDEE8\\uDEF0-\\uDEF8])/; // Any Unicode emoji character\nvar EMOJI_VARIATION$1 = /\\ufe0f/;\nvar DIGIT = /\\d/;\nvar SPACE = /\\s/;\nvar regexp = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ASCII_LETTER: ASCII_LETTER,\n  LETTER: LETTER,\n  EMOJI: EMOJI,\n  EMOJI_VARIATION: EMOJI_VARIATION$1,\n  DIGIT: DIGIT,\n  SPACE: SPACE\n});\n\n/**\r\n\tThe scanner provides an interface that takes a string of text as input, and\r\n\toutputs an array of tokens instances that can be used for easy URL parsing.\r\n*/\nvar NL = '\\n'; // New line character\nvar EMOJI_VARIATION = \"\\uFE0F\"; // Variation selector, follows heart and others\nvar EMOJI_JOINER = \"\\u200D\"; // zero-width joiner\n\nvar tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\r\n * Scanner output token:\r\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\r\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\r\n * - `s` is the start index of the token in the original string\r\n * - `e` is the end index of the token in the original string\r\n * @typedef {{t: string, v: string, s: number, e: number}} Token\r\n */\n\n/**\r\n * @template T\r\n * @typedef {{ [collection: string]: T[] }} Collections\r\n */\n\n/**\r\n * Initialize the scanner character-based state machine for the given start\r\n * state\r\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\r\n * item is a length-2 tuple with the first element set to the string scheme, and\r\n * the second element set to `true` if the `://` after the scheme is optional\r\n */\nfunction init$2(customSchemes) {\n  if (customSchemes === void 0) {\n    customSchemes = [];\n  }\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  var groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  var Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  var Num = tr(Start, DIGIT, NUM, _defineProperty({}, numeric, true));\n  tr(Num, DIGIT, Num);\n\n  // State which emits a word token\n  var Word = tr(Start, ASCII_LETTER, WORD, _defineProperty({}, ascii, true));\n  tr(Word, ASCII_LETTER, Word);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  var UWord = tr(Start, LETTER, UWORD, _defineProperty({}, alpha, true));\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, LETTER, UWord);\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  var Ws = tr(Start, SPACE, WS, _defineProperty({}, whitespace, true));\n  tt(Start, NL, NL$1, _defineProperty({}, whitespace, true));\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  var Emoji = tr(Start, EMOJI, EMOJI$1, _defineProperty({}, emoji, true));\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  var EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  var wordjr = [[ASCII_LETTER, Word]];\n  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\n  for (var i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (var _i = 0; _i < utlds.length; _i++) {\n    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort(function (a, b) {\n    return a[0] > b[0] ? 1 : -1;\n  });\n  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {\n    var sch = customSchemes[_i2][0];\n    var optionalSlashSlash = customSchemes[_i2][1];\n    var flags = optionalSlashSlash ? _defineProperty({}, scheme, true) : _defineProperty({}, slashscheme, true);\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: assign({\n      groups: groups\n    }, tk)\n  };\n}\n\n/**\r\n\tGiven a string, returns an array of TOKEN instances representing the\r\n\tcomposition of that string.\r\n\r\n\t@method run\r\n\t@param {State<string>} start scanner starting state\r\n\t@param {string} str input string to scan\r\n\t@return {Token[]} list of tokens, each with a type and value\r\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {\n    return c.toLowerCase();\n  }));\n  var charCount = iterable.length; // <= len if there are emojis, etc\n  var tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  var cursor = 0;\n\n  // Cursor through the array-representation of the string\n  var charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    var state = start;\n    var nextState = null;\n    var tokenLength = 0;\n    var latestAccepting = null;\n    var sinceAccepts = -1;\n    var charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\r\n * Convert a String to an Array of characters, taking into account that some\r\n * characters like emojis take up two string indexes.\r\n *\r\n * Adapted from core-js (MIT license)\r\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\r\n *\r\n * @function stringToArray\r\n * @param {string} str\r\n * @returns {string[]}\r\n */\nfunction stringToArray(str) {\n  var result = [];\n  var len = str.length;\n  var index = 0;\n  while (index < len) {\n    var first = str.charCodeAt(index);\n    var second = void 0;\n    var char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\r\n * Fast version of ts function for when transition defaults are well known\r\n * @param {State<string>} state\r\n * @param {string} input\r\n * @param {string} t\r\n * @param {string} defaultt\r\n * @param {[RegExp, State<string>][]} jr\r\n * @returns {State<string>}\r\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  var next;\n  var len = input.length;\n  for (var i = 0; i < len - 1; i++) {\n    var char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\r\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\r\n * into a list of strings.\r\n * @param {str} encoded encoded TLDs string\r\n * @returns {str[]} original TLDs list\r\n */\nfunction decodeTlds(encoded) {\n  var words = [];\n  var stack = [];\n  var i = 0;\n  var digits = '0123456789';\n  while (i < encoded.length) {\n    var popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      var popCount = parseInt(encoded.substring(i, i + popDigitCount), 10);\n      for (; popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else if (encoded[i] === '_') {\n      words.push(stack.join('')); // found a word, will be followed by another\n      i++;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\r\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\r\n * and each value is an event handler function.\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\r\n * @typedef {?{ [event: string]: Function }} EventListeners\r\n */\n\n/**\r\n * All formatted properties required to render a link, including `tagName`,\r\n * `attributes`, `content` and `eventListeners`.\r\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\r\n * eventListeners: EventListeners }} IntermediateRepresentation\r\n */\n\n/**\r\n * Specify either an object described by the template type `O` or a function.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `O`\r\n * @template O\r\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\r\n */\n\n/**\r\n * Specify either a function described by template type `F` or an object.\r\n *\r\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\r\n * value should be a function with template type `F` that is called when the\r\n * corresponding link type is encountered.\r\n * @template F\r\n * @typedef {F | { [type: string]: F}} OptFn\r\n */\n\n/**\r\n * Specify either a value with template type `V`, a function that returns `V` or\r\n * an object where each value resolves to `V`.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `V`\r\n *\r\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\r\n * Each value should either have type `V` or a function that returns V. This\r\n * function similarly takes a string value and a token.\r\n *\r\n * Example valid types for `Opt<string>`:\r\n *\r\n * ```js\r\n * 'hello'\r\n * (value, type, token) => 'world'\r\n * { url: 'hello', email: (value, token) => 'world'}\r\n * ```\r\n * @template V\r\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\r\n */\n\n/**\r\n * See available options: https://linkify.js.org/docs/options.html\r\n * @typedef {{\r\n * \tdefaultProtocol?: string,\r\n *  events?: OptObj<EventListeners>,\r\n * \tformat?: Opt<string>,\r\n * \tformatHref?: Opt<string>,\r\n * \tnl2br?: boolean,\r\n * \ttagName?: Opt<any>,\r\n * \ttarget?: Opt<string>,\r\n * \trel?: Opt<string>,\r\n * \tvalidate?: Opt<boolean>,\r\n * \ttruncate?: Opt<number>,\r\n * \tclassName?: Opt<string>,\r\n * \tattributes?: OptObj<({ [attr: string]: any })>,\r\n *  ignoreTags?: string[],\r\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\r\n * }} Opts\r\n */\n\n/**\r\n * @type Required<Opts>\r\n */\nvar defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\r\n * Utility class for linkify interfaces to apply specified\r\n * {@link Opts formatting and rendering options}.\r\n *\r\n * @param {Opts | Options} [opts] Option value overrides.\r\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\r\n *   internal use) default render function that determines how to generate an\r\n *   HTML element based on a link token's derived tagName, attributes and HTML.\r\n *   Similar to render option\r\n */\nfunction Options(opts, defaultRender) {\n  if (defaultRender === void 0) {\n    defaultRender = null;\n  }\n  var o = assign({}, defaults);\n  if (opts) {\n    o = assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  var ignoredTags = o.ignoreTags;\n  var uppercaseIgnoredTags = [];\n  for (var i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\r\n   * @type string[]\r\n   */\n  ignoreTags: [],\n  /**\r\n   * @param {IntermediateRepresentation} ir\r\n   * @returns {any}\r\n   */\n  defaultRender: function defaultRender(ir) {\n    return ir;\n  },\n  /**\r\n   * Returns true or false based on whether a token should be displayed as a\r\n   * link based on the user options.\r\n   * @param {MultiToken} token\r\n   * @returns {boolean}\r\n   */\n  check: function check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n  /**\r\n   * Resolve an option's value based on the value of the option and the given\r\n   * params. If operator and token are specified and the target option is\r\n   * callable, automatically calls the function with the given argument.\r\n   * @template {keyof Opts} K\r\n   * @param {K} key Name of option to use\r\n   * @param {string} [operator] will be passed to the target option if it's a\r\n   * function. If not specified, RAW function value gets returned\r\n   * @param {MultiToken} [token] The token from linkify.tokenize\r\n   * @returns {Opts[K] | any}\r\n   */\n  get: function get(key, operator, token) {\n    var isCallable = operator != null;\n    var option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\r\n   * @template {keyof Opts} L\r\n   * @param {L} key Name of options object to use\r\n   * @param {string} [operator]\r\n   * @param {MultiToken} [token]\r\n   * @returns {Opts[L] | any}\r\n   */\n  getObj: function getObj(key, operator, token) {\n    var obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\r\n   * Convert the given token to a rendered element that may be added to the\r\n   * calling-interface's DOM\r\n   * @param {MultiToken} token Token to render to an HTML element\r\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\r\n   *   Component, etc.\r\n   */\n  render: function render(token) {\n    var ir = token.render(this); // intermediate representation\n    var renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\nvar options = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  defaults: defaults,\n  Options: Options,\n  assign: assign\n});\n\n/******************************************************************************\r\n\tMulti-Tokens\r\n\tTokens composed of arrays of TextTokens\r\n******************************************************************************/\n\n/**\r\n * @param {string} value\r\n * @param {Token[]} tokens\r\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\r\n * Abstract class used for manufacturing tokens of text tokens. That is rather\r\n * than the value for a token being a small string of text, it's value an array\r\n * of text tokens.\r\n *\r\n * Used for grouping together URLs, emails, hashtags, and other potential\r\n * creations.\r\n * @class MultiToken\r\n * @property {string} t\r\n * @property {string} v\r\n * @property {Token[]} tk\r\n * @abstract\r\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\r\n   * Return the string this token represents.\r\n   * @return {string}\r\n   */\n  toString: function toString() {\n    return this.v;\n  },\n  /**\r\n   * What should the value for this token be in the `href` HTML attribute?\r\n   * Returns the `.toString` value by default.\r\n   * @param {string} [scheme]\r\n   * @return {string}\r\n  */\n  toHref: function toHref(scheme) {\n    return this.toString();\n  },\n  /**\r\n   * @param {Options} options Formatting options\r\n   * @returns {string}\r\n   */\n  toFormattedString: function toFormattedString(options) {\n    var val = this.toString();\n    var truncate = options.get('truncate', val, this);\n    var formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\r\n   *\r\n   * @param {Options} options\r\n   * @returns {string}\r\n   */\n  toFormattedHref: function toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\r\n   * The start index of this token in the original input string\r\n   * @returns {number}\r\n   */\n  startIndex: function startIndex() {\n    return this.tk[0].s;\n  },\n  /**\r\n   * The end index of this token in the original input string (up to this\r\n   * index but not including it)\r\n   * @returns {number}\r\n   */\n  endIndex: function endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\r\n  \tReturns an object  of relevant values for this token, which includes keys\r\n  \t* type - Kind of token ('url', 'email', etc.)\r\n  \t* value - Original text\r\n  \t* href - The value that should be added to the anchor tag's href\r\n  \t\tattribute\r\n  \t\t@method toObject\r\n  \t@param {string} [protocol] `'http'` by default\r\n  */\n  toObject: function toObject(protocol) {\n    if (protocol === void 0) {\n      protocol = defaults.defaultProtocol;\n    }\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\r\n   *\r\n   * @param {Options} options Formatting option\r\n   */\n  toFormattedObject: function toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\r\n   * Whether this token should be rendered as a link according to the given options\r\n   * @param {Options} options\r\n   * @returns {boolean}\r\n   */\n  validate: function validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\r\n   * Return an object that represents how this link should be rendered.\r\n   * @param {Options} options Formattinng options\r\n   */\n  render: function render(options) {\n    var token = this;\n    var href = this.toFormattedHref(options);\n    var tagName = options.get('tagName', href, token);\n    var content = this.toFormattedString(options);\n    var attributes = {};\n    var className = options.get('className', href, token);\n    var target = options.get('target', href, token);\n    var rel = options.get('rel', href, token);\n    var attrs = options.getObj('attributes', href, token);\n    var eventListeners = options.getObj('events', href, token);\n    attributes.href = href;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      assign(attributes, attrs);\n    }\n    return {\n      tagName: tagName,\n      attributes: attributes,\n      content: content,\n      eventListeners: eventListeners\n    };\n  }\n};\n\n/**\r\n * Create a new token that can be emitted by the parser state machine\r\n * @param {string} type readable type of the token\r\n * @param {object} props properties to assign or override, including isLink = true or false\r\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\r\n */\nfunction createTokenClass(type, props) {\n  var Token = /*#__PURE__*/function (_MultiToken) {\n    _inherits(Token, _MultiToken);\n    var _super = _createSuper(Token);\n    function Token(value, tokens) {\n      var _this;\n      _classCallCheck(this, Token);\n      _this = _super.call(this, value, tokens);\n      _this.t = type;\n      return _this;\n    }\n    return _createClass(Token);\n  }(MultiToken);\n  for (var p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\r\n\tRepresents a list of tokens making up a valid email address\r\n*/\nvar Email = createTokenClass('email', {\n  isLink: true,\n  toHref: function toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\r\n\tRepresents some plain text\r\n*/\nvar Text = createTokenClass('text');\n\n/**\r\n\tMulti-linebreak token - represents a line break\r\n\t@class Nl\r\n*/\nvar Nl = createTokenClass('nl');\n\n/**\r\n\tRepresents a list of text tokens making up a valid URL\r\n\t@class Url\r\n*/\nvar Url = createTokenClass('url', {\n  isLink: true,\n  /**\r\n  \tLowercases relevant parts of the domain and adds the protocol if\r\n  \trequired. Note that this will not escape unsafe HTML characters in the\r\n  \tURL.\r\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\r\n  \t@return {string} the full href\r\n  */\n  toHref: function toHref(scheme) {\n    if (scheme === void 0) {\n      scheme = defaults.defaultProtocol;\n    }\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : \"\".concat(scheme, \"://\").concat(this.v);\n  },\n  /**\r\n   * Check whether this URL token has a protocol\r\n   * @return {boolean}\r\n   */\n  hasProtocol: function hasProtocol() {\n    var tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\nvar multi = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MultiToken: MultiToken,\n  Base: MultiToken,\n  createTokenClass: createTokenClass,\n  Email: Email,\n  Text: Text,\n  Nl: Nl,\n  Url: Url\n});\n\n/**\r\n\tNot exactly parser, more like the second-stage scanner (although we can\r\n\ttheoretically hotswap the code here with a real parser in the future... but\r\n\tfor a little URL-finding utility abstract syntax trees may be a little\r\n\toverkill).\r\n\r\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\r\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\r\n\treference)\r\n\r\n\t@module linkify\r\n\t@submodule parser\r\n\t@main run\r\n*/\nvar makeState = function makeState(arg) {\n  return new State(arg);\n};\n\n/**\r\n * Generate the parser multi token-based state machine\r\n * @param {{ groups: Collections<string> }} tokens\r\n */\nfunction init$1(_ref) {\n  var groups = _ref.groups;\n  // Types of characters the URL can definitely end in\n  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\r\n   * @type State<Token>\r\n   */\n  var Start = makeState();\n  var Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  var Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  var LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  var LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  var EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  var EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  var Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  var EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  var EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  var DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  var DomainDot = tt(Domain, DOT); // domain followed by DOT\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  var DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  var DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  var DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  var Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  var UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  var UriPrefix = tt(Scheme, COLON); // e.g., 'mailto:' or 'http://'\n  var SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  var SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  tt(SlashSchemeColonSlash, SLASH, UriPrefix);\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(UriPrefix, groups.domain, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n\n  // URL, followed by an opening bracket\n  var UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\n  var UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\n  var UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\n  var UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\n\n  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\n  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\n  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\n  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);\n\n  // Closing bracket component. This character WILL be included in the URL\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparen, CLOSEPAREN, Url$1);\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n\n  // URL that beings with an opening bracket, followed by a symbols.\n  // Note that the final state can still be `UrlOpenbrace` (if the URL only\n  // has a single opening bracket for some reason).\n  var UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\n  var UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\n  var UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\n  var UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\n  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\n  var UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\n  var UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\n  var UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\n  var UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\n  ta(UrlOpenbrace, qsNonAccepting);\n  ta(UrlOpenbracket, qsNonAccepting);\n  ta(UrlOpenanglebracket, qsNonAccepting);\n  ta(UrlOpenparen, qsNonAccepting);\n\n  // URL that begins with an opening bracket, followed by some symbols\n  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\n  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\n  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);\n\n  // Close brace/bracket to become regular URL\n  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL$1, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\r\n * Run the parser state machine on a list of scanned string-based tokens to\r\n * create a list of multi tokens, each of which represents a URL, email address,\r\n * plain text, etc.\r\n *\r\n * @param {State<MultiToken>} start parser start state\r\n * @param {string} input the original input used to generate the given tokens\r\n * @param {Token[]} tokens list of scanned tokens\r\n * @returns {MultiToken[]}\r\n */\nfunction run(start, input, tokens) {\n  var len = tokens.length;\n  var cursor = 0;\n  var multis = [];\n  var textTokens = [];\n  while (cursor < len) {\n    var state = start;\n    var secondState = null;\n    var nextState = null;\n    var multiLength = 0;\n    var latestAccepting = null;\n    var sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      var Multi = latestAccepting.t;\n      var subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\r\n * Utility function for instantiating a new multitoken with all the relevant\r\n * fields during parsing.\r\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\r\n * @param {string} input original input string\r\n * @param {Token[]} tokens consecutive tokens scanned from input string\r\n * @returns {MultiToken}\r\n */\nfunction initMultiToken(Multi, input, tokens) {\n  var startIdx = tokens[0].s;\n  var endIdx = tokens[tokens.length - 1].e;\n  var value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\nvar warn = typeof console !== 'undefined' && console && console.warn || function () {};\nvar warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nvar INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\r\n * @typedef {{\r\n * \tstart: State<string>,\r\n * \ttokens: { groups: Collections<string> } & typeof tk\r\n * }} ScannerInit\r\n */\n\n/**\r\n * @typedef {{\r\n * \tstart: State<MultiToken>,\r\n * \ttokens: typeof multi\r\n * }} ParserInit\r\n */\n\n/**\r\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\r\n */\n\n/**\r\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\r\n */\n\n/**\r\n * De-register all plugins and reset the internal state-machine. Used for\r\n * testing; not required in practice.\r\n * @private\r\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n}\n\n/**\r\n * Register a token plugin to allow the scanner to recognize additional token\r\n * types before the parser state machine is constructed from the results.\r\n * @param {string} name of plugin to register\r\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\r\n * and available scanner tokens and collections and extends the state machine to\r\n * recognize additional tokens or groups.\r\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(\"linkifyjs: Invalid token plugin \".concat(plugin, \" (expects function)\"));\n  }\n  for (var i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(\"linkifyjs: token plugin \\\"\".concat(name, \"\\\" already registered - will be overwritten\"));\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register token plugin \\\"\".concat(name, \"\\\" \").concat(warnAdvice));\n  }\n}\n\n/**\r\n * Register a linkify plugin\r\n * @param {string} name of plugin to register\r\n * @param {Plugin} plugin function that accepts the parser state machine and\r\n * extends the parser to recognize additional link types\r\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(\"linkifyjs: Invalid plugin \".concat(plugin, \" (expects function)\"));\n  }\n  for (var i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(\"linkifyjs: plugin \\\"\".concat(name, \"\\\" already registered - will be overwritten\"));\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register plugin \\\"\".concat(name, \"\\\" \").concat(warnAdvice));\n  }\n}\n\n/**\r\n * Detect URLs with the following additional protocol. Anything with format\r\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\r\n * `true`, anything with format \"protocol:...\" will be considered a link.\r\n * @param {string} protocol\r\n * @param {boolean} [optionalSlashSlash]\r\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\n  if (optionalSlashSlash === void 0) {\n    optionalSlashSlash = false;\n  }\n  if (INIT.initialized) {\n    warn(\"linkifyjs: already initialized - will not register custom scheme \\\"\".concat(scheme, \"\\\" \").concat(warnAdvice));\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\r\n * Initialize the linkify state machine. Called automatically the first time\r\n * linkify is called on a string, but may be called manually as well.\r\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (var i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (var _i3 = 0; _i3 < INIT.pluginQueue.length; _i3++) {\n    INIT.pluginQueue[_i3][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n}\n\n/**\r\n * Parse a string into tokens that represent linkable and non-linkable sub-components\r\n * @param {string} str\r\n * @return {MultiToken[]} tokens\r\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n\n/**\r\n * Find a list of linkable items in the given string.\r\n * @param {string} str string to find links in\r\n * @param {string | Opts} [type] either formatting options or specific type of\r\n * links to find, e.g., 'url' or 'email'\r\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\r\n * if opts already provided in `type` argument\r\n*/\nfunction find(str, type, opts) {\n  if (type === void 0) {\n    type = null;\n  }\n  if (opts === void 0) {\n    opts = null;\n  }\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(\"linkifyjs: Invalid link type \".concat(type, \"; must be a string\"));\n    }\n    opts = type;\n    type = null;\n  }\n  var options = new Options(opts);\n  var tokens = tokenize(str);\n  var filtered = [];\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (token.isLink && (!type || token.t === type)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\r\n * Is the given string valid linkable text of some sort. Note that this does not\r\n * trim the text for you.\r\n *\r\n * Optionally pass in a second `type` param, which is the type of link to test\r\n * for.\r\n *\r\n * For example,\r\n *\r\n *     linkify.test(str, 'email');\r\n *\r\n * Returns `true` if str is a valid email.\r\n * @param {string} str string to test for links\r\n * @param {string} [type] optional specific link type to look for\r\n * @returns boolean true/false\r\n */\nfunction test(str, type) {\n  if (type === void 0) {\n    type = null;\n  }\n  var tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };","map":{"version":3,"names":["encodedTlds","encodedUtlds","assign","target","properties","key","numeric","ascii","alpha","asciinumeric","alphanumeric","domain","emoji","scheme","slashscheme","whitespace","registerGroup","name","groups","addToGroups","t","flags","k","group","indexOf","push","flagsForToken","result","c","State","token","j","jr","jd","prototype","accepts","go","input","state","nextState","i","length","regex","test","has","exactOnly","ta","inputs","next","tt","tr","regexp","ts","len","templateState","apply","allFlags","WORD","UWORD","LOCALHOST","TLD","UTLD","SCHEME","SLASH_SCHEME","NUM","WS","NL$1","OPENBRACE","OPENBRACKET","OPENANGLEBRACKET","OPENPAREN","CLOSEBRACE","CLOSEBRACKET","CLOSEANGLEBRACKET","CLOSEPAREN","AMPERSAND","APOSTROPHE","ASTERISK","AT","BACKSLASH","BACKTICK","CARET","COLON","COMMA","DOLLAR","DOT","EQUALS","EXCLAMATION","HYPHEN","PERCENT","PIPE","PLUS","POUND","QUERY","QUOTE","SEMI","SLASH","TILDE","UNDERSCORE","EMOJI$1","SYM","tk","Object","freeze","__proto__","NL","EMOJI","ASCII_LETTER","LETTER","EMOJI_VARIATION$1","DIGIT","SPACE","EMOJI_VARIATION","EMOJI_JOINER","tlds","utlds","init$2","customSchemes","Start","decodeTlds","Num","Word","UWord","Ws","Emoji","EmojiJoiner","wordjr","uwordjr","fastts","tld","utld","sort","a","b","sch","optionalSlashSlash","start","tokens","run$1","str","iterable","stringToArray","replace","toLowerCase","charCount","cursor","charCursor","tokenLength","latestAccepting","sinceAccepts","charsSinceAccepts","v","slice","s","e","index","first","charCodeAt","second","char","defaultt","encoded","words","stack","digits","popDigitCount","join","popCount","parseInt","substring","pop","defaults","defaultProtocol","events","format","noop","formatHref","nl2br","tagName","rel","validate","truncate","Infinity","className","attributes","ignoreTags","render","Options","opts","defaultRender","o","ignoredTags","uppercaseIgnoredTags","toUpperCase","ir","check","get","toString","operator","isCallable","option","getObj","obj","renderFn","val","options","MultiToken","value","isLink","toHref","toFormattedString","formatted","toFormattedHref","startIndex","endIndex","toObject","protocol","type","href","end","toFormattedObject","content","attrs","eventListeners","class","createTokenClass","props","Token","p","Email","Text","Nl","Url","hasProtocol","multi","Base","makeState","arg","init$1","_ref","qsAccepting","concat","qsNonAccepting","localpartAccepting","Localpart","Domain","Scheme","SlashScheme","LocalpartAt","LocalpartDot","EmailDomain","EmailDomainDot","Email$1","EmailDomainHyphen","EmailColon","DomainHyphen","DomainDot","DomainDotTld","DomainDotTldColon","DomainDotTldColonPort","Url$1","UrlNonaccept","UriPrefix","SlashSchemeColon","SlashSchemeColonSlash","UrlOpenbrace","UrlOpenbracket","UrlOpenanglebracket","UrlOpenparen","UrlOpenbraceQ","UrlOpenbracketQ","UrlOpenanglebracketQ","UrlOpenparenQ","UrlOpenbraceSyms","UrlOpenbracketSyms","UrlOpenanglebracketSyms","UrlOpenparenSyms","run","multis","textTokens","secondState","multiLength","initMultiToken","Multi","subtokens","startIdx","endIdx","warn","console","warnAdvice","INIT","scanner","parser","tokenQueue","pluginQueue","initialized","reset","registerTokenPlugin","plugin","Error","registerPlugin","registerCustomProtocol","init","tokenize","find","filtered"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/linkifyjs/dist/linkify.es.js"],"sourcesContent":["// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\r\n// See update-tlds.js for encoding/decoding format\r\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\r\nconst encodedTlds = 'aaa1rp3barth4b_ott3vie4c1le2ogado5udhabi7c_ademy5centure6ountant_s9o1tor4d_s1ult4e_g1ro2tna4f_l1rica5g_akhan5ency5i_g1rbus3force5tel5kdn3l_faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m_azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o_l2partments8p_le4q_uarelle8r_ab1mco4chi3my2pa2t_e3s_da2ia2sociates9t_hleta5torney7u_ction5di_ble3o3spost5thor3o_s4vianca6w_s2x_a2z_ure5ba_by2idu3namex3narepublic11d1k2r_celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b_c1t1va3cg1n2d1e_ats2uty4er2ntley5rlin4st_buy5t2f1g1h_arti5i_ble3d1ke2ng_o3o1z2j1lack_friday9ockbuster8g1omberg7ue3m_s1w2n_pparibas9o_ats3ehringer8fa2m1nd2o_k_ing5sch2tik2on4t1utique6x2r_adesco6idgestone9oadway5ker3ther5ussels7s1t1uild_ers6siness6y1zz3v1w1y1z_h3ca_b1fe2l_l1vinklein9m_era3p2non3petown5ital_one8r_avan4ds2e_er_s4s2sa1e1h1ino4t_ering5holic7ba1n1re2s2c1d1enter4o1rn3f_a1d2g1h_anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i_priani6rcle4sco3tadel4i_c2y_eats7k1l_aims4eaning6ick2nic1que6othing5ud3ub_med6m1n1o_ach3des3ffee4llege4ogne5m_cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking_channel11l1p2rsica5untry4pon_s4rses6pa2r_edit_card4union9icket5own3s1uise_s6u_isinella9v1w1x1y_mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e_al_er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si_gn4v2hl2iamonds6et2gital5rect_ory7scount3ver5h2y2j1k1m1np2o_cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c_o2deka3u_cation8e1g1mail3erck5nergy4gineer_ing9terprises10pson4quipment8r_icsson6ni3s_q1tate5t_isalat7u_rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n_s2rm_ers5shion4t3edex3edback6rrari3ero6i_at2delity5o2lm2nal1nce1ial7re_stone6mdale6sh_ing5t_ness6j1k1lickr3ghts4r2orist4wers5y2m1o_o_d_network8tball6rd1ex2sale4um3undation8x2r_ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n_d2rniture7tbol5yi3ga_l_lery3o1up4me_s3p1rden4y2b_iz3d_n2e_a1nt_ing5orge5f1g_ee3h1i_ft_s3ves2ing5l_ass3e1obal2o4m_ail3bh2o1x2n1odaddy5ld_point6f2o_dyear5g_le4p1t1v2p1q1r_ainger5phics5tis4een3ipe3ocery4up4s1t1u_ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc_bank7ealth_care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k_t2m1n1ockey4ldings5iday5medepot5goods5s_ense7nda3rse3spital5t_ing5t_eles2s3mail5use3w2r1sbc3t1u_ghes5yatt3undai7ibm2cbc2e1u2d1e_ee3fm2kano4l1m_amat4db2mo_bilien9n_c1dustries8finiti5o2g1k1stitute6urance4e4t_ernational10uit4vestments10o1piranga7q1r_ish4s_maili5t_anbul7t_au2v3jaguar4va3cb2e_ep2tzt3welry6io2ll2m_p2nj2o_bs1urg4t1y2p_morgan6rs3uegos4niper7kaufen5ddi3e_rryhotels6logistics9properties14fh2g1h1i_a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p_mg2n2r_d1ed3uokgroup8w1y_oto4z2la_caixa5mborghini8er3ncaster5ia3d_rover6xess5salle5t_ino3robe5w_yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i_dl2fe_insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan_s3cker3us3l1ndon4tte1o3ve3pl_financial11r1s1t_d_a3u_ndbeck6xe1ury5v1y2ma_cys3drid4if1son4keup4n_agement7go3p1rket_ing3s4riott5shalls7serati6ttel5ba2c_kinsey7d1e_d_ia3et2lbourne7me1orial6n_u2rckmsd7g1h1iami3crosoft7l1ni1t2t_subishi9k1l_b1s2m_a2n1o_bi_le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to_rcycles9v_ie4p1q1r1s_d2t_n1r2u_seum3ic3tual5v1w1x1y1z2na_b1goya4me2tura4vy3ba2c1e_c1t_bank4flix4work5ustar5w_s2xt_direct7us4f_l2g_o2hk2i_co2ke1on3nja3ssan1y5l1o_kia3rthwesternmutual14on4w_ruz3tv4p1r_a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan_group9dnavy5lo3m_ega4ne1g1l_ine5oo2pen3racle3nge4g_anic5igins6saka4tsuka4t2vh3pa_ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e_t2f_izer5g1h_armacy6d1ilips5one2to_graphy6s4ysio5ics1tet2ures6d1n_g1k2oneer5zza4k1l_ace2y_station9umbing5s3m1n_c2ohl2ker3litie5rn2st3r_america6xi3ess3ime3o_d_uctions8f1gressive8mo2perties3y5tection8u_dential9s1t1ub2w_c2y2qa1pon3uebec3st5racing4dio4e_ad1lestate6tor2y4cipes5d_stone5umbrella9hab3ise_n3t2liance6n_t_als5pair3ort3ublican8st_aurant8view_s5xroth6ich_ardli6oh3l1o1p2o_cher3ks3deo3gers4om3s_vp3u_gby3hr2n2w_e2yukyu6sa_arland6fe_ty4kura4le1on3msclub4ung5ndvik_coromant12ofi4p1rl2s1ve2xo3b_i1s2c_a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e_arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x_y3fr2g1h_angrila6rp2w2ell3ia1ksha5oes2p_ping5uji3w_time7i_lk2na1gles5te3j1k_i_n2y_pe4l_ing4m_art3ile4n_cf3o_ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa_ce3ort2t3r_l2s1t_ada2ples4r1tebank4farm7c_group6ockholm6rage3e3ream4udio2y3yle4u_cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y_dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x_i3c_i2d_k2eam2ch_nology8l1masek5nnis4va3f1g1h_d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j_maxx4x2k_maxx5l1m_all4n1o_day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r_ade1ing4ining5vel_channel7ers_insurance16ust3v2t1ube2i1nes3shu4v_s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va_cations7na1guard7c1e_gas3ntures6risign5mögensberater2ung14sicherung10t2g1i_ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u_elos6wales2mart4ter4ng_gou5tch_es6eather_channel12bcam3er2site5d_ding5ibo2r3f1hoswho6ien2ki2lliamhill9n_dows4e1ners6me2olterskluwer11odside6rk_s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u_tube6t1un3za_ppos4ra3ero3ip2m1one3uerich6w2';\r\n// Internationalized domain names containing non-ASCII\r\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत_म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里_大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\r\n\r\n/**\r\n * @template A\r\n * @template B\r\n * @param {A} target\r\n * @param {B} properties\r\n * @return {A & B}\r\n */\r\nconst assign = (target, properties) => {\r\n  for (const key in properties) {\r\n    target[key] = properties[key];\r\n  }\r\n  return target;\r\n};\r\n\r\n/**\r\n * Finite State Machine generation utilities\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [group: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * @typedef {{ [group: string]: true }} Flags\r\n */\r\n\r\n// Keys in scanner Collections instances\r\nconst numeric = 'numeric';\r\nconst ascii = 'ascii';\r\nconst alpha = 'alpha';\r\nconst asciinumeric = 'asciinumeric';\r\nconst alphanumeric = 'alphanumeric';\r\nconst domain = 'domain';\r\nconst emoji = 'emoji';\r\nconst scheme = 'scheme';\r\nconst slashscheme = 'slashscheme';\r\nconst whitespace = 'whitespace';\r\n\r\n/**\r\n * @template T\r\n * @param {string} name\r\n * @param {Collections<T>} groups to register in\r\n * @returns {T[]} Current list of tokens in the given collection\r\n */\r\nfunction registerGroup(name, groups) {\r\n  if (!(name in groups)) {\r\n    groups[name] = [];\r\n  }\r\n  return groups[name];\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to add\r\n * @param {Collections<T>} groups\r\n * @param {Flags} flags\r\n */\r\nfunction addToGroups(t, flags, groups) {\r\n  if (flags[numeric]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[ascii]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alpha] = true;\r\n  }\r\n  if (flags[asciinumeric]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alpha]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alphanumeric]) {\r\n    flags[domain] = true;\r\n  }\r\n  if (flags[emoji]) {\r\n    flags[domain] = true;\r\n  }\r\n  for (const k in flags) {\r\n    const group = registerGroup(k, groups);\r\n    if (group.indexOf(t) < 0) {\r\n      group.push(t);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to check\r\n * @param {Collections<T>} groups\r\n * @returns {Flags} group flags that contain this token\r\n */\r\nfunction flagsForToken(t, groups) {\r\n  const result = {};\r\n  for (const c in groups) {\r\n    if (groups[c].indexOf(t) >= 0) {\r\n      result[c] = true;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @template T\r\n * @typedef {null | T } Transition\r\n */\r\n\r\n/**\r\n * Define a basic state machine state. j is the list of character transitions,\r\n * jr is the list of regex-match transitions, jd is the default state to\r\n * transition to t is the accepting token type, if any. If this is the terminal\r\n * state, then it does not emit a token.\r\n *\r\n * The template type T represents the type of the token this state accepts. This\r\n * should be a string (such as of the token exports in `text.js`) or a\r\n * MultiToken subclass (from `multi.js`)\r\n *\r\n * @template T\r\n * @param {T} [token] Token that this state emits\r\n */\r\nfunction State(token) {\r\n  if (token === void 0) {\r\n    token = null;\r\n  }\r\n  // this.n = null; // DEBUG: State name\r\n  /** @type {{ [input: string]: State<T> }} j */\r\n  this.j = {}; // IMPLEMENTATION 1\r\n  // this.j = []; // IMPLEMENTATION 2\r\n  /** @type {[RegExp, State<T>][]} jr */\r\n  this.jr = [];\r\n  /** @type {?State<T>} jd */\r\n  this.jd = null;\r\n  /** @type {?T} t */\r\n  this.t = token;\r\n}\r\n\r\n/**\r\n * Scanner token groups\r\n * @type Collections<string>\r\n */\r\nState.groups = {};\r\nState.prototype = {\r\n  accepts() {\r\n    return !!this.t;\r\n  },\r\n  /**\r\n   * Follow an existing transition from the given input to the next state.\r\n   * Does not mutate.\r\n   * @param {string} input character or token type to transition on\r\n   * @returns {?State<T>} the next state, if any\r\n   */\r\n  go(input) {\r\n    const state = this;\r\n    const nextState = state.j[input];\r\n    if (nextState) {\r\n      return nextState;\r\n    }\r\n    for (let i = 0; i < state.jr.length; i++) {\r\n      const regex = state.jr[i][0];\r\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\r\n      if (nextState && regex.test(input)) {\r\n        return nextState;\r\n      }\r\n    }\r\n    // Nowhere left to jump! Return default, if any\r\n    return state.jd;\r\n  },\r\n  /**\r\n   * Whether the state has a transition for the given input. Set the second\r\n   * argument to true to only look for an exact match (and not a default or\r\n   * regular-expression-based transition)\r\n   * @param {string} input\r\n   * @param {boolean} exactOnly\r\n   */\r\n  has(input, exactOnly) {\r\n    if (exactOnly === void 0) {\r\n      exactOnly = false;\r\n    }\r\n    return exactOnly ? input in this.j : !!this.go(input);\r\n  },\r\n  /**\r\n   * Short for \"transition all\"; create a transition from the array of items\r\n   * in the given list to the same final resulting state.\r\n   * @param {string | string[]} inputs Group of inputs to transition on\r\n   * @param {Transition<T> | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   */\r\n  ta(inputs, next, flags, groups) {\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      this.tt(inputs[i], next, flags, groups);\r\n    }\r\n  },\r\n  /**\r\n   * Short for \"take regexp transition\"; defines a transition for this state\r\n   * when it encounters a token which matches the given regular expression\r\n   * @param {RegExp} regexp Regular expression transition (populate first)\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tr(regexp, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    let nextState;\r\n    if (next && next.j) {\r\n      nextState = next;\r\n    } else {\r\n      // Token with maybe token groups\r\n      nextState = new State(next);\r\n      if (flags && groups) {\r\n        addToGroups(next, flags, groups);\r\n      }\r\n    }\r\n    this.jr.push([regexp, nextState]);\r\n    return nextState;\r\n  },\r\n  /**\r\n   * Short for \"take transitions\", will take as many sequential transitions as\r\n   * the length of the given input and returns the\r\n   * resulting final state.\r\n   * @param {string | string[]} input\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  ts(input, next, flags, groups) {\r\n    let state = this;\r\n    const len = input.length;\r\n    if (!len) {\r\n      return state;\r\n    }\r\n    for (let i = 0; i < len - 1; i++) {\r\n      state = state.tt(input[i]);\r\n    }\r\n    return state.tt(input[len - 1], next, flags, groups);\r\n  },\r\n  /**\r\n   * Short for \"take transition\", this is a method for building/working with\r\n   * state machines.\r\n   *\r\n   * If a state already exists for the given input, returns it.\r\n   *\r\n   * If a token is specified, that state will emit that token when reached by\r\n   * the linkify engine.\r\n   *\r\n   * If no state exists, it will be initialized with some default transitions\r\n   * that resemble existing default transitions.\r\n   *\r\n   * If a state is given for the second argument, that state will be\r\n   * transitioned to on the given input regardless of what that input\r\n   * previously did.\r\n   *\r\n   * Specify a token group flags to define groups that this token belongs to.\r\n   * The token will be added to corresponding entires in the given groups\r\n   * object.\r\n   *\r\n   * @param {string} input character, token type to transition on\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tt(input, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    const state = this;\r\n\r\n    // Check if existing state given, just a basic transition\r\n    if (next && next.j) {\r\n      state.j[input] = next;\r\n      return next;\r\n    }\r\n    const t = next;\r\n\r\n    // Take the transition with the usual default mechanisms and use that as\r\n    // a template for creating the next state\r\n    let nextState,\r\n      templateState = state.go(input);\r\n    if (templateState) {\r\n      nextState = new State();\r\n      assign(nextState.j, templateState.j);\r\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\r\n      nextState.jd = templateState.jd;\r\n      nextState.t = templateState.t;\r\n    } else {\r\n      nextState = new State();\r\n    }\r\n    if (t) {\r\n      // Ensure newly token is in the same groups as the old token\r\n      if (groups) {\r\n        if (nextState.t && typeof nextState.t === 'string') {\r\n          const allFlags = assign(flagsForToken(nextState.t, groups), flags);\r\n          addToGroups(t, allFlags, groups);\r\n        } else if (flags) {\r\n          addToGroups(t, flags, groups);\r\n        }\r\n      }\r\n      nextState.t = t; // overwrite anything that was previously there\r\n    }\r\n\r\n    state.j[input] = nextState;\r\n    return nextState;\r\n  }\r\n};\r\n\r\n// Helper functions to improve minification (not exported outside linkifyjs module)\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {RegExp} regexp\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string} input\r\n * @param {T | State<T>} [next]\r\n * @param {Collections<T>} [groups]\r\n * @param {Flags} [flags]\r\n */\r\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\r\n\r\n/******************************************************************************\r\nText Tokens\r\nIdentifiers for token outputs from the regexp scanner\r\n******************************************************************************/\r\n\r\n// A valid web domain token\r\nconst WORD = 'WORD'; // only contains a-z\r\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\r\n\r\n// Special case of word\r\nconst LOCALHOST = 'LOCALHOST';\r\n\r\n// Valid top-level domain, special case of WORD (see tlds.js)\r\nconst TLD = 'TLD';\r\n\r\n// Valid IDN TLD, special case of UWORD (see tlds.js)\r\nconst UTLD = 'UTLD';\r\n\r\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\r\n// `file`, and user-defined custom protocols. Limited to schemes that contain\r\n// only letters\r\nconst SCHEME = 'SCHEME';\r\n\r\n// Similar to SCHEME, except makes distinction for schemes that must always be\r\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\r\n// `ftp`, `ftps`\r\nconst SLASH_SCHEME = 'SLASH_SCHEME';\r\n\r\n// Any sequence of digits 0-9\r\nconst NUM = 'NUM';\r\n\r\n// Any number of consecutive whitespace characters that are not newline\r\nconst WS = 'WS';\r\n\r\n// New line (unix style)\r\nconst NL$1 = 'NL'; // \\n\r\n\r\n// Opening/closing bracket classes\r\nconst OPENBRACE = 'OPENBRACE'; // {\r\nconst OPENBRACKET = 'OPENBRACKET'; // [\r\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\r\nconst OPENPAREN = 'OPENPAREN'; // (\r\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\r\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\r\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\r\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\r\n\r\n// Various symbols\r\nconst AMPERSAND = 'AMPERSAND'; // &\r\nconst APOSTROPHE = 'APOSTROPHE'; // '\r\nconst ASTERISK = 'ASTERISK'; // *\r\nconst AT = 'AT'; // @\r\nconst BACKSLASH = 'BACKSLASH'; // \\\r\nconst BACKTICK = 'BACKTICK'; // `\r\nconst CARET = 'CARET'; // ^\r\nconst COLON = 'COLON'; // :\r\nconst COMMA = 'COMMA'; // ,\r\nconst DOLLAR = 'DOLLAR'; // $\r\nconst DOT = 'DOT'; // .\r\nconst EQUALS = 'EQUALS'; // =\r\nconst EXCLAMATION = 'EXCLAMATION'; // !\r\nconst HYPHEN = 'HYPHEN'; // -\r\nconst PERCENT = 'PERCENT'; // %\r\nconst PIPE = 'PIPE'; // |\r\nconst PLUS = 'PLUS'; // +\r\nconst POUND = 'POUND'; // #\r\nconst QUERY = 'QUERY'; // ?\r\nconst QUOTE = 'QUOTE'; // \"\r\n\r\nconst SEMI = 'SEMI'; // ;\r\nconst SLASH = 'SLASH'; // /\r\nconst TILDE = 'TILDE'; // ~\r\nconst UNDERSCORE = 'UNDERSCORE'; // _\r\n\r\n// Emoji symbol\r\nconst EMOJI$1 = 'EMOJI';\r\n\r\n// Default token - anything that is not one of the above\r\nconst SYM = 'SYM';\r\n\r\nvar tk = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tWORD: WORD,\r\n\tUWORD: UWORD,\r\n\tLOCALHOST: LOCALHOST,\r\n\tTLD: TLD,\r\n\tUTLD: UTLD,\r\n\tSCHEME: SCHEME,\r\n\tSLASH_SCHEME: SLASH_SCHEME,\r\n\tNUM: NUM,\r\n\tWS: WS,\r\n\tNL: NL$1,\r\n\tOPENBRACE: OPENBRACE,\r\n\tOPENBRACKET: OPENBRACKET,\r\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\r\n\tOPENPAREN: OPENPAREN,\r\n\tCLOSEBRACE: CLOSEBRACE,\r\n\tCLOSEBRACKET: CLOSEBRACKET,\r\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\r\n\tCLOSEPAREN: CLOSEPAREN,\r\n\tAMPERSAND: AMPERSAND,\r\n\tAPOSTROPHE: APOSTROPHE,\r\n\tASTERISK: ASTERISK,\r\n\tAT: AT,\r\n\tBACKSLASH: BACKSLASH,\r\n\tBACKTICK: BACKTICK,\r\n\tCARET: CARET,\r\n\tCOLON: COLON,\r\n\tCOMMA: COMMA,\r\n\tDOLLAR: DOLLAR,\r\n\tDOT: DOT,\r\n\tEQUALS: EQUALS,\r\n\tEXCLAMATION: EXCLAMATION,\r\n\tHYPHEN: HYPHEN,\r\n\tPERCENT: PERCENT,\r\n\tPIPE: PIPE,\r\n\tPLUS: PLUS,\r\n\tPOUND: POUND,\r\n\tQUERY: QUERY,\r\n\tQUOTE: QUOTE,\r\n\tSEMI: SEMI,\r\n\tSLASH: SLASH,\r\n\tTILDE: TILDE,\r\n\tUNDERSCORE: UNDERSCORE,\r\n\tEMOJI: EMOJI$1,\r\n\tSYM: SYM\r\n});\r\n\r\n// Note that these two Unicode ones expand into a really big one with Babel\r\nconst ASCII_LETTER = /[a-z]/;\r\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\r\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\r\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\r\nconst DIGIT = /\\d/;\r\nconst SPACE = /\\s/;\r\n\r\nvar regexp = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tASCII_LETTER: ASCII_LETTER,\r\n\tLETTER: LETTER,\r\n\tEMOJI: EMOJI,\r\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\r\n\tDIGIT: DIGIT,\r\n\tSPACE: SPACE\r\n});\r\n\r\n/**\r\n\tThe scanner provides an interface that takes a string of text as input, and\r\n\toutputs an array of tokens instances that can be used for easy URL parsing.\r\n*/\r\nconst NL = '\\n'; // New line character\r\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\r\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\r\n\r\nlet tlds = null,\r\n  utlds = null; // don't change so only have to be computed once\r\n\r\n/**\r\n * Scanner output token:\r\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\r\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\r\n * - `s` is the start index of the token in the original string\r\n * - `e` is the end index of the token in the original string\r\n * @typedef {{t: string, v: string, s: number, e: number}} Token\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [collection: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * Initialize the scanner character-based state machine for the given start\r\n * state\r\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\r\n * item is a length-2 tuple with the first element set to the string scheme, and\r\n * the second element set to `true` if the `://` after the scheme is optional\r\n */\r\nfunction init$2(customSchemes) {\r\n  if (customSchemes === void 0) {\r\n    customSchemes = [];\r\n  }\r\n  // Frequently used states (name argument removed during minification)\r\n  /** @type Collections<string> */\r\n  const groups = {}; // of tokens\r\n  State.groups = groups;\r\n  /** @type State<string> */\r\n  const Start = new State();\r\n  if (tlds == null) {\r\n    tlds = decodeTlds(encodedTlds);\r\n  }\r\n  if (utlds == null) {\r\n    utlds = decodeTlds(encodedUtlds);\r\n  }\r\n\r\n  // States for special URL symbols that accept immediately after start\r\n  tt(Start, \"'\", APOSTROPHE);\r\n  tt(Start, '{', OPENBRACE);\r\n  tt(Start, '[', OPENBRACKET);\r\n  tt(Start, '<', OPENANGLEBRACKET);\r\n  tt(Start, '(', OPENPAREN);\r\n  tt(Start, '}', CLOSEBRACE);\r\n  tt(Start, ']', CLOSEBRACKET);\r\n  tt(Start, '>', CLOSEANGLEBRACKET);\r\n  tt(Start, ')', CLOSEPAREN);\r\n  tt(Start, '&', AMPERSAND);\r\n  tt(Start, '*', ASTERISK);\r\n  tt(Start, '@', AT);\r\n  tt(Start, '`', BACKTICK);\r\n  tt(Start, '^', CARET);\r\n  tt(Start, ':', COLON);\r\n  tt(Start, ',', COMMA);\r\n  tt(Start, '$', DOLLAR);\r\n  tt(Start, '.', DOT);\r\n  tt(Start, '=', EQUALS);\r\n  tt(Start, '!', EXCLAMATION);\r\n  tt(Start, '-', HYPHEN);\r\n  tt(Start, '%', PERCENT);\r\n  tt(Start, '|', PIPE);\r\n  tt(Start, '+', PLUS);\r\n  tt(Start, '#', POUND);\r\n  tt(Start, '?', QUERY);\r\n  tt(Start, '\"', QUOTE);\r\n  tt(Start, '/', SLASH);\r\n  tt(Start, ';', SEMI);\r\n  tt(Start, '~', TILDE);\r\n  tt(Start, '_', UNDERSCORE);\r\n  tt(Start, '\\\\', BACKSLASH);\r\n  const Num = tr(Start, DIGIT, NUM, {\r\n    [numeric]: true\r\n  });\r\n  tr(Num, DIGIT, Num);\r\n\r\n  // State which emits a word token\r\n  const Word = tr(Start, ASCII_LETTER, WORD, {\r\n    [ascii]: true\r\n  });\r\n  tr(Word, ASCII_LETTER, Word);\r\n\r\n  // Same as previous, but specific to non-fsm.ascii alphabet words\r\n  const UWord = tr(Start, LETTER, UWORD, {\r\n    [alpha]: true\r\n  });\r\n  tr(UWord, ASCII_LETTER); // Non-accepting\r\n  tr(UWord, LETTER, UWord);\r\n\r\n  // Whitespace jumps\r\n  // Tokens of only non-newline whitespace are arbitrarily long\r\n  // If any whitespace except newline, more whitespace!\r\n  const Ws = tr(Start, SPACE, WS, {\r\n    [whitespace]: true\r\n  });\r\n  tt(Start, NL, NL$1, {\r\n    [whitespace]: true\r\n  });\r\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\r\n  tr(Ws, SPACE, Ws);\r\n\r\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\r\n  // zero-width joiner is present\r\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\r\n    [emoji]: true\r\n  });\r\n  tr(Emoji, EMOJI, Emoji);\r\n  tt(Emoji, EMOJI_VARIATION, Emoji);\r\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\r\n\r\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\r\n  tr(EmojiJoiner, EMOJI, Emoji);\r\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\r\n\r\n  // Generates states for top-level domains\r\n  // Note that this is most accurate when tlds are in alphabetical order\r\n  const wordjr = [[ASCII_LETTER, Word]];\r\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\r\n  for (let i = 0; i < tlds.length; i++) {\r\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\r\n  }\r\n  for (let i = 0; i < utlds.length; i++) {\r\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\r\n  }\r\n  addToGroups(TLD, {\r\n    tld: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(UTLD, {\r\n    utld: true,\r\n    alpha: true\r\n  }, groups);\r\n\r\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\r\n  // get added that are also protocols, set the token to be the same as the\r\n  // protocol to ensure parsing works as expected.\r\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\r\n  addToGroups(SCHEME, {\r\n    scheme: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(SLASH_SCHEME, {\r\n    slashscheme: true,\r\n    ascii: true\r\n  }, groups);\r\n\r\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\r\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\r\n  for (let i = 0; i < customSchemes.length; i++) {\r\n    const sch = customSchemes[i][0];\r\n    const optionalSlashSlash = customSchemes[i][1];\r\n    const flags = optionalSlashSlash ? {\r\n      [scheme]: true\r\n    } : {\r\n      [slashscheme]: true\r\n    };\r\n    if (sch.indexOf('-') >= 0) {\r\n      flags[domain] = true;\r\n    } else if (!ASCII_LETTER.test(sch)) {\r\n      flags[numeric] = true; // numbers only\r\n    } else if (DIGIT.test(sch)) {\r\n      flags[asciinumeric] = true;\r\n    } else {\r\n      flags[ascii] = true;\r\n    }\r\n    ts(Start, sch, sch, flags);\r\n  }\r\n\r\n  // Localhost token\r\n  ts(Start, 'localhost', LOCALHOST, {\r\n    ascii: true\r\n  });\r\n\r\n  // Set default transition for start state (some symbol)\r\n  Start.jd = new State(SYM);\r\n  return {\r\n    start: Start,\r\n    tokens: assign({\r\n      groups\r\n    }, tk)\r\n  };\r\n}\r\n\r\n/**\r\n\tGiven a string, returns an array of TOKEN instances representing the\r\n\tcomposition of that string.\r\n\r\n\t@method run\r\n\t@param {State<string>} start scanner starting state\r\n\t@param {string} str input string to scan\r\n\t@return {Token[]} list of tokens, each with a type and value\r\n*/\r\nfunction run$1(start, str) {\r\n  // State machine is not case sensitive, so input is tokenized in lowercased\r\n  // form (still returns regular case). Uses selective `toLowerCase` because\r\n  // lowercasing the entire string causes the length and character position to\r\n  // vary in some non-English strings with V8-based runtimes.\r\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\r\n  const charCount = iterable.length; // <= len if there are emojis, etc\r\n  const tokens = []; // return value\r\n\r\n  // cursor through the string itself, accounting for characters that have\r\n  // width with length 2 such as emojis\r\n  let cursor = 0;\r\n\r\n  // Cursor through the array-representation of the string\r\n  let charCursor = 0;\r\n\r\n  // Tokenize the string\r\n  while (charCursor < charCount) {\r\n    let state = start;\r\n    let nextState = null;\r\n    let tokenLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    let charsSinceAccepts = -1;\r\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        charsSinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts += iterable[charCursor].length;\r\n        charsSinceAccepts++;\r\n      }\r\n      tokenLength += iterable[charCursor].length;\r\n      cursor += iterable[charCursor].length;\r\n      charCursor++;\r\n    }\r\n\r\n    // Roll back to the latest accepting state\r\n    cursor -= sinceAccepts;\r\n    charCursor -= charsSinceAccepts;\r\n    tokenLength -= sinceAccepts;\r\n\r\n    // No more jumps, just make a new token from the last accepting one\r\n    tokens.push({\r\n      t: latestAccepting.t,\r\n      // token type/name\r\n      v: str.slice(cursor - tokenLength, cursor),\r\n      // string value\r\n      s: cursor - tokenLength,\r\n      // start index\r\n      e: cursor // end index (excluding)\r\n    });\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\n/**\r\n * Convert a String to an Array of characters, taking into account that some\r\n * characters like emojis take up two string indexes.\r\n *\r\n * Adapted from core-js (MIT license)\r\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\r\n *\r\n * @function stringToArray\r\n * @param {string} str\r\n * @returns {string[]}\r\n */\r\nfunction stringToArray(str) {\r\n  const result = [];\r\n  const len = str.length;\r\n  let index = 0;\r\n  while (index < len) {\r\n    let first = str.charCodeAt(index);\r\n    let second;\r\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\r\n    : str.slice(index, index + 2); // two-index characters\r\n    result.push(char);\r\n    index += char.length;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Fast version of ts function for when transition defaults are well known\r\n * @param {State<string>} state\r\n * @param {string} input\r\n * @param {string} t\r\n * @param {string} defaultt\r\n * @param {[RegExp, State<string>][]} jr\r\n * @returns {State<string>}\r\n */\r\nfunction fastts(state, input, t, defaultt, jr) {\r\n  let next;\r\n  const len = input.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const char = input[i];\r\n    if (state.j[char]) {\r\n      next = state.j[char];\r\n    } else {\r\n      next = new State(defaultt);\r\n      next.jr = jr.slice();\r\n      state.j[char] = next;\r\n    }\r\n    state = next;\r\n  }\r\n  next = new State(t);\r\n  next.jr = jr.slice();\r\n  state.j[input[len - 1]] = next;\r\n  return next;\r\n}\r\n\r\n/**\r\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\r\n * into a list of strings.\r\n * @param {str} encoded encoded TLDs string\r\n * @returns {str[]} original TLDs list\r\n */\r\nfunction decodeTlds(encoded) {\r\n  const words = [];\r\n  const stack = [];\r\n  let i = 0;\r\n  let digits = '0123456789';\r\n  while (i < encoded.length) {\r\n    let popDigitCount = 0;\r\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\r\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\r\n    }\r\n\r\n    if (popDigitCount > 0) {\r\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\r\n      let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10);\r\n      for (; popCount > 0; popCount--) {\r\n        stack.pop();\r\n      }\r\n      i += popDigitCount;\r\n    } else if (encoded[i] === '_') {\r\n      words.push(stack.join('')); // found a word, will be followed by another\r\n      i++;\r\n    } else {\r\n      stack.push(encoded[i]); // drop down a level into the trie\r\n      i++;\r\n    }\r\n  }\r\n  return words;\r\n}\r\n\r\n/**\r\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\r\n * and each value is an event handler function.\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\r\n * @typedef {?{ [event: string]: Function }} EventListeners\r\n */\r\n\r\n/**\r\n * All formatted properties required to render a link, including `tagName`,\r\n * `attributes`, `content` and `eventListeners`.\r\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\r\n * eventListeners: EventListeners }} IntermediateRepresentation\r\n */\r\n\r\n/**\r\n * Specify either an object described by the template type `O` or a function.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `O`\r\n * @template O\r\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\r\n */\r\n\r\n/**\r\n * Specify either a function described by template type `F` or an object.\r\n *\r\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\r\n * value should be a function with template type `F` that is called when the\r\n * corresponding link type is encountered.\r\n * @template F\r\n * @typedef {F | { [type: string]: F}} OptFn\r\n */\r\n\r\n/**\r\n * Specify either a value with template type `V`, a function that returns `V` or\r\n * an object where each value resolves to `V`.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `V`\r\n *\r\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\r\n * Each value should either have type `V` or a function that returns V. This\r\n * function similarly takes a string value and a token.\r\n *\r\n * Example valid types for `Opt<string>`:\r\n *\r\n * ```js\r\n * 'hello'\r\n * (value, type, token) => 'world'\r\n * { url: 'hello', email: (value, token) => 'world'}\r\n * ```\r\n * @template V\r\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\r\n */\r\n\r\n/**\r\n * See available options: https://linkify.js.org/docs/options.html\r\n * @typedef {{\r\n * \tdefaultProtocol?: string,\r\n *  events?: OptObj<EventListeners>,\r\n * \tformat?: Opt<string>,\r\n * \tformatHref?: Opt<string>,\r\n * \tnl2br?: boolean,\r\n * \ttagName?: Opt<any>,\r\n * \ttarget?: Opt<string>,\r\n * \trel?: Opt<string>,\r\n * \tvalidate?: Opt<boolean>,\r\n * \ttruncate?: Opt<number>,\r\n * \tclassName?: Opt<string>,\r\n * \tattributes?: OptObj<({ [attr: string]: any })>,\r\n *  ignoreTags?: string[],\r\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\r\n * }} Opts\r\n */\r\n\r\n/**\r\n * @type Required<Opts>\r\n */\r\nconst defaults = {\r\n  defaultProtocol: 'http',\r\n  events: null,\r\n  format: noop,\r\n  formatHref: noop,\r\n  nl2br: false,\r\n  tagName: 'a',\r\n  target: null,\r\n  rel: null,\r\n  validate: true,\r\n  truncate: Infinity,\r\n  className: null,\r\n  attributes: null,\r\n  ignoreTags: [],\r\n  render: null\r\n};\r\n\r\n/**\r\n * Utility class for linkify interfaces to apply specified\r\n * {@link Opts formatting and rendering options}.\r\n *\r\n * @param {Opts | Options} [opts] Option value overrides.\r\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\r\n *   internal use) default render function that determines how to generate an\r\n *   HTML element based on a link token's derived tagName, attributes and HTML.\r\n *   Similar to render option\r\n */\r\nfunction Options(opts, defaultRender) {\r\n  if (defaultRender === void 0) {\r\n    defaultRender = null;\r\n  }\r\n  let o = assign({}, defaults);\r\n  if (opts) {\r\n    o = assign(o, opts instanceof Options ? opts.o : opts);\r\n  }\r\n\r\n  // Ensure all ignored tags are uppercase\r\n  const ignoredTags = o.ignoreTags;\r\n  const uppercaseIgnoredTags = [];\r\n  for (let i = 0; i < ignoredTags.length; i++) {\r\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\r\n  }\r\n  /** @protected */\r\n  this.o = o;\r\n  if (defaultRender) {\r\n    this.defaultRender = defaultRender;\r\n  }\r\n  this.ignoreTags = uppercaseIgnoredTags;\r\n}\r\nOptions.prototype = {\r\n  o: defaults,\r\n  /**\r\n   * @type string[]\r\n   */\r\n  ignoreTags: [],\r\n  /**\r\n   * @param {IntermediateRepresentation} ir\r\n   * @returns {any}\r\n   */\r\n  defaultRender(ir) {\r\n    return ir;\r\n  },\r\n  /**\r\n   * Returns true or false based on whether a token should be displayed as a\r\n   * link based on the user options.\r\n   * @param {MultiToken} token\r\n   * @returns {boolean}\r\n   */\r\n  check(token) {\r\n    return this.get('validate', token.toString(), token);\r\n  },\r\n  // Private methods\r\n\r\n  /**\r\n   * Resolve an option's value based on the value of the option and the given\r\n   * params. If operator and token are specified and the target option is\r\n   * callable, automatically calls the function with the given argument.\r\n   * @template {keyof Opts} K\r\n   * @param {K} key Name of option to use\r\n   * @param {string} [operator] will be passed to the target option if it's a\r\n   * function. If not specified, RAW function value gets returned\r\n   * @param {MultiToken} [token] The token from linkify.tokenize\r\n   * @returns {Opts[K] | any}\r\n   */\r\n  get(key, operator, token) {\r\n    const isCallable = operator != null;\r\n    let option = this.o[key];\r\n    if (!option) {\r\n      return option;\r\n    }\r\n    if (typeof option === 'object') {\r\n      option = token.t in option ? option[token.t] : defaults[key];\r\n      if (typeof option === 'function' && isCallable) {\r\n        option = option(operator, token);\r\n      }\r\n    } else if (typeof option === 'function' && isCallable) {\r\n      option = option(operator, token.t, token);\r\n    }\r\n    return option;\r\n  },\r\n  /**\r\n   * @template {keyof Opts} L\r\n   * @param {L} key Name of options object to use\r\n   * @param {string} [operator]\r\n   * @param {MultiToken} [token]\r\n   * @returns {Opts[L] | any}\r\n   */\r\n  getObj(key, operator, token) {\r\n    let obj = this.o[key];\r\n    if (typeof obj === 'function' && operator != null) {\r\n      obj = obj(operator, token.t, token);\r\n    }\r\n    return obj;\r\n  },\r\n  /**\r\n   * Convert the given token to a rendered element that may be added to the\r\n   * calling-interface's DOM\r\n   * @param {MultiToken} token Token to render to an HTML element\r\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\r\n   *   Component, etc.\r\n   */\r\n  render(token) {\r\n    const ir = token.render(this); // intermediate representation\r\n    const renderFn = this.get('render', null, token) || this.defaultRender;\r\n    return renderFn(ir, token.t, token);\r\n  }\r\n};\r\nfunction noop(val) {\r\n  return val;\r\n}\r\n\r\nvar options = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tdefaults: defaults,\r\n\tOptions: Options,\r\n\tassign: assign\r\n});\r\n\r\n/******************************************************************************\r\n\tMulti-Tokens\r\n\tTokens composed of arrays of TextTokens\r\n******************************************************************************/\r\n\r\n/**\r\n * @param {string} value\r\n * @param {Token[]} tokens\r\n */\r\nfunction MultiToken(value, tokens) {\r\n  this.t = 'token';\r\n  this.v = value;\r\n  this.tk = tokens;\r\n}\r\n\r\n/**\r\n * Abstract class used for manufacturing tokens of text tokens. That is rather\r\n * than the value for a token being a small string of text, it's value an array\r\n * of text tokens.\r\n *\r\n * Used for grouping together URLs, emails, hashtags, and other potential\r\n * creations.\r\n * @class MultiToken\r\n * @property {string} t\r\n * @property {string} v\r\n * @property {Token[]} tk\r\n * @abstract\r\n */\r\nMultiToken.prototype = {\r\n  isLink: false,\r\n  /**\r\n   * Return the string this token represents.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.v;\r\n  },\r\n  /**\r\n   * What should the value for this token be in the `href` HTML attribute?\r\n   * Returns the `.toString` value by default.\r\n   * @param {string} [scheme]\r\n   * @return {string}\r\n  */\r\n  toHref(scheme) {\r\n    return this.toString();\r\n  },\r\n  /**\r\n   * @param {Options} options Formatting options\r\n   * @returns {string}\r\n   */\r\n  toFormattedString(options) {\r\n    const val = this.toString();\r\n    const truncate = options.get('truncate', val, this);\r\n    const formatted = options.get('format', val, this);\r\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options\r\n   * @returns {string}\r\n   */\r\n  toFormattedHref(options) {\r\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\r\n  },\r\n  /**\r\n   * The start index of this token in the original input string\r\n   * @returns {number}\r\n   */\r\n  startIndex() {\r\n    return this.tk[0].s;\r\n  },\r\n  /**\r\n   * The end index of this token in the original input string (up to this\r\n   * index but not including it)\r\n   * @returns {number}\r\n   */\r\n  endIndex() {\r\n    return this.tk[this.tk.length - 1].e;\r\n  },\r\n  /**\r\n  \tReturns an object  of relevant values for this token, which includes keys\r\n  \t* type - Kind of token ('url', 'email', etc.)\r\n  \t* value - Original text\r\n  \t* href - The value that should be added to the anchor tag's href\r\n  \t\tattribute\r\n  \t\t@method toObject\r\n  \t@param {string} [protocol] `'http'` by default\r\n  */\r\n  toObject(protocol) {\r\n    if (protocol === void 0) {\r\n      protocol = defaults.defaultProtocol;\r\n    }\r\n    return {\r\n      type: this.t,\r\n      value: this.toString(),\r\n      isLink: this.isLink,\r\n      href: this.toHref(protocol),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options Formatting option\r\n   */\r\n  toFormattedObject(options) {\r\n    return {\r\n      type: this.t,\r\n      value: this.toFormattedString(options),\r\n      isLink: this.isLink,\r\n      href: this.toFormattedHref(options),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   * Whether this token should be rendered as a link according to the given options\r\n   * @param {Options} options\r\n   * @returns {boolean}\r\n   */\r\n  validate(options) {\r\n    return options.get('validate', this.toString(), this);\r\n  },\r\n  /**\r\n   * Return an object that represents how this link should be rendered.\r\n   * @param {Options} options Formattinng options\r\n   */\r\n  render(options) {\r\n    const token = this;\r\n    const href = this.toFormattedHref(options);\r\n    const tagName = options.get('tagName', href, token);\r\n    const content = this.toFormattedString(options);\r\n    const attributes = {};\r\n    const className = options.get('className', href, token);\r\n    const target = options.get('target', href, token);\r\n    const rel = options.get('rel', href, token);\r\n    const attrs = options.getObj('attributes', href, token);\r\n    const eventListeners = options.getObj('events', href, token);\r\n    attributes.href = href;\r\n    if (className) {\r\n      attributes.class = className;\r\n    }\r\n    if (target) {\r\n      attributes.target = target;\r\n    }\r\n    if (rel) {\r\n      attributes.rel = rel;\r\n    }\r\n    if (attrs) {\r\n      assign(attributes, attrs);\r\n    }\r\n    return {\r\n      tagName,\r\n      attributes,\r\n      content,\r\n      eventListeners\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new token that can be emitted by the parser state machine\r\n * @param {string} type readable type of the token\r\n * @param {object} props properties to assign or override, including isLink = true or false\r\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\r\n */\r\nfunction createTokenClass(type, props) {\r\n  class Token extends MultiToken {\r\n    constructor(value, tokens) {\r\n      super(value, tokens);\r\n      this.t = type;\r\n    }\r\n  }\r\n  for (const p in props) {\r\n    Token.prototype[p] = props[p];\r\n  }\r\n  Token.t = type;\r\n  return Token;\r\n}\r\n\r\n/**\r\n\tRepresents a list of tokens making up a valid email address\r\n*/\r\nconst Email = createTokenClass('email', {\r\n  isLink: true,\r\n  toHref() {\r\n    return 'mailto:' + this.toString();\r\n  }\r\n});\r\n\r\n/**\r\n\tRepresents some plain text\r\n*/\r\nconst Text = createTokenClass('text');\r\n\r\n/**\r\n\tMulti-linebreak token - represents a line break\r\n\t@class Nl\r\n*/\r\nconst Nl = createTokenClass('nl');\r\n\r\n/**\r\n\tRepresents a list of text tokens making up a valid URL\r\n\t@class Url\r\n*/\r\nconst Url = createTokenClass('url', {\r\n  isLink: true,\r\n  /**\r\n  \tLowercases relevant parts of the domain and adds the protocol if\r\n  \trequired. Note that this will not escape unsafe HTML characters in the\r\n  \tURL.\r\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\r\n  \t@return {string} the full href\r\n  */\r\n  toHref(scheme) {\r\n    if (scheme === void 0) {\r\n      scheme = defaults.defaultProtocol;\r\n    }\r\n    // Check if already has a prefix scheme\r\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\r\n  },\r\n  /**\r\n   * Check whether this URL token has a protocol\r\n   * @return {boolean}\r\n   */\r\n  hasProtocol() {\r\n    const tokens = this.tk;\r\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\r\n  }\r\n});\r\n\r\nvar multi = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tMultiToken: MultiToken,\r\n\tBase: MultiToken,\r\n\tcreateTokenClass: createTokenClass,\r\n\tEmail: Email,\r\n\tText: Text,\r\n\tNl: Nl,\r\n\tUrl: Url\r\n});\r\n\r\n/**\r\n\tNot exactly parser, more like the second-stage scanner (although we can\r\n\ttheoretically hotswap the code here with a real parser in the future... but\r\n\tfor a little URL-finding utility abstract syntax trees may be a little\r\n\toverkill).\r\n\r\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\r\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\r\n\treference)\r\n\r\n\t@module linkify\r\n\t@submodule parser\r\n\t@main run\r\n*/\r\nconst makeState = arg => new State(arg);\r\n\r\n/**\r\n * Generate the parser multi token-based state machine\r\n * @param {{ groups: Collections<string> }} tokens\r\n */\r\nfunction init$1(_ref) {\r\n  let {\r\n    groups\r\n  } = _ref;\r\n  // Types of characters the URL can definitely end in\r\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\r\n\r\n  // Types of tokens that can follow a URL and be part of the query string\r\n  // but cannot be the very last characters\r\n  // Characters that cannot appear in the URL at all should be excluded\r\n  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];\r\n\r\n  // For addresses without the mailto prefix\r\n  // Tokens allowed in the localpart of the email\r\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\r\n\r\n  // The universal starting state.\r\n  /**\r\n   * @type State<Token>\r\n   */\r\n  const Start = makeState();\r\n  const Localpart = tt(Start, TILDE); // Local part of the email address\r\n  ta(Localpart, localpartAccepting, Localpart);\r\n  ta(Localpart, groups.domain, Localpart);\r\n  const Domain = makeState(),\r\n    Scheme = makeState(),\r\n    SlashScheme = makeState();\r\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\r\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\r\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\r\n\r\n  ta(Domain, localpartAccepting, Localpart);\r\n  ta(Domain, groups.domain, Domain);\r\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\r\n\r\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\r\n\r\n  // Local part of an email address can be e.g. 'http' or 'mailto'\r\n  tt(Scheme, AT, LocalpartAt);\r\n  tt(SlashScheme, AT, LocalpartAt);\r\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\r\n  ta(LocalpartDot, localpartAccepting, Localpart);\r\n  ta(LocalpartDot, groups.domain, Localpart);\r\n  const EmailDomain = makeState();\r\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\r\n  ta(EmailDomain, groups.domain, EmailDomain);\r\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\r\n  ta(EmailDomainDot, groups.domain, EmailDomain);\r\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\r\n  ta(EmailDomainDot, groups.tld, Email$1);\r\n  ta(EmailDomainDot, groups.utld, Email$1);\r\n  tt(LocalpartAt, LOCALHOST, Email$1);\r\n\r\n  // Hyphen can jump back to a domain name\r\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\r\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\r\n  ta(Email$1, groups.domain, EmailDomain);\r\n  tt(Email$1, DOT, EmailDomainDot);\r\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\r\n\r\n  // Final possible email states\r\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\r\n  /*const EmailColonPort = */\r\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\r\n\r\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\r\n  // (but not TLDs)\r\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\r\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\r\n  ta(DomainHyphen, groups.domain, Domain);\r\n  ta(DomainDot, localpartAccepting, Localpart);\r\n  ta(DomainDot, groups.domain, Domain);\r\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\r\n  ta(DomainDot, groups.tld, DomainDotTld);\r\n  ta(DomainDot, groups.utld, DomainDotTld);\r\n  ta(DomainDotTld, groups.domain, Domain);\r\n  ta(DomainDotTld, localpartAccepting, Localpart);\r\n  tt(DomainDotTld, DOT, DomainDot);\r\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\r\n  tt(DomainDotTld, AT, LocalpartAt);\r\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\r\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\r\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\r\n\r\n  // Long URL with optional port and maybe query string\r\n  const Url$1 = makeState(Url);\r\n\r\n  // URL with extra symbols at the end, followed by an opening bracket\r\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\r\n\r\n  // Query strings\r\n  ta(Url$1, qsAccepting, Url$1);\r\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\r\n  ta(UrlNonaccept, qsAccepting, Url$1);\r\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\r\n\r\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\r\n  // Here works with or without scheme:// prefix\r\n  tt(DomainDotTld, SLASH, Url$1);\r\n  tt(DomainDotTldColonPort, SLASH, Url$1);\r\n\r\n  // Note that domains that begin with schemes are treated slighly differently\r\n  const UriPrefix = tt(Scheme, COLON); // e.g., 'mailto:' or 'http://'\r\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\r\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\r\n\r\n  tt(SlashSchemeColonSlash, SLASH, UriPrefix);\r\n\r\n  // Scheme states can transition to domain states\r\n  ta(Scheme, groups.domain, Domain);\r\n  tt(Scheme, DOT, DomainDot);\r\n  tt(Scheme, HYPHEN, DomainHyphen);\r\n  ta(SlashScheme, groups.domain, Domain);\r\n  tt(SlashScheme, DOT, DomainDot);\r\n  tt(SlashScheme, HYPHEN, DomainHyphen);\r\n\r\n  // Force URL with scheme prefix followed by anything sane\r\n  ta(UriPrefix, groups.domain, Url$1);\r\n  tt(UriPrefix, SLASH, Url$1);\r\n\r\n  // URL, followed by an opening bracket\r\n  const UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\r\n  const UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\r\n  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\r\n  const UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\r\n\r\n  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\r\n  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\r\n  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\r\n  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);\r\n\r\n  // Closing bracket component. This character WILL be included in the URL\r\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\r\n  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparen, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\r\n\r\n  // URL that beings with an opening bracket, followed by a symbols.\r\n  // Note that the final state can still be `UrlOpenbrace` (if the URL only\r\n  // has a single opening bracket for some reason).\r\n  const UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\r\n  const UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\r\n  const UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\r\n  const UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\r\n  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\r\n  const UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\r\n  const UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\r\n  const UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\r\n  const UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\r\n  ta(UrlOpenbrace, qsNonAccepting);\r\n  ta(UrlOpenbracket, qsNonAccepting);\r\n  ta(UrlOpenanglebracket, qsNonAccepting);\r\n  ta(UrlOpenparen, qsNonAccepting);\r\n\r\n  // URL that begins with an opening bracket, followed by some symbols\r\n  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\r\n  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\r\n  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\r\n  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\r\n  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);\r\n\r\n  // Close brace/bracket to become regular URL\r\n  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\r\n  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\r\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\r\n  tt(Start, NL$1, Nl); // single new line\r\n\r\n  return {\r\n    start: Start,\r\n    tokens: tk\r\n  };\r\n}\r\n\r\n/**\r\n * Run the parser state machine on a list of scanned string-based tokens to\r\n * create a list of multi tokens, each of which represents a URL, email address,\r\n * plain text, etc.\r\n *\r\n * @param {State<MultiToken>} start parser start state\r\n * @param {string} input the original input used to generate the given tokens\r\n * @param {Token[]} tokens list of scanned tokens\r\n * @returns {MultiToken[]}\r\n */\r\nfunction run(start, input, tokens) {\r\n  let len = tokens.length;\r\n  let cursor = 0;\r\n  let multis = [];\r\n  let textTokens = [];\r\n  while (cursor < len) {\r\n    let state = start;\r\n    let secondState = null;\r\n    let nextState = null;\r\n    let multiLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\r\n      // Starting tokens with nowhere to jump to.\r\n      // Consider these to be just plain text\r\n      textTokens.push(tokens[cursor++]);\r\n    }\r\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\r\n      // Get the next state\r\n      secondState = null;\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts++;\r\n      }\r\n      cursor++;\r\n      multiLength++;\r\n    }\r\n    if (sinceAccepts < 0) {\r\n      // No accepting state was found, part of a regular text token add\r\n      // the first text token to the text tokens array and try again from\r\n      // the next\r\n      cursor -= multiLength;\r\n      if (cursor < len) {\r\n        textTokens.push(tokens[cursor]);\r\n        cursor++;\r\n      }\r\n    } else {\r\n      // Accepting state!\r\n      // First close off the textTokens (if available)\r\n      if (textTokens.length > 0) {\r\n        multis.push(initMultiToken(Text, input, textTokens));\r\n        textTokens = [];\r\n      }\r\n\r\n      // Roll back to the latest accepting state\r\n      cursor -= sinceAccepts;\r\n      multiLength -= sinceAccepts;\r\n\r\n      // Create a new multitoken\r\n      const Multi = latestAccepting.t;\r\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\r\n      multis.push(initMultiToken(Multi, input, subtokens));\r\n    }\r\n  }\r\n\r\n  // Finally close off the textTokens (if available)\r\n  if (textTokens.length > 0) {\r\n    multis.push(initMultiToken(Text, input, textTokens));\r\n  }\r\n  return multis;\r\n}\r\n\r\n/**\r\n * Utility function for instantiating a new multitoken with all the relevant\r\n * fields during parsing.\r\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\r\n * @param {string} input original input string\r\n * @param {Token[]} tokens consecutive tokens scanned from input string\r\n * @returns {MultiToken}\r\n */\r\nfunction initMultiToken(Multi, input, tokens) {\r\n  const startIdx = tokens[0].s;\r\n  const endIdx = tokens[tokens.length - 1].e;\r\n  const value = input.slice(startIdx, endIdx);\r\n  return new Multi(value, tokens);\r\n}\r\n\r\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\r\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\r\n\r\n// Side-effect initialization state\r\nconst INIT = {\r\n  scanner: null,\r\n  parser: null,\r\n  tokenQueue: [],\r\n  pluginQueue: [],\r\n  customSchemes: [],\r\n  initialized: false\r\n};\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<string>,\r\n * \ttokens: { groups: Collections<string> } & typeof tk\r\n * }} ScannerInit\r\n */\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<MultiToken>,\r\n * \ttokens: typeof multi\r\n * }} ParserInit\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\r\n */\r\n\r\n/**\r\n * De-register all plugins and reset the internal state-machine. Used for\r\n * testing; not required in practice.\r\n * @private\r\n */\r\nfunction reset() {\r\n  State.groups = {};\r\n  INIT.scanner = null;\r\n  INIT.parser = null;\r\n  INIT.tokenQueue = [];\r\n  INIT.pluginQueue = [];\r\n  INIT.customSchemes = [];\r\n  INIT.initialized = false;\r\n}\r\n\r\n/**\r\n * Register a token plugin to allow the scanner to recognize additional token\r\n * types before the parser state machine is constructed from the results.\r\n * @param {string} name of plugin to register\r\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\r\n * and available scanner tokens and collections and extends the state machine to\r\n * recognize additional tokens or groups.\r\n */\r\nfunction registerTokenPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    if (name === INIT.tokenQueue[i][0]) {\r\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.tokenQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.tokenQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Register a linkify plugin\r\n * @param {string} name of plugin to register\r\n * @param {Plugin} plugin function that accepts the parser state machine and\r\n * extends the parser to recognize additional link types\r\n */\r\nfunction registerPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    if (name === INIT.pluginQueue[i][0]) {\r\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.pluginQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.pluginQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Detect URLs with the following additional protocol. Anything with format\r\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\r\n * `true`, anything with format \"protocol:...\" will be considered a link.\r\n * @param {string} protocol\r\n * @param {boolean} [optionalSlashSlash]\r\n */\r\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\r\n  if (optionalSlashSlash === void 0) {\r\n    optionalSlashSlash = false;\r\n  }\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\r\n  }\r\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\r\n    throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\r\n  }\r\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\r\n}\r\n\r\n/**\r\n * Initialize the linkify state machine. Called automatically the first time\r\n * linkify is called on a string, but may be called manually as well.\r\n */\r\nfunction init() {\r\n  // Initialize scanner state machine and plugins\r\n  INIT.scanner = init$2(INIT.customSchemes);\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    INIT.tokenQueue[i][1]({\r\n      scanner: INIT.scanner\r\n    });\r\n  }\r\n\r\n  // Initialize parser state machine and plugins\r\n  INIT.parser = init$1(INIT.scanner.tokens);\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    INIT.pluginQueue[i][1]({\r\n      scanner: INIT.scanner,\r\n      parser: INIT.parser\r\n    });\r\n  }\r\n  INIT.initialized = true;\r\n}\r\n\r\n/**\r\n * Parse a string into tokens that represent linkable and non-linkable sub-components\r\n * @param {string} str\r\n * @return {MultiToken[]} tokens\r\n */\r\nfunction tokenize(str) {\r\n  if (!INIT.initialized) {\r\n    init();\r\n  }\r\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\r\n}\r\n\r\n/**\r\n * Find a list of linkable items in the given string.\r\n * @param {string} str string to find links in\r\n * @param {string | Opts} [type] either formatting options or specific type of\r\n * links to find, e.g., 'url' or 'email'\r\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\r\n * if opts already provided in `type` argument\r\n*/\r\nfunction find(str, type, opts) {\r\n  if (type === void 0) {\r\n    type = null;\r\n  }\r\n  if (opts === void 0) {\r\n    opts = null;\r\n  }\r\n  if (type && typeof type === 'object') {\r\n    if (opts) {\r\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\r\n    }\r\n    opts = type;\r\n    type = null;\r\n  }\r\n  const options = new Options(opts);\r\n  const tokens = tokenize(str);\r\n  const filtered = [];\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const token = tokens[i];\r\n    if (token.isLink && (!type || token.t === type)) {\r\n      filtered.push(token.toFormattedObject(options));\r\n    }\r\n  }\r\n  return filtered;\r\n}\r\n\r\n/**\r\n * Is the given string valid linkable text of some sort. Note that this does not\r\n * trim the text for you.\r\n *\r\n * Optionally pass in a second `type` param, which is the type of link to test\r\n * for.\r\n *\r\n * For example,\r\n *\r\n *     linkify.test(str, 'email');\r\n *\r\n * Returns `true` if str is a valid email.\r\n * @param {string} str string to test for links\r\n * @param {string} [type] optional specific link type to look for\r\n * @returns boolean true/false\r\n */\r\nfunction test(str, type) {\r\n  if (type === void 0) {\r\n    type = null;\r\n  }\r\n  const tokens = tokenize(str);\r\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\r\n}\r\n\r\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}