{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n\n/**\n * Transforms a Buffer stream of binary data to a stream of Base64 text. Note that this will\n * also work on a stream of pure strings, as the Writeable base class will automatically decode\n * text string chunks into Buffers.\n * You can pass optionally a line length or a prefix\n * @extends Transform\n */\nmodule.exports = class Base64Encode extends Transform {\n  /**\n   * Creates a Base64Encode\n   * @param {Object=} options - Options for stream creation. Passed to Transform constructor as-is.\n   * @param {string=} options.inputEncoding - The input chunk format. Default is 'utf8'. No effect on Buffer input chunks.\n   * @param {string=} options.outputEncoding - The output chunk format. Default is 'utf8'. Pass `null` for Buffer chunks.\n   * @param {number=} options.lineLength - The max line-length of the output stream.\n   * @param {string=} options.prefix - Prefix for output string.\n   */\n  constructor(options) {\n    super(options);\n\n    // Any extra chars from the last chunk\n    this.extra = null;\n    this.lineLength = options && options.lineLength;\n    this.currLineLength = 0;\n    if (options && options.prefix) {\n      this.push(options.prefix);\n    }\n\n    // Default string input to be treated as 'utf8'\n    const encIn = options && options.inputEncoding;\n    this.setDefaultEncoding(encIn || 'utf8');\n\n    // Default output to be strings\n    const encOut = options && options.outputEncoding;\n    if (encOut !== null) {\n      this.setEncoding(encOut || 'utf8');\n    }\n  }\n\n  /**\n   * Adds \\r\\n as needed to the data chunk to ensure that the output Base64 string meets\n   * the maximum line length requirement.\n   * @param {string} chunk\n   * @returns {string}\n   * @private\n   */\n  _fixLineLength(chunk) {\n    // If we care about line length, add line breaks\n    if (!this.lineLength) {\n      return chunk;\n    }\n    const size = chunk.length;\n    const needed = this.lineLength - this.currLineLength;\n    let start, end;\n    let _chunk = '';\n    for (start = 0, end = needed; end < size; start = end, end += this.lineLength) {\n      _chunk += chunk.slice(start, end);\n      _chunk += '\\r\\n';\n    }\n    const left = chunk.slice(start);\n    this.currLineLength = left.length;\n    _chunk += left;\n    return _chunk;\n  }\n\n  /**\n  * Transforms a Buffer chunk of data to a Base64 string chunk.\n  * @param {Buffer} chunk\n  * @param {string} encoding - unused since chunk is always a Buffer\n  * @param cb\n  * @private\n  */\n  _transform(chunk, encoding, cb) {\n    // Add any previous extra bytes to the chunk\n    if (this.extra) {\n      chunk = Buffer.concat([this.extra, chunk]);\n      this.extra = null;\n    }\n\n    // 3 bytes are represented by 4 characters, so we can only encode in groups of 3 bytes\n    const remaining = chunk.length % 3;\n    if (remaining !== 0) {\n      // Store the extra bytes for later\n      this.extra = chunk.slice(chunk.length - remaining);\n      chunk = chunk.slice(0, chunk.length - remaining);\n    }\n\n    // Convert chunk to a base 64 string\n    chunk = chunk.toString('base64');\n\n    // Push the chunk\n    this.push(Buffer.from(this._fixLineLength(chunk)));\n    cb();\n  }\n\n  /**\n   * Emits 0 or 4 extra characters of Base64 data.\n   * @param cb\n   * @private\n   */\n  _flush(cb) {\n    if (this.extra) {\n      this.push(Buffer.from(this._fixLineLength(this.extra.toString('base64'))));\n    }\n    cb();\n  }\n};","map":{"version":3,"names":["Transform","require","module","exports","Base64Encode","constructor","options","extra","lineLength","currLineLength","prefix","push","encIn","inputEncoding","setDefaultEncoding","encOut","outputEncoding","setEncoding","_fixLineLength","chunk","size","length","needed","start","end","_chunk","slice","left","_transform","encoding","cb","Buffer","concat","remaining","toString","from","_flush"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/base64-stream/lib/encode.js"],"sourcesContent":["const { Transform } = require('stream');\n\n/**\n * Transforms a Buffer stream of binary data to a stream of Base64 text. Note that this will\n * also work on a stream of pure strings, as the Writeable base class will automatically decode\n * text string chunks into Buffers.\n * You can pass optionally a line length or a prefix\n * @extends Transform\n */\nmodule.exports = class Base64Encode extends Transform {\n    /**\n     * Creates a Base64Encode\n     * @param {Object=} options - Options for stream creation. Passed to Transform constructor as-is.\n     * @param {string=} options.inputEncoding - The input chunk format. Default is 'utf8'. No effect on Buffer input chunks.\n     * @param {string=} options.outputEncoding - The output chunk format. Default is 'utf8'. Pass `null` for Buffer chunks.\n     * @param {number=} options.lineLength - The max line-length of the output stream.\n     * @param {string=} options.prefix - Prefix for output string.\n     */\n    constructor(options) {\n        super(options);\n\n        // Any extra chars from the last chunk\n        this.extra = null;\n        this.lineLength = options && options.lineLength;\n        this.currLineLength = 0;\n        if (options && options.prefix) {\n            this.push(options.prefix);\n        }\n\n        // Default string input to be treated as 'utf8'\n        const encIn = options && options.inputEncoding;\n        this.setDefaultEncoding(encIn || 'utf8');\n\n        // Default output to be strings\n        const encOut = options && options.outputEncoding;\n        if (encOut !== null) {\n            this.setEncoding(encOut || 'utf8');\n        }\n    }\n\n    /**\n     * Adds \\r\\n as needed to the data chunk to ensure that the output Base64 string meets\n     * the maximum line length requirement.\n     * @param {string} chunk\n     * @returns {string}\n     * @private\n     */\n    _fixLineLength(chunk) {\n        // If we care about line length, add line breaks\n        if (!this.lineLength) {\n            return chunk;\n        }\n\n        const size = chunk.length;\n        const needed = this.lineLength - this.currLineLength;\n        let start, end;\n\n        let _chunk = '';\n        for (start = 0, end = needed; end < size; start = end, end += this.lineLength) {\n            _chunk += chunk.slice(start, end);\n            _chunk += '\\r\\n';\n        }\n\n        const left = chunk.slice(start);\n        this.currLineLength = left.length;\n\n        _chunk += left;\n\n        return _chunk;\n    }\n\n    /**\n    * Transforms a Buffer chunk of data to a Base64 string chunk.\n    * @param {Buffer} chunk\n    * @param {string} encoding - unused since chunk is always a Buffer\n    * @param cb\n    * @private\n    */\n    _transform(chunk, encoding, cb) {\n        // Add any previous extra bytes to the chunk\n        if (this.extra) {\n            chunk = Buffer.concat([this.extra, chunk]);\n            this.extra = null;\n        }\n\n        // 3 bytes are represented by 4 characters, so we can only encode in groups of 3 bytes\n        const remaining = chunk.length % 3;\n\n        if (remaining !== 0) {\n            // Store the extra bytes for later\n            this.extra = chunk.slice(chunk.length - remaining);\n            chunk = chunk.slice(0, chunk.length - remaining);\n        }\n\n        // Convert chunk to a base 64 string\n        chunk = chunk.toString('base64');\n\n        // Push the chunk\n        this.push(Buffer.from(this._fixLineLength(chunk)));\n        cb();\n    }\n\n    /**\n     * Emits 0 or 4 extra characters of Base64 data.\n     * @param cb\n     * @private\n     */\n    _flush(cb) {\n        if (this.extra) {\n            this.push(Buffer.from(this._fixLineLength(this.extra.toString('base64'))));\n        }\n\n        cb();\n    }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}