{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n\n// TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode) {\n  let targetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\nasync function copyToClipboard__EXPERIMENTAL(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = window.getSelection();\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;","map":{"version":3,"names":["html","require","selection","utils","lexical","$getHtmlContent","editor","$getSelection","Error","$isRangeSelection","isCollapsed","getNodes","length","$generateHtmlFromNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","dom","parseFromString","$generateNodesFromDOM","lines","split","linesLength","i","insertText","insertParagraph","isSelectionInsideOfGrid","DEPRECATED_$isGridSelection","$findMatchingParent","anchor","getNode","n","DEPRECATED_$isGridCellNode","focus","DEPRECATED_$isGridNode","$mergeGridNodesStrategy","$basicInsertStrategy","topLevelBlocks","currentBlock","node","isLineBreakNode","$isLineBreakNode","$isDecoratorNode","isInline","$isElementNode","$isTextNode","isParentRequired","createParentElementNode","push","append","insertNodes","anchorCell","isFromLexical","newGrid","newGridRows","getChildren","newColumnCount","getFirstChildOrThrow","getChildrenSize","newRowCount","gridCellNode","gridRowNode","DEPRECATED_$isGridRowNode","gridNode","startY","getIndexWithinParent","stopY","Math","min","startX","stopX","fromX","fromY","toX","max","toY","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","r","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","c","currentGridCellNode","newGridCellNode","getKey","originalChildren","forEach","child","paragraphNode","$createParagraphNode","remove","newGridSelection","DEPRECATED_$createGridSelection","set","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","undefined","exportNodeToJSON","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","selection$1","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","$cloneWithProperties","$sliceSelectedTextNodeContent","__text","childNode","shouldIncludeChild","extractWithChild","serializedChildNode","root","$getRoot","topLevelChildren","topLevelNode","serializedNodes","$parseSerializedNode","$addNodeStyle","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard__EXPERIMENTAL","event","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","domSelection","document","getSelection","element","createElement","style","cssText","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","COPY_COMMAND","secondEvent","ClipboardEvent","window","clearTimeout","COMMAND_PRIORITY_CRITICAL","setTimeout","execCommand","anchorDOM","anchorNode","focusDOM","focusNode","isSelectionWithinEditor","preventDefault","clipboardData","plainString","getTextContent","setData","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/clipboard/LexicalClipboard.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar html = require('@lexical/html');\r\nvar selection = require('@lexical/selection');\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $getHtmlContent(editor) {\r\n  const selection = lexical.$getSelection();\r\n  if (selection == null) {\r\n    {\r\n      throw Error(`Expected valid LexicalSelection`);\r\n    }\r\n  }\r\n\r\n  // If we haven't selected anything\r\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\r\n    return '';\r\n  }\r\n  return html.$generateHtmlFromNodes(editor, selection);\r\n}\r\n\r\n// TODO 0.6.0 Return a blank string instead\r\n// TODO 0.6.0 Rename to $getJSON\r\nfunction $getLexicalContent(editor) {\r\n  const selection = lexical.$getSelection();\r\n  if (selection == null) {\r\n    {\r\n      throw Error(`Expected valid LexicalSelection`);\r\n    }\r\n  }\r\n\r\n  // If we haven't selected anything\r\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\r\n    return null;\r\n  }\r\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\r\n}\r\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\r\n  const text = dataTransfer.getData('text/plain');\r\n  if (text != null) {\r\n    selection.insertRawText(text);\r\n  }\r\n}\r\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\r\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\r\n  if (lexicalString) {\r\n    try {\r\n      const payload = JSON.parse(lexicalString);\r\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\r\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\r\n        return $insertGeneratedNodes(editor, nodes, selection);\r\n      }\r\n    } catch {\r\n      // Fail silently.\r\n    }\r\n  }\r\n  const htmlString = dataTransfer.getData('text/html');\r\n  if (htmlString) {\r\n    try {\r\n      const parser = new DOMParser();\r\n      const dom = parser.parseFromString(htmlString, 'text/html');\r\n      const nodes = html.$generateNodesFromDOM(editor, dom);\r\n      return $insertGeneratedNodes(editor, nodes, selection);\r\n    } catch {\r\n      // Fail silently.\r\n    }\r\n  }\r\n\r\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\r\n  // instead of single paragraph with linebreaks.\r\n  const text = dataTransfer.getData('text/plain');\r\n  if (text != null) {\r\n    if (lexical.$isRangeSelection(selection)) {\r\n      const lines = text.split(/\\r?\\n/);\r\n      const linesLength = lines.length;\r\n      for (let i = 0; i < linesLength; i++) {\r\n        selection.insertText(lines[i]);\r\n        if (i < linesLength - 1) {\r\n          selection.insertParagraph();\r\n        }\r\n      }\r\n    } else {\r\n      selection.insertRawText(text);\r\n    }\r\n  }\r\n}\r\nfunction $insertGeneratedNodes(editor, nodes, selection) {\r\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\r\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\r\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\r\n    return;\r\n  }\r\n  $basicInsertStrategy(nodes, selection);\r\n  return;\r\n}\r\nfunction $basicInsertStrategy(nodes, selection) {\r\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\r\n  const topLevelBlocks = [];\r\n  let currentBlock = null;\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\r\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\r\n      if (currentBlock === null) {\r\n        currentBlock = node.createParentElementNode();\r\n        topLevelBlocks.push(currentBlock);\r\n        // In the case of LineBreakNode, we just need to\r\n        // add an empty ParagraphNode to the topLevelBlocks.\r\n        if (isLineBreakNode) {\r\n          continue;\r\n        }\r\n      }\r\n      if (currentBlock !== null) {\r\n        currentBlock.append(node);\r\n      }\r\n    } else {\r\n      topLevelBlocks.push(node);\r\n      currentBlock = null;\r\n    }\r\n  }\r\n  if (lexical.$isRangeSelection(selection)) {\r\n    selection.insertNodes(topLevelBlocks);\r\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\r\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\r\n    const anchorCell = selection.anchor.getNode();\r\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\r\n      {\r\n        throw Error(`Expected Grid Cell in Grid Selection`);\r\n      }\r\n    }\r\n    anchorCell.append(...topLevelBlocks);\r\n  }\r\n}\r\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\r\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\r\n    {\r\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\r\n    }\r\n  }\r\n  const newGrid = nodes[0];\r\n  const newGridRows = newGrid.getChildren();\r\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\r\n  const newRowCount = newGrid.getChildrenSize();\r\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\r\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\r\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\r\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\r\n    {\r\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\r\n    }\r\n  }\r\n  const startY = gridRowNode.getIndexWithinParent();\r\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\r\n  const startX = gridCellNode.getIndexWithinParent();\r\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\r\n  const fromX = Math.min(startX, stopX);\r\n  const fromY = Math.min(startY, stopY);\r\n  const toX = Math.max(startX, stopX);\r\n  const toY = Math.max(startY, stopY);\r\n  const gridRowNodes = gridNode.getChildren();\r\n  let newRowIdx = 0;\r\n  let newAnchorCellKey;\r\n  let newFocusCellKey;\r\n  for (let r = fromY; r <= toY; r++) {\r\n    const currentGridRowNode = gridRowNodes[r];\r\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\r\n      {\r\n        throw Error(`getNodes: expected to find GridRowNode`);\r\n      }\r\n    }\r\n    const newGridRowNode = newGridRows[newRowIdx];\r\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\r\n      {\r\n        throw Error(`getNodes: expected to find GridRowNode`);\r\n      }\r\n    }\r\n    const gridCellNodes = currentGridRowNode.getChildren();\r\n    const newGridCellNodes = newGridRowNode.getChildren();\r\n    let newColumnIdx = 0;\r\n    for (let c = fromX; c <= toX; c++) {\r\n      const currentGridCellNode = gridCellNodes[c];\r\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\r\n        {\r\n          throw Error(`getNodes: expected to find GridCellNode`);\r\n        }\r\n      }\r\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\r\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\r\n        {\r\n          throw Error(`getNodes: expected to find GridCellNode`);\r\n        }\r\n      }\r\n      if (r === fromY && c === fromX) {\r\n        newAnchorCellKey = currentGridCellNode.getKey();\r\n      } else if (r === toY && c === toX) {\r\n        newFocusCellKey = currentGridCellNode.getKey();\r\n      }\r\n      const originalChildren = currentGridCellNode.getChildren();\r\n      newGridCellNode.getChildren().forEach(child => {\r\n        if (lexical.$isTextNode(child)) {\r\n          const paragraphNode = lexical.$createParagraphNode();\r\n          paragraphNode.append(child);\r\n          currentGridCellNode.append(child);\r\n        } else {\r\n          currentGridCellNode.append(child);\r\n        }\r\n      });\r\n      originalChildren.forEach(n => n.remove());\r\n      newColumnIdx++;\r\n    }\r\n    newRowIdx++;\r\n  }\r\n  if (newAnchorCellKey && newFocusCellKey) {\r\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\r\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\r\n    lexical.$setSelection(newGridSelection);\r\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\r\n  }\r\n}\r\nfunction exportNodeToJSON(node) {\r\n  const serializedNode = node.exportJSON();\r\n  const nodeClass = node.constructor;\r\n\r\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\r\n  if (serializedNode.type !== nodeClass.getType()) {\r\n    {\r\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\r\n    }\r\n  }\r\n\r\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\r\n  const serializedChildren = serializedNode.children;\r\n  if (lexical.$isElementNode(node)) {\r\n    if (!Array.isArray(serializedChildren)) {\r\n      {\r\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\r\n      }\r\n    }\r\n  }\r\n  return serializedNode;\r\n}\r\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\r\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\r\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\r\n  let target = currentNode;\r\n  if (selection$1 !== null) {\r\n    let clone = selection.$cloneWithProperties(currentNode);\r\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\r\n    target = clone;\r\n  }\r\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\r\n  const serializedNode = exportNodeToJSON(target);\r\n\r\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\r\n  // which uses getLatest() to get the text from the original node with the same key.\r\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\r\n  // same node as far as the LexicalEditor is concerned since it shares a key.\r\n  // We need a way to create a clone of a Node in memory with it's own key, but\r\n  // until then this hack will work for the selected text extract use case.\r\n  if (lexical.$isTextNode(target)) {\r\n    const text = target.__text;\r\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\r\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\r\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\r\n    if (text.length > 0) {\r\n      serializedNode.text = text;\r\n    } else {\r\n      shouldInclude = false;\r\n    }\r\n  }\r\n  for (let i = 0; i < children.length; i++) {\r\n    const childNode = children[i];\r\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\r\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\r\n      shouldInclude = true;\r\n    }\r\n  }\r\n  if (shouldInclude && !shouldExclude) {\r\n    targetArray.push(serializedNode);\r\n  } else if (Array.isArray(serializedNode.children)) {\r\n    for (let i = 0; i < serializedNode.children.length; i++) {\r\n      const serializedChildNode = serializedNode.children[i];\r\n      targetArray.push(serializedChildNode);\r\n    }\r\n  }\r\n  return shouldInclude;\r\n}\r\n\r\n// TODO why $ function with Editor instance?\r\nfunction $generateJSONFromSelectedNodes(editor, selection) {\r\n  const nodes = [];\r\n  const root = lexical.$getRoot();\r\n  const topLevelChildren = root.getChildren();\r\n  for (let i = 0; i < topLevelChildren.length; i++) {\r\n    const topLevelNode = topLevelChildren[i];\r\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\r\n  }\r\n  return {\r\n    namespace: editor._config.namespace,\r\n    nodes\r\n  };\r\n}\r\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\r\n  const nodes = [];\r\n  for (let i = 0; i < serializedNodes.length; i++) {\r\n    const serializedNode = serializedNodes[i];\r\n    const node = lexical.$parseSerializedNode(serializedNode);\r\n    if (lexical.$isTextNode(node)) {\r\n      selection.$addNodeStyle(node);\r\n    }\r\n    nodes.push(node);\r\n  }\r\n  return nodes;\r\n}\r\nconst EVENT_LATENCY = 50;\r\nlet clipboardEventTimeout = null;\r\n\r\n// TODO custom selection\r\n// TODO potentially have a node customizable version for plain text\r\nasync function copyToClipboard__EXPERIMENTAL(editor, event) {\r\n  if (clipboardEventTimeout !== null) {\r\n    // Prevent weird race conditions that can happen when this function is run multiple times\r\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\r\n    return false;\r\n  }\r\n  if (event !== null) {\r\n    return new Promise((resolve, reject) => {\r\n      editor.update(() => {\r\n        resolve($copyToClipboardEvent(editor, event));\r\n      });\r\n    });\r\n  }\r\n  const rootElement = editor.getRootElement();\r\n  const domSelection = document.getSelection();\r\n  if (rootElement === null || domSelection === null) {\r\n    return false;\r\n  }\r\n  const element = document.createElement('span');\r\n  element.style.cssText = 'position: fixed; top: -1000px;';\r\n  element.append(document.createTextNode('#'));\r\n  rootElement.append(element);\r\n  const range = new Range();\r\n  range.setStart(element, 0);\r\n  range.setEnd(element, 1);\r\n  domSelection.removeAllRanges();\r\n  domSelection.addRange(range);\r\n  return new Promise((resolve, reject) => {\r\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\r\n      if (secondEvent instanceof ClipboardEvent) {\r\n        removeListener();\r\n        if (clipboardEventTimeout !== null) {\r\n          window.clearTimeout(clipboardEventTimeout);\r\n          clipboardEventTimeout = null;\r\n        }\r\n        resolve($copyToClipboardEvent(editor, secondEvent));\r\n      }\r\n      // Block the entire copy flow while we wait for the next ClipboardEvent\r\n      return true;\r\n    }, lexical.COMMAND_PRIORITY_CRITICAL);\r\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\r\n    // the listener will be quickly freed so that the user can reuse it again\r\n    clipboardEventTimeout = window.setTimeout(() => {\r\n      removeListener();\r\n      clipboardEventTimeout = null;\r\n      resolve(false);\r\n    }, EVENT_LATENCY);\r\n    document.execCommand('copy');\r\n    element.remove();\r\n  });\r\n}\r\n\r\n// TODO shouldn't pass editor (pass namespace directly)\r\nfunction $copyToClipboardEvent(editor, event) {\r\n  const domSelection = window.getSelection();\r\n  if (!domSelection) {\r\n    return false;\r\n  }\r\n  const anchorDOM = domSelection.anchorNode;\r\n  const focusDOM = domSelection.focusNode;\r\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\r\n    return false;\r\n  }\r\n  event.preventDefault();\r\n  const clipboardData = event.clipboardData;\r\n  const selection = lexical.$getSelection();\r\n  if (clipboardData === null || selection === null) {\r\n    return false;\r\n  }\r\n  const htmlString = $getHtmlContent(editor);\r\n  const lexicalString = $getLexicalContent(editor);\r\n  let plainString = '';\r\n  if (selection !== null) {\r\n    plainString = selection.getTextContent();\r\n  }\r\n  if (htmlString !== null) {\r\n    clipboardData.setData('text/html', htmlString);\r\n  }\r\n  if (lexicalString !== null) {\r\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\r\n  }\r\n  clipboardData.setData('text/plain', plainString);\r\n  return true;\r\n}\r\n\r\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\r\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\r\nexports.$getHtmlContent = $getHtmlContent;\r\nexports.$getLexicalContent = $getLexicalContent;\r\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\r\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\r\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\r\nexports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}