{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/link */\n/** @noInheritDoc */\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n  constructor(url) {\n    let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let key = arguments.length > 2 ? arguments[2] : undefined;\n    super(key);\n    const {\n      target = null,\n      rel = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.__url;\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  insertNewAfter(selection) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n}\nfunction convertAnchorElement(domNode) {\n  let node = null;\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\nfunction toggleLink(url) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    target\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noopener' : attributes.rel;\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, ancestor => $isLinkNode(ancestor));\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n  return parent;\n}\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;","map":{"version":3,"names":["utils","require","lexical","LinkNode","ElementNode","getType","clone","node","__url","rel","__rel","target","__target","__key","constructor","url","attributes","key","createDOM","config","element","document","createElement","href","addClassNamesToElement","theme","link","updateDOM","prevNode","anchor","removeAttribute","importDOM","a","conversion","convertAnchorElement","priority","importJSON","serializedNode","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","getRel","getTarget","type","getURL","version","getLatest","setURL","writable","getWritable","setTarget","setRel","insertNewAfter","selection","restoreSelection","getParentOrThrow","$isElementNode","linkNode","append","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","destination","$isRangeSelection","anchorNode","getNode","focusNode","focus","isParentOf","getTextContent","length","domNode","isHTMLAnchorElement","content","textContent","getAttribute","$applyNodeReplacement","$isLinkNode","AutoLinkNode","$createAutoLinkNode","_rel","$isAutoLinkNode","TOGGLE_LINK_COMMAND","createCommand","toggleLink","undefined","$getSelection","nodes","extract","forEach","parent","getParent","children","getChildren","i","insertBefore","remove","firstNode","$getLinkAncestor","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","ancestor","predicate","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/link/LexicalLink.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/link */\r\n/** @noInheritDoc */\r\nclass LinkNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'link';\r\n  }\r\n  static clone(node) {\r\n    return new LinkNode(node.__url, {\r\n      rel: node.__rel,\r\n      target: node.__target\r\n    }, node.__key);\r\n  }\r\n  constructor(url, attributes = {}, key) {\r\n    super(key);\r\n    const {\r\n      target = null,\r\n      rel = null\r\n    } = attributes;\r\n    this.__url = url;\r\n    this.__target = target;\r\n    this.__rel = rel;\r\n  }\r\n  createDOM(config) {\r\n    const element = document.createElement('a');\r\n    element.href = this.__url;\r\n    if (this.__target !== null) {\r\n      element.target = this.__target;\r\n    }\r\n    if (this.__rel !== null) {\r\n      element.rel = this.__rel;\r\n    }\r\n    utils.addClassNamesToElement(element, config.theme.link);\r\n    return element;\r\n  }\r\n  updateDOM(prevNode, anchor, config) {\r\n    const url = this.__url;\r\n    const target = this.__target;\r\n    const rel = this.__rel;\r\n    if (url !== prevNode.__url) {\r\n      anchor.href = url;\r\n    }\r\n    if (target !== prevNode.__target) {\r\n      if (target) {\r\n        anchor.target = target;\r\n      } else {\r\n        anchor.removeAttribute('target');\r\n      }\r\n    }\r\n    if (rel !== prevNode.__rel) {\r\n      if (rel) {\r\n        anchor.rel = rel;\r\n      } else {\r\n        anchor.removeAttribute('rel');\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      a: node => ({\r\n        conversion: convertAnchorElement,\r\n        priority: 1\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createLinkNode(serializedNode.url, {\r\n      rel: serializedNode.rel,\r\n      target: serializedNode.target\r\n    });\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      rel: this.getRel(),\r\n      target: this.getTarget(),\r\n      type: 'link',\r\n      url: this.getURL(),\r\n      version: 1\r\n    };\r\n  }\r\n  getURL() {\r\n    return this.getLatest().__url;\r\n  }\r\n  setURL(url) {\r\n    const writable = this.getWritable();\r\n    writable.__url = url;\r\n  }\r\n  getTarget() {\r\n    return this.getLatest().__target;\r\n  }\r\n  setTarget(target) {\r\n    const writable = this.getWritable();\r\n    writable.__target = target;\r\n  }\r\n  getRel() {\r\n    return this.getLatest().__rel;\r\n  }\r\n  setRel(rel) {\r\n    const writable = this.getWritable();\r\n    writable.__rel = rel;\r\n  }\r\n  insertNewAfter(selection, restoreSelection = true) {\r\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\r\n    if (lexical.$isElementNode(element)) {\r\n      const linkNode = $createLinkNode(this.__url, {\r\n        rel: this.__rel,\r\n        target: this.__target\r\n      });\r\n      element.append(linkNode);\r\n      return linkNode;\r\n    }\r\n    return null;\r\n  }\r\n  canInsertTextBefore() {\r\n    return false;\r\n  }\r\n  canInsertTextAfter() {\r\n    return false;\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  isInline() {\r\n    return true;\r\n  }\r\n  extractWithChild(child, selection, destination) {\r\n    if (!lexical.$isRangeSelection(selection)) {\r\n      return false;\r\n    }\r\n    const anchorNode = selection.anchor.getNode();\r\n    const focusNode = selection.focus.getNode();\r\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\r\n  }\r\n}\r\nfunction convertAnchorElement(domNode) {\r\n  let node = null;\r\n  if (utils.isHTMLAnchorElement(domNode)) {\r\n    const content = domNode.textContent;\r\n    if (content !== null && content !== '') {\r\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\r\n        rel: domNode.getAttribute('rel'),\r\n        target: domNode.getAttribute('target')\r\n      });\r\n    }\r\n  }\r\n  return {\r\n    node\r\n  };\r\n}\r\nfunction $createLinkNode(url, attributes) {\r\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\r\n}\r\nfunction $isLinkNode(node) {\r\n  return node instanceof LinkNode;\r\n}\r\n// Custom node type to override `canInsertTextAfter` that will\r\n// allow typing within the link\r\nclass AutoLinkNode extends LinkNode {\r\n  static getType() {\r\n    return 'autolink';\r\n  }\r\n  static clone(node) {\r\n    return new AutoLinkNode(node.__url, {\r\n      rel: node.__rel,\r\n      target: node.__target\r\n    }, node.__key);\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createAutoLinkNode(serializedNode.url, {\r\n      rel: serializedNode.rel,\r\n      target: serializedNode.target\r\n    });\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  static importDOM() {\r\n    // TODO: Should link node should handle the import over autolink?\r\n    return null;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'autolink',\r\n      version: 1\r\n    };\r\n  }\r\n  insertNewAfter(selection, restoreSelection = true) {\r\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\r\n    if (lexical.$isElementNode(element)) {\r\n      const linkNode = $createAutoLinkNode(this.__url, {\r\n        rel: this._rel,\r\n        target: this.__target\r\n      });\r\n      element.append(linkNode);\r\n      return linkNode;\r\n    }\r\n    return null;\r\n  }\r\n}\r\nfunction $createAutoLinkNode(url, attributes) {\r\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\r\n}\r\nfunction $isAutoLinkNode(node) {\r\n  return node instanceof AutoLinkNode;\r\n}\r\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\r\nfunction toggleLink(url, attributes = {}) {\r\n  const {\r\n    target\r\n  } = attributes;\r\n  const rel = attributes.rel === undefined ? 'noopener' : attributes.rel;\r\n  const selection = lexical.$getSelection();\r\n  if (!lexical.$isRangeSelection(selection)) {\r\n    return;\r\n  }\r\n  const nodes = selection.extract();\r\n  if (url === null) {\r\n    // Remove LinkNodes\r\n    nodes.forEach(node => {\r\n      const parent = node.getParent();\r\n      if ($isLinkNode(parent)) {\r\n        const children = parent.getChildren();\r\n        for (let i = 0; i < children.length; i++) {\r\n          parent.insertBefore(children[i]);\r\n        }\r\n        parent.remove();\r\n      }\r\n    });\r\n  } else {\r\n    // Add or merge LinkNodes\r\n    if (nodes.length === 1) {\r\n      const firstNode = nodes[0];\r\n      // if the first node is a LinkNode or if its\r\n      // parent is a LinkNode, we update the URL, target and rel.\r\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\r\n      if (linkNode !== null) {\r\n        linkNode.setURL(url);\r\n        if (target !== undefined) {\r\n          linkNode.setTarget(target);\r\n        }\r\n        if (rel !== null) {\r\n          linkNode.setRel(rel);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    let prevParent = null;\r\n    let linkNode = null;\r\n    nodes.forEach(node => {\r\n      const parent = node.getParent();\r\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\r\n        return;\r\n      }\r\n      if ($isLinkNode(parent)) {\r\n        linkNode = parent;\r\n        parent.setURL(url);\r\n        if (target !== undefined) {\r\n          parent.setTarget(target);\r\n        }\r\n        if (rel !== null) {\r\n          linkNode.setRel(rel);\r\n        }\r\n        return;\r\n      }\r\n      if (!parent.is(prevParent)) {\r\n        prevParent = parent;\r\n        linkNode = $createLinkNode(url, {\r\n          rel,\r\n          target\r\n        });\r\n        if ($isLinkNode(parent)) {\r\n          if (node.getPreviousSibling() === null) {\r\n            parent.insertBefore(linkNode);\r\n          } else {\r\n            parent.insertAfter(linkNode);\r\n          }\r\n        } else {\r\n          node.insertBefore(linkNode);\r\n        }\r\n      }\r\n      if ($isLinkNode(node)) {\r\n        if (node.is(linkNode)) {\r\n          return;\r\n        }\r\n        if (linkNode !== null) {\r\n          const children = node.getChildren();\r\n          for (let i = 0; i < children.length; i++) {\r\n            linkNode.append(children[i]);\r\n          }\r\n        }\r\n        node.remove();\r\n        return;\r\n      }\r\n      if (linkNode !== null) {\r\n        linkNode.append(node);\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction $getLinkAncestor(node) {\r\n  return $getAncestor(node, ancestor => $isLinkNode(ancestor));\r\n}\r\nfunction $getAncestor(node, predicate) {\r\n  let parent = node;\r\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\r\n  return parent;\r\n}\r\n\r\nexports.$createAutoLinkNode = $createAutoLinkNode;\r\nexports.$createLinkNode = $createLinkNode;\r\nexports.$isAutoLinkNode = $isAutoLinkNode;\r\nexports.$isLinkNode = $isLinkNode;\r\nexports.AutoLinkNode = AutoLinkNode;\r\nexports.LinkNode = LinkNode;\r\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\r\nexports.toggleLink = toggleLink;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}