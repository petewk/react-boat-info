{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/text */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\nfunction $isRootTextContentEmpty(isEditorComposing) {\n  let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;","map":{"version":3,"names":["lexical","require","$findTextIntersectionFromCharacters","root","targetCharacters","node","getFirstChild","currentCharacters","mainLoop","$isElementNode","child","$isTextNode","characters","getTextContentSize","offset","sibling","getNextSibling","parent","getParent","parentSibling","$isRootTextContentEmpty","isEditorComposing","trim","text","$rootTextContent","$isRootTextContentEmptyCurry","$getRoot","getTextContent","$canShowPlaceholder","isComposing","children","getChildren","childrenLength","length","i","topBlock","$isParagraphNode","__indent","topBlockChildren","topBlockChildrenLength","s","$canShowPlaceholderCurry","registerLexicalTextEntity","editor","getMatch","targetNode","createNode","isTargetNode","replaceWithSimpleText","textNode","$createTextNode","setFormat","getFormat","replace","getMode","getLatest","__mode","textNodeTransform","isSimpleText","prevSibling","getPreviousSibling","currentNode","match","previousText","combinedText","prevMatch","diff","end","concatText","slice","newTextContent","select","setTextContent","remove","remainingText","start","nextText","nextSibling","nextMatch","markDirty","isTextEntity","nodeToReplace","splitText","replacementNode","reverseNodeTransform","removePlainTextTransform","registerNodeTransform","TextNode","removeReverseNodeTransform","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/text/LexicalText.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/text */\r\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\r\n  let node = root.getFirstChild();\r\n  let currentCharacters = 0;\r\n  mainLoop: while (node !== null) {\r\n    if (lexical.$isElementNode(node)) {\r\n      const child = node.getFirstChild();\r\n      if (child !== null) {\r\n        node = child;\r\n        continue;\r\n      }\r\n    } else if (lexical.$isTextNode(node)) {\r\n      const characters = node.getTextContentSize();\r\n      if (currentCharacters + characters > targetCharacters) {\r\n        return {\r\n          node,\r\n          offset: targetCharacters - currentCharacters\r\n        };\r\n      }\r\n      currentCharacters += characters;\r\n    }\r\n    const sibling = node.getNextSibling();\r\n    if (sibling !== null) {\r\n      node = sibling;\r\n      continue;\r\n    }\r\n    let parent = node.getParent();\r\n    while (parent !== null) {\r\n      const parentSibling = parent.getNextSibling();\r\n      if (parentSibling !== null) {\r\n        node = parentSibling;\r\n        continue mainLoop;\r\n      }\r\n      parent = parent.getParent();\r\n    }\r\n    break;\r\n  }\r\n  return null;\r\n}\r\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\r\n  if (isEditorComposing) {\r\n    return false;\r\n  }\r\n  let text = $rootTextContent();\r\n  if (trim) {\r\n    text = text.trim();\r\n  }\r\n  return text === '';\r\n}\r\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\r\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\r\n}\r\nfunction $rootTextContent() {\r\n  const root = lexical.$getRoot();\r\n  return root.getTextContent();\r\n}\r\nfunction $canShowPlaceholder(isComposing) {\r\n  if (!$isRootTextContentEmpty(isComposing, false)) {\r\n    return false;\r\n  }\r\n  const root = lexical.$getRoot();\r\n  const children = root.getChildren();\r\n  const childrenLength = children.length;\r\n  if (childrenLength > 1) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < childrenLength; i++) {\r\n    const topBlock = children[i];\r\n    if (lexical.$isElementNode(topBlock)) {\r\n      if (!lexical.$isParagraphNode(topBlock)) {\r\n        return false;\r\n      }\r\n      if (topBlock.__indent !== 0) {\r\n        return false;\r\n      }\r\n      const topBlockChildren = topBlock.getChildren();\r\n      const topBlockChildrenLength = topBlockChildren.length;\r\n      for (let s = 0; s < topBlockChildrenLength; s++) {\r\n        const child = topBlockChildren[i];\r\n        if (!lexical.$isTextNode(child)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction $canShowPlaceholderCurry(isEditorComposing) {\r\n  return () => $canShowPlaceholder(isEditorComposing);\r\n}\r\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\r\n  const isTargetNode = node => {\r\n    return node instanceof targetNode;\r\n  };\r\n  const replaceWithSimpleText = node => {\r\n    const textNode = lexical.$createTextNode(node.getTextContent());\r\n    textNode.setFormat(node.getFormat());\r\n    node.replace(textNode);\r\n  };\r\n  const getMode = node => {\r\n    return node.getLatest().__mode;\r\n  };\r\n  const textNodeTransform = node => {\r\n    if (!node.isSimpleText()) {\r\n      return;\r\n    }\r\n    const prevSibling = node.getPreviousSibling();\r\n    let text = node.getTextContent();\r\n    let currentNode = node;\r\n    let match;\r\n    if (lexical.$isTextNode(prevSibling)) {\r\n      const previousText = prevSibling.getTextContent();\r\n      const combinedText = previousText + text;\r\n      const prevMatch = getMatch(combinedText);\r\n      if (isTargetNode(prevSibling)) {\r\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\r\n          replaceWithSimpleText(prevSibling);\r\n          return;\r\n        } else {\r\n          const diff = prevMatch.end - previousText.length;\r\n          if (diff > 0) {\r\n            const concatText = text.slice(0, diff);\r\n            const newTextContent = previousText + concatText;\r\n            prevSibling.select();\r\n            prevSibling.setTextContent(newTextContent);\r\n            if (diff === text.length) {\r\n              node.remove();\r\n            } else {\r\n              const remainingText = text.slice(diff);\r\n              node.setTextContent(remainingText);\r\n            }\r\n            return;\r\n          }\r\n        }\r\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      match = getMatch(text);\r\n      let nextText = match === null ? '' : text.slice(match.end);\r\n      text = nextText;\r\n      if (nextText === '') {\r\n        const nextSibling = currentNode.getNextSibling();\r\n        if (lexical.$isTextNode(nextSibling)) {\r\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\r\n          const nextMatch = getMatch(nextText);\r\n          if (nextMatch === null) {\r\n            if (isTargetNode(nextSibling)) {\r\n              replaceWithSimpleText(nextSibling);\r\n            } else {\r\n              nextSibling.markDirty();\r\n            }\r\n            return;\r\n          } else if (nextMatch.start !== 0) {\r\n            return;\r\n          }\r\n        }\r\n      } else {\r\n        const nextMatch = getMatch(nextText);\r\n        if (nextMatch !== null && nextMatch.start === 0) {\r\n          return;\r\n        }\r\n      }\r\n      if (match === null) {\r\n        return;\r\n      }\r\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\r\n        continue;\r\n      }\r\n      let nodeToReplace;\r\n      if (match.start === 0) {\r\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\r\n      } else {\r\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\r\n      }\r\n      const replacementNode = createNode(nodeToReplace);\r\n      nodeToReplace.replace(replacementNode);\r\n      if (currentNode == null) {\r\n        return;\r\n      }\r\n    }\r\n  };\r\n  const reverseNodeTransform = node => {\r\n    const text = node.getTextContent();\r\n    const match = getMatch(text);\r\n    if (match === null || match.start !== 0) {\r\n      replaceWithSimpleText(node);\r\n      return;\r\n    }\r\n    if (text.length > match.end) {\r\n      // This will split out the rest of the text as simple text\r\n      node.splitText(match.end);\r\n      return;\r\n    }\r\n    const prevSibling = node.getPreviousSibling();\r\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\r\n      replaceWithSimpleText(prevSibling);\r\n      replaceWithSimpleText(node);\r\n    }\r\n    const nextSibling = node.getNextSibling();\r\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\r\n      replaceWithSimpleText(nextSibling);\r\n\r\n      // This may have already been converted in the previous block\r\n      if (isTargetNode(node)) {\r\n        replaceWithSimpleText(node);\r\n      }\r\n    }\r\n  };\r\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\r\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\r\n  return [removePlainTextTransform, removeReverseNodeTransform];\r\n}\r\n\r\nexports.$canShowPlaceholder = $canShowPlaceholder;\r\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\r\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\r\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\r\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\r\nexports.$rootTextContent = $rootTextContent;\r\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}