{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n\n/**\r\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\r\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\r\n * or an equivilant library and pass in the document here.\r\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement) {\n  let selection$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = new DocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE']);\nfunction $createNodesFromDOM(node, editor) {\n  let forChildMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  let parentLexicalNode = arguments.length > 3 ? arguments[3] : undefined;\n  let preformatted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;","map":{"version":3,"names":["selection","require","lexical","$generateNodesFromDOM","editor","dom","lexicalNodes","elements","body","Array","from","childNodes","elementsLength","length","i","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$generateHtmlFromNodes","document","window","Error","container","createElement","root","$getRoot","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","selection$1","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","children","after","exportDOM","fragment","DocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","undefined","cachedConversion","domConversion","priority","conversion","Set","node","forChildMap","Map","parentLexicalNode","preformatted","currentLexicalNode","transformFunction","transformOutput","postTransform","forChildFunction","push","forChild","set","childLexicalNodes","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/html/LexicalHtml.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar selection = require('@lexical/selection');\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/html */\r\n\r\n/**\r\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\r\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\r\n * or an equivilant library and pass in the document here.\r\n */\r\nfunction $generateNodesFromDOM(editor, dom) {\r\n  let lexicalNodes = [];\r\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\r\n  const elementsLength = elements.length;\r\n  for (let i = 0; i < elementsLength; i++) {\r\n    const element = elements[i];\r\n    if (!IGNORE_TAGS.has(element.nodeName)) {\r\n      const lexicalNode = $createNodesFromDOM(element, editor);\r\n      if (lexicalNode !== null) {\r\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\r\n      }\r\n    }\r\n  }\r\n  return lexicalNodes;\r\n}\r\nfunction $generateHtmlFromNodes(editor, selection) {\r\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\r\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\r\n  }\r\n  const container = document.createElement('div');\r\n  const root = lexical.$getRoot();\r\n  const topLevelChildren = root.getChildren();\r\n  for (let i = 0; i < topLevelChildren.length; i++) {\r\n    const topLevelNode = topLevelChildren[i];\r\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\r\n  }\r\n  return container.innerHTML;\r\n}\r\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\r\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\r\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\r\n  let target = currentNode;\r\n  if (selection$1 !== null) {\r\n    let clone = selection.$cloneWithProperties(currentNode);\r\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\r\n    target = clone;\r\n  }\r\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\r\n  const {\r\n    element,\r\n    after\r\n  } = target.exportDOM(editor);\r\n  if (!element) {\r\n    return false;\r\n  }\r\n  const fragment = new DocumentFragment();\r\n  for (let i = 0; i < children.length; i++) {\r\n    const childNode = children[i];\r\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\r\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\r\n      shouldInclude = true;\r\n    }\r\n  }\r\n  if (shouldInclude && !shouldExclude) {\r\n    element.append(fragment);\r\n    parentElement.append(element);\r\n    if (after) {\r\n      const newElement = after.call(target, element);\r\n      if (newElement) element.replaceWith(newElement);\r\n    }\r\n  } else {\r\n    parentElement.append(fragment);\r\n  }\r\n  return shouldInclude;\r\n}\r\nfunction getConversionFunction(domNode, editor) {\r\n  const {\r\n    nodeName\r\n  } = domNode;\r\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\r\n  let currentConversion = null;\r\n  if (cachedConversions !== undefined) {\r\n    for (const cachedConversion of cachedConversions) {\r\n      const domConversion = cachedConversion(domNode);\r\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\r\n        currentConversion = domConversion;\r\n      }\r\n    }\r\n  }\r\n  return currentConversion !== null ? currentConversion.conversion : null;\r\n}\r\nconst IGNORE_TAGS = new Set(['STYLE']);\r\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\r\n  let lexicalNodes = [];\r\n  if (IGNORE_TAGS.has(node.nodeName)) {\r\n    return lexicalNodes;\r\n  }\r\n  let currentLexicalNode = null;\r\n  const transformFunction = getConversionFunction(node, editor);\r\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\r\n  let postTransform = null;\r\n  if (transformOutput !== null) {\r\n    postTransform = transformOutput.after;\r\n    currentLexicalNode = transformOutput.node;\r\n    if (currentLexicalNode !== null) {\r\n      for (const [, forChildFunction] of forChildMap) {\r\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\r\n        if (!currentLexicalNode) {\r\n          break;\r\n        }\r\n      }\r\n      if (currentLexicalNode) {\r\n        lexicalNodes.push(currentLexicalNode);\r\n      }\r\n    }\r\n    if (transformOutput.forChild != null) {\r\n      forChildMap.set(node.nodeName, transformOutput.forChild);\r\n    }\r\n  }\r\n\r\n  // If the DOM node doesn't have a transformer, we don't know what\r\n  // to do with it but we still need to process any childNodes.\r\n  const children = node.childNodes;\r\n  let childLexicalNodes = [];\r\n  for (let i = 0; i < children.length; i++) {\r\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\r\n  }\r\n  if (postTransform != null) {\r\n    childLexicalNodes = postTransform(childLexicalNodes);\r\n  }\r\n  if (currentLexicalNode == null) {\r\n    // If it hasn't been converted to a LexicalNode, we hoist its children\r\n    // up to the same level as it.\r\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\r\n  } else {\r\n    if (lexical.$isElementNode(currentLexicalNode)) {\r\n      // If the current node is a ElementNode after conversion,\r\n      // we can append all the children to it.\r\n      currentLexicalNode.append(...childLexicalNodes);\r\n    }\r\n  }\r\n  return lexicalNodes;\r\n}\r\n\r\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\r\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAS,CAAC;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqB,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC1C,IAAIC,YAAY,GAAG,EAAE;EACrB,MAAMC,QAAQ,GAAGF,GAAG,CAACG,IAAI,GAAGC,KAAK,CAACC,IAAI,CAACL,GAAG,CAACG,IAAI,CAACG,UAAU,CAAC,GAAG,EAAE;EAChE,MAAMC,cAAc,GAAGL,QAAQ,CAACM,MAAM;EACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,cAAc,EAAEE,CAAC,EAAE,EAAE;IACvC,MAAMC,OAAO,GAAGR,QAAQ,CAACO,CAAC,CAAC;IAC3B,IAAI,CAACE,WAAW,CAACC,GAAG,CAACF,OAAO,CAACG,QAAQ,CAAC,EAAE;MACtC,MAAMC,WAAW,GAAGC,mBAAmB,CAACL,OAAO,EAAEX,MAAM,CAAC;MACxD,IAAIe,WAAW,KAAK,IAAI,EAAE;QACxBb,YAAY,GAAGA,YAAY,CAACe,MAAM,CAACF,WAAW,CAAC;MACjD;IACF;EACF;EACA,OAAOb,YAAY;AACrB;AACA,SAASgB,sBAAsB,CAAClB,MAAM,EAAEJ,SAAS,EAAE;EACjD,IAAI,OAAOuB,QAAQ,KAAK,WAAW,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACpE,MAAM,IAAIC,KAAK,CAAC,gJAAgJ,CAAC;EACnK;EACA,MAAMC,SAAS,GAAGH,QAAQ,CAACI,aAAa,CAAC,KAAK,CAAC;EAC/C,MAAMC,IAAI,GAAG1B,OAAO,CAAC2B,QAAQ,EAAE;EAC/B,MAAMC,gBAAgB,GAAGF,IAAI,CAACG,WAAW,EAAE;EAC3C,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,gBAAgB,CAACjB,MAAM,EAAEC,CAAC,EAAE,EAAE;IAChD,MAAMkB,YAAY,GAAGF,gBAAgB,CAAChB,CAAC,CAAC;IACxCmB,kBAAkB,CAAC7B,MAAM,EAAE4B,YAAY,EAAEN,SAAS,EAAE1B,SAAS,CAAC;EAChE;EACA,OAAO0B,SAAS,CAACQ,SAAS;AAC5B;AACA,SAASD,kBAAkB,CAAC7B,MAAM,EAAE+B,WAAW,EAAEC,aAAa,EAAsB;EAAA,IAApBC,WAAW,uEAAG,IAAI;EAChF,IAAIC,aAAa,GAAGD,WAAW,IAAI,IAAI,GAAGF,WAAW,CAACI,UAAU,EAAE,GAAG,IAAI;EACzE,MAAMC,aAAa,GAAGtC,OAAO,CAACuC,cAAc,CAACN,WAAW,CAAC,IAAIA,WAAW,CAACO,eAAe,CAAC,MAAM,CAAC;EAChG,IAAIC,MAAM,GAAGR,WAAW;EACxB,IAAIE,WAAW,KAAK,IAAI,EAAE;IACxB,IAAIO,KAAK,GAAG5C,SAAS,CAAC6C,oBAAoB,CAACV,WAAW,CAAC;IACvDS,KAAK,GAAG1C,OAAO,CAAC4C,WAAW,CAACF,KAAK,CAAC,IAAIP,WAAW,IAAI,IAAI,GAAGrC,SAAS,CAAC+C,6BAA6B,CAACV,WAAW,EAAEO,KAAK,CAAC,GAAGA,KAAK;IAC/HD,MAAM,GAAGC,KAAK;EAChB;EACA,MAAMI,QAAQ,GAAG9C,OAAO,CAACuC,cAAc,CAACE,MAAM,CAAC,GAAGA,MAAM,CAACZ,WAAW,EAAE,GAAG,EAAE;EAC3E,MAAM;IACJhB,OAAO;IACPkC;EACF,CAAC,GAAGN,MAAM,CAACO,SAAS,CAAC9C,MAAM,CAAC;EAC5B,IAAI,CAACW,OAAO,EAAE;IACZ,OAAO,KAAK;EACd;EACA,MAAMoC,QAAQ,GAAG,IAAIC,gBAAgB,EAAE;EACvC,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,QAAQ,CAACnC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACxC,MAAMuC,SAAS,GAAGL,QAAQ,CAAClC,CAAC,CAAC;IAC7B,MAAMwC,kBAAkB,GAAGrB,kBAAkB,CAAC7B,MAAM,EAAEiD,SAAS,EAAEF,QAAQ,EAAEd,WAAW,CAAC;IACvF,IAAI,CAACC,aAAa,IAAIpC,OAAO,CAACuC,cAAc,CAACN,WAAW,CAAC,IAAImB,kBAAkB,IAAInB,WAAW,CAACoB,gBAAgB,CAACF,SAAS,EAAEhB,WAAW,EAAE,MAAM,CAAC,EAAE;MAC/IC,aAAa,GAAG,IAAI;IACtB;EACF;EACA,IAAIA,aAAa,IAAI,CAACE,aAAa,EAAE;IACnCzB,OAAO,CAACyC,MAAM,CAACL,QAAQ,CAAC;IACxBf,aAAa,CAACoB,MAAM,CAACzC,OAAO,CAAC;IAC7B,IAAIkC,KAAK,EAAE;MACT,MAAMQ,UAAU,GAAGR,KAAK,CAACS,IAAI,CAACf,MAAM,EAAE5B,OAAO,CAAC;MAC9C,IAAI0C,UAAU,EAAE1C,OAAO,CAAC4C,WAAW,CAACF,UAAU,CAAC;IACjD;EACF,CAAC,MAAM;IACLrB,aAAa,CAACoB,MAAM,CAACL,QAAQ,CAAC;EAChC;EACA,OAAOb,aAAa;AACtB;AACA,SAASsB,qBAAqB,CAACC,OAAO,EAAEzD,MAAM,EAAE;EAC9C,MAAM;IACJc;EACF,CAAC,GAAG2C,OAAO;EACX,MAAMC,iBAAiB,GAAG1D,MAAM,CAAC2D,gBAAgB,CAACC,GAAG,CAAC9C,QAAQ,CAAC+C,WAAW,EAAE,CAAC;EAC7E,IAAIC,iBAAiB,GAAG,IAAI;EAC5B,IAAIJ,iBAAiB,KAAKK,SAAS,EAAE;IACnC,KAAK,MAAMC,gBAAgB,IAAIN,iBAAiB,EAAE;MAChD,MAAMO,aAAa,GAAGD,gBAAgB,CAACP,OAAO,CAAC;MAC/C,IAAIQ,aAAa,KAAK,IAAI,KAAKH,iBAAiB,KAAK,IAAI,IAAIA,iBAAiB,CAACI,QAAQ,GAAGD,aAAa,CAACC,QAAQ,CAAC,EAAE;QACjHJ,iBAAiB,GAAGG,aAAa;MACnC;IACF;EACF;EACA,OAAOH,iBAAiB,KAAK,IAAI,GAAGA,iBAAiB,CAACK,UAAU,GAAG,IAAI;AACzE;AACA,MAAMvD,WAAW,GAAG,IAAIwD,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC;AACtC,SAASpD,mBAAmB,CAACqD,IAAI,EAAErE,MAAM,EAAoE;EAAA,IAAlEsE,WAAW,uEAAG,IAAIC,GAAG,EAAE;EAAA,IAAEC,iBAAiB;EAAA,IAAEC,YAAY,uEAAG,KAAK;EACzG,IAAIvE,YAAY,GAAG,EAAE;EACrB,IAAIU,WAAW,CAACC,GAAG,CAACwD,IAAI,CAACvD,QAAQ,CAAC,EAAE;IAClC,OAAOZ,YAAY;EACrB;EACA,IAAIwE,kBAAkB,GAAG,IAAI;EAC7B,MAAMC,iBAAiB,GAAGnB,qBAAqB,CAACa,IAAI,EAAErE,MAAM,CAAC;EAC7D,MAAM4E,eAAe,GAAGD,iBAAiB,GAAGA,iBAAiB,CAACN,IAAI,EAAEN,SAAS,EAAEU,YAAY,CAAC,GAAG,IAAI;EACnG,IAAII,aAAa,GAAG,IAAI;EACxB,IAAID,eAAe,KAAK,IAAI,EAAE;IAC5BC,aAAa,GAAGD,eAAe,CAAC/B,KAAK;IACrC6B,kBAAkB,GAAGE,eAAe,CAACP,IAAI;IACzC,IAAIK,kBAAkB,KAAK,IAAI,EAAE;MAC/B,KAAK,MAAM,GAAGI,gBAAgB,CAAC,IAAIR,WAAW,EAAE;QAC9CI,kBAAkB,GAAGI,gBAAgB,CAACJ,kBAAkB,EAAEF,iBAAiB,CAAC;QAC5E,IAAI,CAACE,kBAAkB,EAAE;UACvB;QACF;MACF;MACA,IAAIA,kBAAkB,EAAE;QACtBxE,YAAY,CAAC6E,IAAI,CAACL,kBAAkB,CAAC;MACvC;IACF;IACA,IAAIE,eAAe,CAACI,QAAQ,IAAI,IAAI,EAAE;MACpCV,WAAW,CAACW,GAAG,CAACZ,IAAI,CAACvD,QAAQ,EAAE8D,eAAe,CAACI,QAAQ,CAAC;IAC1D;EACF;;EAEA;EACA;EACA,MAAMpC,QAAQ,GAAGyB,IAAI,CAAC9D,UAAU;EAChC,IAAI2E,iBAAiB,GAAG,EAAE;EAC1B,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,QAAQ,CAACnC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACxCwE,iBAAiB,CAACH,IAAI,CAAC,GAAG/D,mBAAmB,CAAC4B,QAAQ,CAAClC,CAAC,CAAC,EAAEV,MAAM,EAAE,IAAIuE,GAAG,CAACD,WAAW,CAAC,EAAEI,kBAAkB,EAAED,YAAY,IAAI,CAACG,eAAe,IAAIA,eAAe,CAACH,YAAY,MAAM,IAAI,CAAC,CAAC;EAC3L;EACA,IAAII,aAAa,IAAI,IAAI,EAAE;IACzBK,iBAAiB,GAAGL,aAAa,CAACK,iBAAiB,CAAC;EACtD;EACA,IAAIR,kBAAkB,IAAI,IAAI,EAAE;IAC9B;IACA;IACAxE,YAAY,GAAGA,YAAY,CAACe,MAAM,CAACiE,iBAAiB,CAAC;EACvD,CAAC,MAAM;IACL,IAAIpF,OAAO,CAACuC,cAAc,CAACqC,kBAAkB,CAAC,EAAE;MAC9C;MACA;MACAA,kBAAkB,CAACtB,MAAM,CAAC,GAAG8B,iBAAiB,CAAC;IACjD;EACF;EACA,OAAOhF,YAAY;AACrB;AAEAiF,OAAO,CAACjE,sBAAsB,GAAGA,sBAAsB;AACvDiE,OAAO,CAACpF,qBAAqB,GAAGA,qBAAqB"},"metadata":{},"sourceType":"script","externalDependencies":[]}