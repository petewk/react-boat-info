{"ast":null,"code":"import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? `${hasWidth}px` : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) {\n        fixedWidth = false;\n      }\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width !== cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`;\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = `${totalWidth}px`;\n  }\n}\nclass TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n  update(node) {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    this.node = node;\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(mutation) {\n    return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));\n  }\n}\nfunction createCell(cellType, cellContent) {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n  return cellType.createAndFill();\n}\nfunction getTableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n  const types = getTableNodeTypes(schema);\n  const headerCells = [];\n  const cells = [];\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent);\n    if (cell) {\n      cells.push(cell);\n    }\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent);\n      if (headerCell) {\n        headerCells.push(headerCell);\n      }\n    }\n  }\n  const rows = [];\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n  }\n  return types.table.createChecked(null, rows);\n}\nfunction isCellSelection(value) {\n  return value instanceof CellSelection;\n}\nconst deleteTableWhenAllCellsSelected = _ref => {\n  let {\n    editor\n  } = _ref;\n  const {\n    selection\n  } = editor.state;\n  if (!isCellSelection(selection)) {\n    return false;\n  }\n  let cellCount = 0;\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table';\n  });\n  table === null || table === void 0 ? void 0 : table.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false;\n    }\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1;\n    }\n  });\n  const allCellsSelected = cellCount === selection.ranges.length;\n  if (!allCellsSelected) {\n    return false;\n  }\n  editor.commands.deleteTable();\n  return true;\n};\nconst Table = Node.create({\n  name: 'table',\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false\n    };\n  },\n  content: 'tableRow+',\n  tableRole: 'table',\n  isolating: true,\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'table'\n    }];\n  },\n  renderHTML(_ref2) {\n    let {\n      HTMLAttributes\n    } = _ref2;\n    return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\n  },\n  addCommands() {\n    return {\n      insertTable: function () {\n        let {\n          rows = 3,\n          cols = 3,\n          withHeaderRow = true\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _ref3 => {\n          let {\n            tr,\n            dispatch,\n            editor\n          } = _ref3;\n          const node = createTable(editor.schema, rows, cols, withHeaderRow);\n          if (dispatch) {\n            const offset = tr.selection.anchor + 1;\n            tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset)));\n          }\n          return true;\n        };\n      },\n      addColumnBefore: () => _ref4 => {\n        let {\n          state,\n          dispatch\n        } = _ref4;\n        return addColumnBefore(state, dispatch);\n      },\n      addColumnAfter: () => _ref5 => {\n        let {\n          state,\n          dispatch\n        } = _ref5;\n        return addColumnAfter(state, dispatch);\n      },\n      deleteColumn: () => _ref6 => {\n        let {\n          state,\n          dispatch\n        } = _ref6;\n        return deleteColumn(state, dispatch);\n      },\n      addRowBefore: () => _ref7 => {\n        let {\n          state,\n          dispatch\n        } = _ref7;\n        return addRowBefore(state, dispatch);\n      },\n      addRowAfter: () => _ref8 => {\n        let {\n          state,\n          dispatch\n        } = _ref8;\n        return addRowAfter(state, dispatch);\n      },\n      deleteRow: () => _ref9 => {\n        let {\n          state,\n          dispatch\n        } = _ref9;\n        return deleteRow(state, dispatch);\n      },\n      deleteTable: () => _ref10 => {\n        let {\n          state,\n          dispatch\n        } = _ref10;\n        return deleteTable(state, dispatch);\n      },\n      mergeCells: () => _ref11 => {\n        let {\n          state,\n          dispatch\n        } = _ref11;\n        return mergeCells(state, dispatch);\n      },\n      splitCell: () => _ref12 => {\n        let {\n          state,\n          dispatch\n        } = _ref12;\n        return splitCell(state, dispatch);\n      },\n      toggleHeaderColumn: () => _ref13 => {\n        let {\n          state,\n          dispatch\n        } = _ref13;\n        return toggleHeader('column')(state, dispatch);\n      },\n      toggleHeaderRow: () => _ref14 => {\n        let {\n          state,\n          dispatch\n        } = _ref14;\n        return toggleHeader('row')(state, dispatch);\n      },\n      toggleHeaderCell: () => _ref15 => {\n        let {\n          state,\n          dispatch\n        } = _ref15;\n        return toggleHeaderCell(state, dispatch);\n      },\n      mergeOrSplit: () => _ref16 => {\n        let {\n          state,\n          dispatch\n        } = _ref16;\n        if (mergeCells(state, dispatch)) {\n          return true;\n        }\n        return splitCell(state, dispatch);\n      },\n      setCellAttribute: (name, value) => _ref17 => {\n        let {\n          state,\n          dispatch\n        } = _ref17;\n        return setCellAttr(name, value)(state, dispatch);\n      },\n      goToNextCell: () => _ref18 => {\n        let {\n          state,\n          dispatch\n        } = _ref18;\n        return goToNextCell(1)(state, dispatch);\n      },\n      goToPreviousCell: () => _ref19 => {\n        let {\n          state,\n          dispatch\n        } = _ref19;\n        return goToNextCell(-1)(state, dispatch);\n      },\n      fixTables: () => _ref20 => {\n        let {\n          state,\n          dispatch\n        } = _ref20;\n        if (dispatch) {\n          fixTables(state);\n        }\n        return true;\n      },\n      setCellSelection: position => _ref21 => {\n        let {\n          tr,\n          dispatch\n        } = _ref21;\n        if (dispatch) {\n          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\n          // @ts-ignore\n          tr.setSelection(selection);\n        }\n        return true;\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true;\n        }\n        if (!this.editor.can().addRowAfter()) {\n          return false;\n        }\n        return this.editor.chain().addRowAfter().goToNextCell().run();\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected\n    };\n  },\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable;\n    return [...(isResizable ? [columnResizing({\n      handleWidth: this.options.handleWidth,\n      cellMinWidth: this.options.cellMinWidth,\n      // @ts-ignore (incorrect type)\n      View: this.options.View,\n      // TODO: PR for @types/prosemirror-tables\n      // @ts-ignore (incorrect type)\n      lastColumnResizable: this.options.lastColumnResizable\n    })] : []), tableEditing({\n      allowTableNodeSelection: this.options.allowTableNodeSelection\n    })];\n  },\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context))\n    };\n  }\n});\nexport { Table, createTable, Table as default };","map":{"version":3,"names":["updateColumns","node","colgroup","table","cellMinWidth","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","firstChild","row","i","col","childCount","colspan","colwidth","child","attrs","j","hasWidth","cssWidth","appendChild","document","createElement","style","width","nextSibling","after","parentNode","removeChild","minWidth","TableView","constructor","dom","className","contentDOM","update","type","ignoreMutation","mutation","target","contains","createCell","cellType","cellContent","createChecked","createAndFill","getTableNodeTypes","schema","cached","tableNodeTypes","roles","Object","keys","nodes","forEach","nodeType","spec","tableRole","createTable","rowsCount","colsCount","withHeaderRow","types","headerCells","cells","index","cell","push","headerCell","header_cell","rows","isCellSelection","value","CellSelection","deleteTableWhenAllCellsSelected","_ref","editor","selection","state","cellCount","findParentNodeClosestToPos","ranges","$from","name","descendants","includes","allCellsSelected","length","commands","deleteTable","Table","Node","create","addOptions","HTMLAttributes","resizable","handleWidth","View","lastColumnResizable","allowTableNodeSelection","content","isolating","group","parseHTML","tag","renderHTML","_ref2","mergeAttributes","options","addCommands","insertTable","cols","arguments","undefined","_ref3","tr","dispatch","offset","anchor","replaceSelectionWith","scrollIntoView","setSelection","TextSelection","near","doc","resolve","addColumnBefore","_ref4","addColumnAfter","_ref5","deleteColumn","_ref6","addRowBefore","_ref7","addRowAfter","_ref8","deleteRow","_ref9","_ref10","mergeCells","_ref11","splitCell","_ref12","toggleHeaderColumn","_ref13","toggleHeader","toggleHeaderRow","_ref14","toggleHeaderCell","_ref15","mergeOrSplit","_ref16","setCellAttribute","_ref17","setCellAttr","goToNextCell","_ref18","goToPreviousCell","_ref19","fixTables","_ref20","setCellSelection","position","_ref21","anchorCell","headCell","addKeyboardShortcuts","Tab","can","chain","run","Shift-Tab","Backspace","Delete","addProseMirrorPlugins","isResizable","isEditable","columnResizing","tableEditing","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField"],"sources":["C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\TableView.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\utilities\\createCell.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\utilities\\getTableNodeTypes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\utilities\\createTable.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\utilities\\isCellSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\utilities\\deleteTableWhenAllCellsSelected.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-table\\src\\table.ts"],"sourcesContent":["// @ts-nocheck\nimport { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeView } from '@tiptap/pm/view'\n\nexport function updateColumns(\n  node: ProseMirrorNode,\n  colgroup: Element,\n  table: Element,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: any,\n) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j]\n      const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth\n      } else {\n        if (nextDOM.style.width !== cssWidth) {\n          nextDOM.style.width = cssWidth\n        }\n\n        nextDOM = nextDOM.nextSibling\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: Element\n\n  table: Element\n\n  colgroup: Element\n\n  contentDOM: Element\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    return (\n      mutation.type === 'attributes'\n      && (mutation.target === this.table || this.colgroup.contains(mutation.target))\n    )\n  }\n}\n","import { Fragment, Node as ProsemirrorNode, NodeType } from '@tiptap/pm/model'\n\nexport function createCell(\n  cellType: NodeType,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n","import { Fragment, Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\n\nimport { createCell } from './createCell.js'\nimport { getTableNodeTypes } from './getTableNodeTypes.js'\n\nexport function createTable(\n  schema: Schema,\n  rowsCount: number,\n  colsCount: number,\n  withHeaderRow: boolean,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n","import { CellSelection } from '@tiptap/pm/tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n","import { findParentNodeClosestToPos, KeyboardShortcutCommand } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection.js'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n","import {\n  callOrReturn, getExtensionField, mergeAttributes, Node, ParentConfig,\n} from '@tiptap/core'\nimport { TextSelection } from '@tiptap/pm/state'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@tiptap/pm/tables'\nimport { NodeView } from '@tiptap/pm/view'\n\nimport { TableView } from './TableView.js'\nimport { createTable } from './utilities/createTable.js'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected.js'\n\nexport interface TableOptions {\n  HTMLAttributes: Record<string, any>\n  resizable: boolean\n  handleWidth: number\n  cellMinWidth: number\n  View: NodeView\n  lastColumnResizable: boolean\n  allowTableNodeSelection: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      insertTable: (options?: {\n        rows?: number\n        cols?: number\n        withHeaderRow?: boolean\n      }) => ReturnType\n      addColumnBefore: () => ReturnType\n      addColumnAfter: () => ReturnType\n      deleteColumn: () => ReturnType\n      addRowBefore: () => ReturnType\n      addRowAfter: () => ReturnType\n      deleteRow: () => ReturnType\n      deleteTable: () => ReturnType\n      mergeCells: () => ReturnType\n      splitCell: () => ReturnType\n      toggleHeaderColumn: () => ReturnType\n      toggleHeaderRow: () => ReturnType\n      toggleHeaderCell: () => ReturnType\n      mergeOrSplit: () => ReturnType\n      setCellAttribute: (name: string, value: any) => ReturnType\n      goToNextCell: () => ReturnType\n      goToPreviousCell: () => ReturnType\n      fixTables: () => ReturnType\n      setCellSelection: (position: { anchorCell: number; headCell?: number }) => ReturnType\n    }\n  }\n\n  interface NodeConfig<Options, Storage> {\n    /**\n     * Table Role\n     */\n    tableRole?:\n      | string\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options>>['tableRole']\n        }) => string)\n  }\n}\n\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'table' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]]\n  },\n\n  addCommands() {\n    return {\n      insertTable:\n        ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n          const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n          if (dispatch) {\n            const offset = tr.selection.anchor + 1\n\n            tr.replaceSelectionWith(node)\n              .scrollIntoView()\n              .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n          }\n\n          return true\n        },\n      addColumnBefore:\n        () => ({ state, dispatch }) => {\n          return addColumnBefore(state, dispatch)\n        },\n      addColumnAfter:\n        () => ({ state, dispatch }) => {\n          return addColumnAfter(state, dispatch)\n        },\n      deleteColumn:\n        () => ({ state, dispatch }) => {\n          return deleteColumn(state, dispatch)\n        },\n      addRowBefore:\n        () => ({ state, dispatch }) => {\n          return addRowBefore(state, dispatch)\n        },\n      addRowAfter:\n        () => ({ state, dispatch }) => {\n          return addRowAfter(state, dispatch)\n        },\n      deleteRow:\n        () => ({ state, dispatch }) => {\n          return deleteRow(state, dispatch)\n        },\n      deleteTable:\n        () => ({ state, dispatch }) => {\n          return deleteTable(state, dispatch)\n        },\n      mergeCells:\n        () => ({ state, dispatch }) => {\n          return mergeCells(state, dispatch)\n        },\n      splitCell:\n        () => ({ state, dispatch }) => {\n          return splitCell(state, dispatch)\n        },\n      toggleHeaderColumn:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('column')(state, dispatch)\n        },\n      toggleHeaderRow:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('row')(state, dispatch)\n        },\n      toggleHeaderCell:\n        () => ({ state, dispatch }) => {\n          return toggleHeaderCell(state, dispatch)\n        },\n      mergeOrSplit:\n        () => ({ state, dispatch }) => {\n          if (mergeCells(state, dispatch)) {\n            return true\n          }\n\n          return splitCell(state, dispatch)\n        },\n      setCellAttribute:\n        (name, value) => ({ state, dispatch }) => {\n          return setCellAttr(name, value)(state, dispatch)\n        },\n      goToNextCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(1)(state, dispatch)\n        },\n      goToPreviousCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(-1)(state, dispatch)\n        },\n      fixTables:\n        () => ({ state, dispatch }) => {\n          if (dispatch) {\n            fixTables(state)\n          }\n\n          return true\n        },\n      setCellSelection:\n        position => ({ tr, dispatch }) => {\n          if (dispatch) {\n            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n            // @ts-ignore\n            tr.setSelection(selection)\n          }\n\n          return true\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor.chain().addRowAfter().goToNextCell().run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable\n        ? [\n          columnResizing({\n            handleWidth: this.options.handleWidth,\n            cellMinWidth: this.options.cellMinWidth,\n            // @ts-ignore (incorrect type)\n            View: this.options.View,\n            // TODO: PR for @types/prosemirror-tables\n            // @ts-ignore (incorrect type)\n            lastColumnResizable: this.options.lastColumnResizable,\n          }),\n        ]\n        : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}