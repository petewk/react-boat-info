{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/history */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState.clone(historyStateEntry.undoSelection), {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = _ref => {\n    let {\n      editorState,\n      prevEditorState,\n      dirtyLeaves,\n      dirtyElements,\n      tags\n    } = _ref;\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current,\n          undoSelection: prevEditorState.read(lexical.$getSelection)\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;","map":{"version":3,"names":["utils","require","lexical","HISTORY_MERGE","HISTORY_PUSH","DISCARD_HISTORY_CANDIDATE","OTHER","COMPOSING_CHARACTER","INSERT_CHARACTER_AFTER_SELECTION","DELETE_CHARACTER_BEFORE_SELECTION","DELETE_CHARACTER_AFTER_SELECTION","getDirtyNodes","editorState","dirtyLeaves","dirtyElements","nodeMap","_nodeMap","nodes","dirtyLeafKey","dirtyLeaf","get","undefined","push","dirtyElementKey","intentionallyMarkedAsDirty","dirtyElement","$isRootNode","getChangeType","prevEditorState","nextEditorState","dirtyLeavesSet","dirtyElementsSet","isComposing","size","nextSelection","_selection","prevSelection","$isRangeSelection","isCollapsed","dirtyNodes","length","nextNodeMap","nextAnchorNode","anchor","key","prevAnchorNode","has","__key","$isTextNode","__text","offset","nextDirtyNode","prevDirtyNode","__mode","prevText","nextText","nextAnchor","prevAnchor","type","nextAnchorOffset","prevAnchorOffset","textDiff","isTextNodeUnchanged","prevNode","nextNode","isDeletingLine","focus","__type","__detail","__style","__format","__parent","createMergeActionGetter","editor","delay","prevChangeTime","Date","now","prevChangeType","currentHistoryEntry","tags","changeTime","changeType","mergeAction","isSameEditor","shouldPushHistory","shouldMergeHistory","selection","hasDirtyNodes","Array","from","redo","historyState","redoStack","undoStack","current","dispatchCommand","CAN_UNDO_COMMAND","historyStateEntry","pop","CAN_REDO_COMMAND","setEditorState","tag","undo","undoStackLength","clone","undoSelection","clearHistory","registerHistory","getMergeAction","applyChange","currentEditorState","read","$getSelection","unregisterCommandListener","mergeRegister","registerCommand","UNDO_COMMAND","COMMAND_PRIORITY_EDITOR","REDO_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","registerUpdateListener","unregisterUpdateListener","createEmptyHistoryState","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/history/LexicalHistory.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/history */\r\nconst HISTORY_MERGE = 0;\r\nconst HISTORY_PUSH = 1;\r\nconst DISCARD_HISTORY_CANDIDATE = 2;\r\nconst OTHER = 0;\r\nconst COMPOSING_CHARACTER = 1;\r\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\r\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\r\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\r\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\r\n  const nodeMap = editorState._nodeMap;\r\n  const nodes = [];\r\n  for (const dirtyLeafKey of dirtyLeaves) {\r\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\r\n    if (dirtyLeaf !== undefined) {\r\n      nodes.push(dirtyLeaf);\r\n    }\r\n  }\r\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\r\n    if (!intentionallyMarkedAsDirty) {\r\n      continue;\r\n    }\r\n    const dirtyElement = nodeMap.get(dirtyElementKey);\r\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\r\n      nodes.push(dirtyElement);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\r\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\r\n    return OTHER;\r\n  }\r\n  const nextSelection = nextEditorState._selection;\r\n  const prevSelection = prevEditorState._selection;\r\n  if (isComposing) {\r\n    return COMPOSING_CHARACTER;\r\n  }\r\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\r\n    return OTHER;\r\n  }\r\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\r\n  if (dirtyNodes.length === 0) {\r\n    return OTHER;\r\n  }\r\n\r\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\r\n  // or after existing node.\r\n  if (dirtyNodes.length > 1) {\r\n    const nextNodeMap = nextEditorState._nodeMap;\r\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\r\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\r\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\r\n      return INSERT_CHARACTER_AFTER_SELECTION;\r\n    }\r\n    return OTHER;\r\n  }\r\n  const nextDirtyNode = dirtyNodes[0];\r\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\r\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\r\n    return OTHER;\r\n  }\r\n  const prevText = prevDirtyNode.__text;\r\n  const nextText = nextDirtyNode.__text;\r\n  if (prevText === nextText) {\r\n    return OTHER;\r\n  }\r\n  const nextAnchor = nextSelection.anchor;\r\n  const prevAnchor = prevSelection.anchor;\r\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\r\n    return OTHER;\r\n  }\r\n  const nextAnchorOffset = nextAnchor.offset;\r\n  const prevAnchorOffset = prevAnchor.offset;\r\n  const textDiff = nextText.length - prevText.length;\r\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\r\n    return INSERT_CHARACTER_AFTER_SELECTION;\r\n  }\r\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\r\n    return DELETE_CHARACTER_BEFORE_SELECTION;\r\n  }\r\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\r\n    return DELETE_CHARACTER_AFTER_SELECTION;\r\n  }\r\n  return OTHER;\r\n}\r\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\r\n  const prevNode = prevEditorState._nodeMap.get(key);\r\n  const nextNode = nextEditorState._nodeMap.get(key);\r\n  const prevSelection = prevEditorState._selection;\r\n  const nextSelection = nextEditorState._selection;\r\n  let isDeletingLine = false;\r\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\r\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\r\n  }\r\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\r\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\r\n  }\r\n  return false;\r\n}\r\nfunction createMergeActionGetter(editor, delay) {\r\n  let prevChangeTime = Date.now();\r\n  let prevChangeType = OTHER;\r\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\r\n    const changeTime = Date.now();\r\n\r\n    // If applying changes from history stack there's no need\r\n    // to run history logic again, as history entries already calculated\r\n    if (tags.has('historic')) {\r\n      prevChangeType = OTHER;\r\n      prevChangeTime = changeTime;\r\n      return DISCARD_HISTORY_CANDIDATE;\r\n    }\r\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\r\n    const mergeAction = (() => {\r\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\r\n      const shouldPushHistory = tags.has('history-push');\r\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\r\n      if (shouldMergeHistory) {\r\n        return HISTORY_MERGE;\r\n      }\r\n      if (prevEditorState === null) {\r\n        return HISTORY_PUSH;\r\n      }\r\n      const selection = nextEditorState._selection;\r\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\r\n      if (!hasDirtyNodes) {\r\n        if (selection !== null) {\r\n          return HISTORY_MERGE;\r\n        }\r\n        return DISCARD_HISTORY_CANDIDATE;\r\n      }\r\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\r\n        return HISTORY_MERGE;\r\n      }\r\n\r\n      // A single node might have been marked as dirty, but not have changed\r\n      // due to some node transform reverting the change.\r\n      if (dirtyLeaves.size === 1) {\r\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\r\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\r\n          return HISTORY_MERGE;\r\n        }\r\n      }\r\n      return HISTORY_PUSH;\r\n    })();\r\n    prevChangeTime = changeTime;\r\n    prevChangeType = changeType;\r\n    return mergeAction;\r\n  };\r\n}\r\nfunction redo(editor, historyState) {\r\n  const redoStack = historyState.redoStack;\r\n  const undoStack = historyState.undoStack;\r\n  if (redoStack.length !== 0) {\r\n    const current = historyState.current;\r\n    if (current !== null) {\r\n      undoStack.push(current);\r\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\r\n    }\r\n    const historyStateEntry = redoStack.pop();\r\n    if (redoStack.length === 0) {\r\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\r\n    }\r\n    historyState.current = historyStateEntry || null;\r\n    if (historyStateEntry) {\r\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\r\n        tag: 'historic'\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction undo(editor, historyState) {\r\n  const redoStack = historyState.redoStack;\r\n  const undoStack = historyState.undoStack;\r\n  const undoStackLength = undoStack.length;\r\n  if (undoStackLength !== 0) {\r\n    const current = historyState.current;\r\n    const historyStateEntry = undoStack.pop();\r\n    if (current !== null) {\r\n      redoStack.push(current);\r\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\r\n    }\r\n    if (undoStack.length === 0) {\r\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\r\n    }\r\n    historyState.current = historyStateEntry || null;\r\n    if (historyStateEntry) {\r\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState.clone(historyStateEntry.undoSelection), {\r\n        tag: 'historic'\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction clearHistory(historyState) {\r\n  historyState.undoStack = [];\r\n  historyState.redoStack = [];\r\n  historyState.current = null;\r\n}\r\nfunction registerHistory(editor, historyState, delay) {\r\n  const getMergeAction = createMergeActionGetter(editor, delay);\r\n  const applyChange = ({\r\n    editorState,\r\n    prevEditorState,\r\n    dirtyLeaves,\r\n    dirtyElements,\r\n    tags\r\n  }) => {\r\n    const current = historyState.current;\r\n    const redoStack = historyState.redoStack;\r\n    const undoStack = historyState.undoStack;\r\n    const currentEditorState = current === null ? null : current.editorState;\r\n    if (current !== null && editorState === currentEditorState) {\r\n      return;\r\n    }\r\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\r\n    if (mergeAction === HISTORY_PUSH) {\r\n      if (redoStack.length !== 0) {\r\n        historyState.redoStack = [];\r\n      }\r\n      if (current !== null) {\r\n        undoStack.push({\r\n          ...current,\r\n          undoSelection: prevEditorState.read(lexical.$getSelection)\r\n        });\r\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\r\n      }\r\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\r\n      return;\r\n    }\r\n\r\n    // Else we merge\r\n    historyState.current = {\r\n      editor,\r\n      editorState\r\n    };\r\n  };\r\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\r\n    undo(editor, historyState);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\r\n    redo(editor, historyState);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\r\n    clearHistory(historyState);\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\r\n    clearHistory(historyState);\r\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\r\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\r\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\r\n  return () => {\r\n    unregisterCommandListener();\r\n    unregisterUpdateListener();\r\n  };\r\n}\r\nfunction createEmptyHistoryState() {\r\n  return {\r\n    current: null,\r\n    redoStack: [],\r\n    undoStack: []\r\n  };\r\n}\r\n\r\nexports.createEmptyHistoryState = createEmptyHistoryState;\r\nexports.registerHistory = registerHistory;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}