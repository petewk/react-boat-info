{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  };\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      if (node.canContainTabs()) {\n        const hasTabCharacter = textContent.includes('\\t');\n\n        // At present, this condition is primarily used for code highlights when\n        // grouped together in lines (divs). If a code highlight includes a tab,\n        // the newly typed character may be missing from the DOM's textContent.\n\n        // Let's take an example. If a LinedCodeNode looked roughly like this:\n        // <code><div><codeHighlight /><codeHighlight /></div></code>,\n        // the following could occur when using tabs:\n\n        // a. /tconst --type--> 'd' at offset 1 --get--> /tconst\n        //    - Missing 'd'\n        // b. /tconst --type--> 'd' at offset 3 --get--> /tcondst\n        //    --type--> 'd' at offset 3 --get--> /tcondst\n        //    - Missing second 'd'\n\n        // In these cases, we can fix the problem by manually inserting the\n        // newly typed character where we know it should have been.\n\n        if (data && data.length > 0 && hasTabCharacter) {\n          const selectionOffset = data.length;\n          const insertionOffset = anchorOffset + selectionOffset - 1;\n          const beforeInsertion = textContent.slice(0, insertionOffset);\n          const afterInsertion = textContent.slice(insertionOffset, textContent.length);\n          textContent = `${beforeInsertion}${data}${afterInsertion}`;\n          anchorOffset += selectionOffset;\n          focusOffset += selectionOffset;\n        }\n      }\n\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start, and we need\n      // to clear this input from occurring as that action wasn't\n      // permitted.\n      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesTheme[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (offset !== 0) {\n    {\n      throw Error(`TODO`);\n    }\n  }\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' ');\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    if (child !== undefined && child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMap.delete(childKey);\n    }\n    child = child.isAttached() ? child.getNextSibling() : null;\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);\n        }\n\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMap.delete(nodeKey);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '20px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' ');\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (domSelection && anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n        domSelection.removeAllRanges();\n        selection.dirty = true;\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction $applyTargetRange(selection, event) {\n  if (event.getTargetRanges) {\n    const targetRange = event.getTargetRanges()[0];\n    if (targetRange) {\n      selection.applyDOMRange(targetRange);\n    }\n  }\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {\n      $applyTargetRange(selection, event);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Some browsers do not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          if (isInsertLineBreak) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      }\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered++;\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--;\n\n    // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes, selectStart);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n    return true;\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  }\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!(anchorCellNode !== null)) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!(focusCellNode !== null)) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const nodesSet = new Set();\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY\n    } = this.getShape();\n    const gridNode = $getNodeByKey(this.gridKey);\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      {\n        throw Error(`getNodes: expected to find GridNode`);\n      }\n    }\n    nodesSet.add(gridNode);\n    const gridRowNodes = gridNode.getChildren();\n    for (let r = fromY; r <= toY; r++) {\n      const gridRowNode = gridRowNodes[r];\n      nodesSet.add(gridRowNode);\n      if (!DEPRECATED_$isGridRowNode(gridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n      const gridCellNodes = gridRowNode.getChildren();\n      for (let c = fromX; c <= toX; c++) {\n        const gridCellNode = gridCellNodes[c];\n        if (!DEPRECATED_$isGridCellNode(gridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n        nodesSet.add(gridCellNode);\n        const children = gridCellNode.getChildren();\n        while (children.length > 0) {\n          const child = children.shift();\n          nodesSet.add(child);\n          if ($isElementNode(child)) {\n            children.unshift(...child.getChildren());\n          }\n        }\n      }\n    }\n    const nodes = Array.from(nodesSet);\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = anchor.getNode();\n    let lastNode = focus.getNode();\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(anchor.offset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(focus.offset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(focus.offset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  insertRawText(text) {\n    const parts = text.split(/\\r?\\n/);\n    if (parts.length === 1) {\n      this.insertText(text);\n    } else {\n      const nodes = [];\n      const length = parts.length;\n      for (let i = 0; i < length; i++) {\n        const part = parts[i];\n        if (part !== '') {\n          nodes.push($createTextNode(part));\n        }\n        if (i !== length - 1) {\n          nodes.push($createLineBreakNode());\n        }\n      }\n      this.insertNodes(nodes);\n    }\n  }\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  removeText() {\n    this.insertText('');\n  }\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText();\n\n      // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n    const siblings = [];\n\n    // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null;\n\n    // Time to insert the nodes!\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          }\n          // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n          const firstDescendant = node.getFirstDescendant();\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n            const children = element.getChildren();\n            const childrenLength = children.length;\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n              target = target.getParentOrThrow();\n            }\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n      didReplaceOrMerge = false;\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          target = target.insertAfter(node, false);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node;\n        // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow();\n        // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n        target = nextTarget;\n        // Re-try again with the target being the parent\n        i--;\n        continue;\n      }\n    }\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && (\n          // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          }\n          // Check if the prev parent is empty, as it might need\n          // removing.\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n    return true;\n  }\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n        return;\n      }\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n    const nodesToMoveLength = nodesToMove.length;\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n      return;\n    }\n    const newElement = currentElement.insertNewAfter(this, false);\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow();\n      // For inline elements, we append the siblings to the parent.\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n          firstChild = nodeToMove;\n        }\n      }\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  deleteCharacter(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n      if (!isBackward && (\n      // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {\n          return;\n        }\n      }\n      // Handle the deletion around decorators.\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n        }\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    const wasCollapsed = this.isCollapsed();\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      }\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // @ts-expect-error Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset) {\n  let times = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n    return;\n  }\n  // Multiple nodes selected. We shift or redimension selection\n  const isBackward = selection.isBackward();\n  const firstPoint = isBackward ? focus : anchor;\n  const firstPointNode = firstPoint.getNode();\n  const lastPoint = isBackward ? anchor : focus;\n  const lastPointNode = lastPoint.getNode();\n  if (parentNode.is(firstPointNode)) {\n    const firstPointOffset = firstPoint.offset;\n    if (nodeOffset <= firstPointOffset) {\n      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n    }\n  }\n  if (parentNode.is(lastPointNode)) {\n    const lastPointOffset = lastPoint.offset;\n    if (nodeOffset <= lastPointOffset) {\n      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    // When updating more than 1000 nodes on Chrome, it's actually better to defer\n    // updating the selection till the next frame. This is because Chrome's\n    // Blink engine has hard limit on how many DOM nodes it can redraw in\n    // a single cycle, so keeping it to the next frame improves performance.\n    // The downside is that is makes the computation within Lexical more\n    // complex, as now, we've sync update the DOM, but selection no longer\n    // matches.\n    if (IS_CHROME && nodeCount > 1000) {\n      window.requestAnimationFrame(() => domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset));\n    } else {\n      domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n    }\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      // @ts-ignore Text nodes do have getBoundingClientRect\n      const selectionRect = selectionTarget.getBoundingClientRect();\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  const nodeCount = pendingEditorState._nodeMap.size;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement, nodeCount);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, tags, dirtyLeaves);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, updateTags, dirtyLeaves) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (var _len = arguments.length, payload = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      payload[_key - 3] = arguments[_key];\n    }\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const windowObj = editor._window;\n  const windowEvent = windowObj !== null ? window.event : null;\n  const eventType = windowEvent != null ? windowEvent.type : null;\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor) || editor._blockCursorElement !== null && eventType === 'blur';\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type,\n        // @ts-expect-error\n        this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  getType() {\n    return this.__type;\n  }\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n  isBefore(targetNode) {\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    // @ts-expect-error\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  getTextContent() {\n    return '';\n  }\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /*\n   * This method is called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  // Setters and mutators\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n  insertAfter(nodeToInsert) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n  insertBefore(nodeToInsert) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n  isParentRequired() {\n    return false;\n  }\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  // Proxy to mark something as dirty\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    }\n    // Decorator or LineBreak\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    }\n    // Decorator or LineBreak\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n    return this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append() {\n    for (var _len2 = arguments.length, nodesToAppend = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodesToAppend[_key2] = arguments[_key2];\n    }\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canInsertTab() {\n    return false;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  canExtractContents() {\n    return true;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...arguments);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  const serializedChildren = serializedNode.children;\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement;\n        // If the <br> is the only child, then skip including it\n        if (parentElement != null && parentElement.firstChild === node && parentElement.lastChild === node) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  // View\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      br: () => ({\n        conversion: convertLineBreakToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (element !== null) {\n      if (this.hasFormat('bold')) {\n        element = wrapElementWith(element, 'b');\n      }\n      if (this.hasFormat('italic')) {\n        element = wrapElementWith(element, 'i');\n      }\n      if (this.hasFormat('strikethrough')) {\n        element = wrapElementWith(element, 's');\n      }\n      if (this.hasFormat('underline')) {\n        element = wrapElementWith(element, 'u');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  canContainTabs() {\n    return false;\n  }\n  splitText() {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    for (var _len3 = arguments.length, splitOffsets = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      splitOffsets[_key3] = arguments[_key3];\n    }\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = span.style.fontWeight === '700';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through';\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = span.style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline';\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertLineBreakToElement() {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertTextDOMNode(domNode, _parent, preformatted) {\n  let textContent = domNode.textContent || '';\n  if (!preformatted && /\\n/.test(textContent)) {\n    textContent = textContent.replace(/\\r?\\n/gm, ' ');\n    if (textContent.trim().length === 0) {\n      return {\n        node: null\n      };\n    }\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode() {\n  let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM();\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      }\n      // Ensure custom nodes implement required methods.\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms: new Set()\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    // We don't actually make use of the `editable` argument above.\n    // Doing so, causes e2e tests around the lock to fail.\n    this._editable = true;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  hasNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const klass = nodes[i];\n      const type = klass.getType();\n      if (!this._nodes.has(type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  getDecorators() {\n    return this._decorators;\n  }\n  getRootElement() {\n    return this._rootElement;\n  }\n  getKey() {\n    return this._key;\n  }\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  getEditorState() {\n    return this._editorState;\n  }\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  focus(callbackFn) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        }\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  isEditable() {\n    return this._editable;\n  }\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colSpan: this.__colSpan\n    };\n  }\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$insertNodes = $insertNodes;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;","map":{"version":3,"names":["createCommand","type","SELECTION_CHANGE_COMMAND","CLICK_COMMAND","DELETE_CHARACTER_COMMAND","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","PASTE_COMMAND","REMOVE_TEXT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","FORMAT_TEXT_COMMAND","UNDO_COMMAND","REDO_COMMAND","KEY_DOWN_COMMAND","KEY_ARROW_RIGHT_COMMAND","MOVE_TO_END","KEY_ARROW_LEFT_COMMAND","MOVE_TO_START","KEY_ARROW_UP_COMMAND","KEY_ARROW_DOWN_COMMAND","KEY_ENTER_COMMAND","KEY_SPACE_COMMAND","KEY_BACKSPACE_COMMAND","KEY_ESCAPE_COMMAND","KEY_DELETE_COMMAND","KEY_TAB_COMMAND","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","DROP_COMMAND","FORMAT_ELEMENT_COMMAND","DRAGSTART_COMMAND","DRAGOVER_COMMAND","DRAGEND_COMMAND","COPY_COMMAND","CUT_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","FOCUS_COMMAND","BLUR_COMMAND","KEY_MODIFIER_COMMAND","CAN_USE_DOM","window","document","createElement","documentMode","IS_APPLE","test","navigator","platform","IS_FIREFOX","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_ALL_FORMATTING","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","NON_BREAKING_SPACE","ZERO_WIDTH_SPACE","COMPOSITION_SUFFIX","DOUBLE_LINE_BREAK","COMPOSITION_START_CHAR","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","code","highlight","italic","strikethrough","subscript","superscript","underline","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE","TEXT_MUTATION_VARIANCE","isProcessingMutations","lastTextEntryTimeStamp","getIsProcesssingMutations","updateTimeStamp","event","timeStamp","initTextEntryListener","editor","getWindow","addEventListener","isManagedLineBreak","dom","target","__lexicalLineBreak","_key","undefined","getLastSelection","getEditorState","read","selection","$getSelection","clone","handleTextMutation","node","domSelection","getDOMSelection","_window","anchorOffset","focusOffset","anchorNode","text","nodeValue","$updateTextNodeFromDOMContent","shouldUpdateTextNodeFromMutation","targetDOM","targetNode","$isRangeSelection","anchor","getNode","is","format","getFormat","nodeType","isAttached","$flushMutations$1","mutations","observer","shouldFlushTextMutations","performance","now","updateEditor","badDOMTargets","Map","rootElement","getRootElement","currentEditorState","_editorState","blockCursorElement","_blockCursorElement","shouldRevertSelection","possibleTextForFirefoxPaste","i","length","mutation","$getNearestNodeFromDOMNode","$isDecoratorNode","$isTextNode","addedDOMs","addedNodes","s","addedDOM","getNodeFromDOMNode","parentDOM","parentNode","nodeName","possibleText","innerText","removeChild","removedDOMs","removedNodes","removedDOMsLength","unremovedBRs","removedDOM","appendChild","internalGetRoot","set","size","$isElementNode","childKeys","getChildrenKeys","currentDOM","firstChild","key","correctDOM","getElementByKey","replaceChild","nextSibling","markDirty","records","takeRecords","record","dirty","$setSelection","isFirefoxClipboardEvents","insertRawText","flushRootMutations","_observer","initMutationObserver","MutationObserver","keyCounter","generateRandomKey","getRegisteredNodeOrThrow","registeredNode","_nodes","get","Error","scheduleMicroTask","queueMicrotask","fn","Promise","resolve","then","$isSelectionCapturedInDecorator","isSelectionCapturedInDecoratorInput","anchorDOM","activeElement","contentEditable","__lexicalEditor","isSelectionWithinEditor","focusDOM","contains","getNearestEditorFromDOMNode","error","currentNode","getParentElement","getTextDirection","$isTokenOrSegmented","isToken","isSegmented","isDOMNodeLexicalTextNode","getDOMTextNode","element","toggleTextFormatType","alignWithFormat","activeFormat","isStateFlagPresent","$isLeafNode","$isLineBreakNode","$setNodeKey","existingKey","__key","errorOnReadOnly","errorOnInfiniteTransforms","getActiveEditor","editorState","getActiveEditorState","_nodeMap","_dirtyElements","_dirtyLeaves","add","_cloneNotNeeded","_dirtyType","internalMarkParentElementsAsDirty","parentKey","nodeMap","dirtyElements","nextParentKey","has","__parent","removeFromParent","oldParent","getParent","writableNode","getWritable","writableParent","prevSibling","getPreviousSibling","getNextSibling","writableNextSibling","__first","__prev","writablePrevSibling","__next","__last","__size","internalMarkNodeAsDirty","latest","getLatest","parent","internalMarkSiblingsAsDirty","previousNode","nextNode","$setCompositionKey","compositionKey","previousCompositionKey","_compositionKey","$getNodeByKey","$getCompositionKey","isCurrentlyReadOnlyMode","startingDOM","cloneDecorators","currentDecorators","_decorators","pendingDecorators","Object","assign","_pendingDecorators","getEditorStateTextContent","$getRoot","getTextContent","markAllNodesAsDirty","isEmpty","_pendingEditorState","tag","isFrozen","_cachedNodes","_selection","$flushMutations","getNodeFromDOM","nodeKey","getNodeKeyFromDOM","getTextNodeOffset","moveSelectionToEnd","getTextContentSize","doesContainGrapheme","str","getEditorsToPropagate","editorsToPropagate","currentEditor","push","_parentEditor","createUID","Math","random","toString","replace","substr","getAnchorTextFromDOM","$updateSelectedTextFromDOM","isCompositionEnd","data","textContent","canContainTabs","hasTabCharacter","includes","selectionOffset","insertionOffset","beforeInsertion","slice","afterInsertion","offset","textNode","compositionEnd","isDirty","isComposing","normalizedTextContent","prevTextContent","setTimeout","update","remove","prevSelection","$getPreviousSelection","getKey","canInsertTextBefore","setTextContent","setTextNodeRange","originalTextContent","replacement","$createTextNode","$previousSiblingDoesNotAcceptText","previousSibling","isInline","canInsertTextAfter","$shouldInsertTextAfterOrBeforeTextNode","isCollapsed","getParentOrThrow","isTab","keyCode","altKey","ctrlKey","metaKey","isBold","controlOrMeta","isItalic","isUnderline","isParagraph","shiftKey","isReturn","isLineBreak","isOpenLineBreak","isDeleteWordBackward","isBackspace","isDeleteWordForward","isDelete","isDeleteLineBackward","isDeleteLineForward","isDeleteBackward","isDeleteForward","isUndo","isRedo","isCopy","isCut","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","isMoveBackward","isMoveToStart","isMoveForward","isMoveToEnd","isMoveUp","isMoveDown","isModifier","isSpace","isEscape","getCachedClassNameArray","classNamesTheme","classNameThemeType","classNames","classNamesArr","split","setMutatedNode","mutatedNodes","registeredNodes","mutationListeners","__type","klass","mutatedNodesByType","prevMutation","isMove","$nodesOfType","readOnly","_readOnly","klassType","getType","nodes","nodesOfType","resolveElement","isBackward","block","getIndexWithinParent","getChildrenSize","getChildAtIndex","$getAdjacentNode","focus","focusNode","possibleNode","inputType","dispatchCommand","command","payload","triggerCommandListeners","$textContentRequiresDoubleLinebreakAtEnd","$isRootNode","isLastChild","getElementByKeyOrThrow","_keyToDOMMap","parentElement","assignedSlot","host","scrollIntoViewIfNeeded","selectionRect","doc","ownerDocument","defaultView","top","currentTop","bottom","currentBottom","targetTop","targetBottom","isBodyElement","body","innerHeight","targetRect","getBoundingClientRect","diff","scrollBy","scrollTop","yOffset","$addUpdateTag","_updateTags","$maybeMoveChildrenSelectionToParent","$hasAncestor","child","getDefaultView","domElem","ownerDoc","windowObj","$isInlineElementOrDecoratorNode","$getNearestRootOrShadowRoot","$isRootOrShadowRoot","isShadowRoot","$copyNode","copy","constructor","$applyNodeReplacement","replaceFunc","replacementNode","errorOnInsertTextNodeOnRoot","insertNode","createBlockCursorElement","editorConfig","theme","setAttribute","blockCursorTheme","blockCursor","classList","needsBlockCursor","canBeEmpty","removeDOMBlockCursorElement","style","removeProperty","updateDOMBlockCursorElement","nextSelection","elementNode","elementNodeSize","isBlockCursor","insertBeforeElement","sibling","elementDOM","_config","caretColor","insertBefore","targetWindow","getSelection","$splitNode","startNode","recurse","isParentRoot","nodeToMove","insertAfter","leftTree","rightTree","newParent","nextSiblings","getNextSiblings","append","$garbageCollectDetachedDecorators","pendingEditorState","decorators","$garbageCollectDetachedDeepChildNodes","prevNodeMap","dirtyNodes","getFirstChild","childKey","delete","$garbageCollectDetachedNodes","prevEditorState","dirtyLeaves","$canSimpleTextNodesBeMerged","node1","node2","node1Mode","__mode","node1Format","__format","node1Style","__style","node2Mode","node2Format","node2Style","$mergeTextNodes","writableNode1","mergeWithSibling","normalizedNodes","_normalizedNodes","$normalizeTextNode","__text","isSimpleText","isUnmergeable","$normalizeSelection","$normalizePoint","point","nextOffsetAtEnd","subTreeTextContent","subTreeDirectionedTextContent","editorTextContent","activeEditorConfig","activeEditor$1","activeEditorNodes","treatAllNodesAsDirty","activeEditorStateReadOnly","activeMutationListeners","activeTextDirection","activeDirtyElements","activeDirtyLeaves","activePrevNodeMap","activeNextNodeMap","activePrevKeyToDOMMap","destroyNode","getPrevElementByKeyOrThrow","children","createChildrenArray","destroyChildren","_startIndex","endIndex","startIndex","setTextAlign","domStyle","value","setProperty","DEFAULT_INDENT_VALUE","setElementIndent","indent","indentClassName","elementHasClassName","indentationBaseValue","getComputedStyle","getPropertyValue","setElementFormat","createNode","insertDOM","createDOM","storeDOMWithKey","__indent","childrenSize","createChildrenWithDirection","reconcileElementTerminatingLineBreak","decorator","decorate","reconcileDecorator","isDirectionless","possibleLineBreak","freeze","previousSubTreeDirectionedTextContent","createChildren","reconcileBlockDirection","previousSubTreeTextContent","__lexicalTextContent","isLastChildLineBreakOrDecorator","prevElement","nextElement","prevLineBreak","nextLineBreak","previousSubTreeDirectionTextContent","__lexicalDirTextContent","previousDirection","__lexicalDir","hasEmptyDirectionedTextContent","direction","previousDirectionTheme","nextDirectionTheme","removeAttribute","dir","__dir","reconcileChildrenWithDirection","reconcileChildren","prevChildrenSize","nextChildrenSize","prevFirstChildKey","nextFrstChildKey","reconcileNode","lastDOM","replacementDOM","prevChildren","nextChildren","lexicalLineBreak","canUseFastPath","reconcileNodeChildren","prevNode","updateDOM","nextIndent","nextFormat","__cachedText","prevChildrenLength","nextChildrenLength","prevEndIndex","nextEndIndex","prevChildrenSet","nextChildrenSet","siblingDOM","prevIndex","nextIndex","prevKey","nextKey","Set","nextHasPrevKey","prevHasNextKey","childDOM","appendNewChildren","removeOldChildren","reconcileRoot","nextEditorState","dirtyType","_listeners","currentMutatedNodes","keyToDOMMap","PASS_THROUGH_COMMAND","ANDROID_COMPOSITION_LATENCY","rootElementEvents","onKeyDown","onPointerDown","onCompositionStart","onCompositionEnd","onInput","onClick","onBeforeInput","lastKeyDownTimeStamp","lastKeyCode","lastBeforeInputInsertTextTimeStamp","unprocessedBeforeInputData","rootElementsRegistered","isSelectionChangeFromDOMUpdate","isSelectionChangeFromMouseDown","isInsertLineBreak","isFirefoxEndingComposition","collapsedSelectionFormat","$shouldPreventDefaultAndInsertText","isBeforeInput","domAnchorNode","anchorKey","backingAnchorElement","textLength","getStyle","shouldSkipSelectionChange","domNode","onSelectionChange","isActive","windowEvent","currentTimeStamp","lastFormat","lastStyle","lastOffset","lastKey","combinedFormat","hasTextNodes","getNodes","nodesLength","lastSelection","getTopLevelElementOrThrow","removeAllRanges","pointerType","Node","$applyTargetRange","getTargetRanges","targetRange","applyDOMRange","$canRemoveText","isPossiblyAndroidKeyPress","preventDefault","dataTransfer","getData","stopPropagation","onCompositionEndImpl","characterData","$isNodeSelection","getRootElementRemoveHandles","eventHandles","__lexicalEventHandles","activeNestedEditorsMap","onDocumentSelectionChange","nextActiveEditor","newSelection","internalCreateRangeSelection","editors","rootEditor","rootEditorKey","activeNestedEditor","prevActiveEditor","stopLexicalPropagation","_lexicalHandled","hasStoppedLexicalPropagation","stopped","addRootElementEvents","removeHandles","eventName","onEvent","eventHandler","isEditable","removeEventListener","removeRootElementEvents","cleanActiveNestedEditorsMap","markSelectionChangeFromDOMUpdate","markCollapsedSelectionFormat","Point","isBefore","b","aNode","bNode","aOffset","bOffset","aNodeDescendant","getDescendantByIndex","bNodeDescendant","oldKey","$createPoint","selectPointOnNode","textContentLength","$moveSelectionPointToEnd","lastNode","getLastDescendant","$transferStartingElementPointToTextPoint","placementNode","$createParagraphNode","setFormat","setStyle","$setPointValues","NodeSelection","objects","a","Array","from","every","clear","extract","insertText","insertNodes","selectStart","selectedNodes","selectedNodesLength","lastSelectedNode","selectionAtEnd","select","index","cachedNodes","object","x","RangeSelection","GridSelection","gridKey","DEPRECATED_$isGridSelection","anchorCellKey","focusCellKey","getCharacterOffsets","getShape","anchorCellNode","anchorCellNodeIndex","anchorCelRoweIndex","focusCellNode","focusCellNodeIndex","focusCellRowIndex","startX","min","stopX","max","startY","stopY","fromX","fromY","toX","toY","nodesSet","gridNode","DEPRECATED_$isGridNode","gridRowNodes","getChildren","r","gridRowNode","DEPRECATED_$isGridRowNode","gridCellNodes","c","gridCellNode","DEPRECATED_$isGridCellNode","shift","unshift","firstNode","firstNodeDescendant","lastNodeDescendant","getNodesBetween","prevWasElement","range","resolvedSelectionPoints","internalResolveSelectionPoints","startContainer","startOffset","endContainer","endOffset","anchorPoint","focusPoint","toggleFormat","hasFormat","formatFlag","parts","part","$createLineBreakNode","firstPoint","endPoint","firstNodeText","firstNodeTextLength","firstNodeParent","lastIndex","lastNodeParent","normalizeSelectionPointsForBoundaries","firstNodeFormat","firstNodeStyle","splitText","delCount","spliceText","markedNodeKeysForKeep","getParentKeys","firstElement","lastElement","lastElementChild","lastNodeChildren","selectedNodesSet","firstAndLastElementsAreEqual","insertionTarget","lastNodeChild","isParentOf","lastRemovedParent","childrenLength","selectedNode","removeText","formatText","formatType","selectedTextNodes","selectedTextNodesLength","startPoint","firstIndex","firstNextFormat","getFormatFlags","splitNodes","lastNextFormat","selectionEnd","nextSiblingKey","prevSiblingKey","siblings","topLevelElement","danglingText","startingNode","didReplaceOrMerge","canReplaceWith","firstDescendant","getFirstDescendant","splitNode","splitOffset","nextTarget","lastChild","selectPrevious","selectNext","originalTarget","prevParent","$isBlockElementNode","isIsolated","canInsertAfter","prevParentClone","insertParagraph","currentElement","nodesToMove","siblingsToMove","reverse","paragraph","nodesToMoveLength","newElement","insertNewAfter","insertLineBreak","currentElementFirstChild","isBeginning","siblingsToMoveLength","siblingToMove","lineBreakNode","lastNodeText","lastNodeTextLength","pop","modify","alter","granularity","collapse","isKeyboardSelectable","nodeSelection","$createNodeSelection","elementKey","siblingKey","_rootElement","moveNativeSelection","rangeCount","getRangeAt","root","validNodes","shrinkSelection","firstValidNode","lastValidNode","selectEnd","$swapPoints","deleteCharacter","canExtractContents","textContentSize","$removeSegment","$updateCaretSelectionForUnicodeCharacter","collapseAtStart","wasCollapsed","deleteLine","deleteWord","getCharacterOffset","anchorType","characterOffset","splitLength","segmentOffset","restoreOffset","isLast","splice","nextTextContent","join","trim","shouldResolveAncestor","resolvedElement","resolvedOffset","lastPoint","internalResolveSelectionPoint","resolvedNode","childNodes","childNodesLength","hasBlockCursor","descendant","resolveSelectionPointOnBoundary","parentSibling","lastAnchor","lastFocus","resolvedAnchorPoint","resolvedFocusPoint","internalMakeRangeSelection","focusKey","focusType","$createRangeSelection","DEPRECATED_$createGridSelection","internalCreateSelection","eventType","isSelectionChange","useDOMSelection","detail","$updateElementSelectionOnCreateDeleteNode","nodeOffset","times","newSelectionOffset","$updateSelectionResolveTextNodes","firstPointNode","lastPointNode","firstPointOffset","lastPointOffset","childSize","anchorOffsetAtEnd","newOffset","focusOffsetAtEnd","applySelectionTransforms","selectionTransform","moveSelectionPointToSibling","adjustPointOffsetForMergedSibling","updateDOMSelection","tags","nodeCount","anchorDOMNode","focusDOMNode","nextAnchorOffset","nextFocusOffset","nextStyle","nextAnchorNode","nextFocusNode","anchorFormatOrStyleChanged","preventScroll","requestAnimationFrame","setBaseAndExtent","selectionTarget","$insertNodes","$getTextContent","activeEditorState","activeEditor","isReadOnlyMode","isAttemptingToRecoverFromReconcilerError","infiniteTransformCount","observerOptions","childList","subtree","internalGetActiveEditor","$applyTransforms","transformsCache","transformsArr","transforms","transformsArrLength","$isNodeValidForTransform","$normalizeAllDirtyTextNodes","$applyAllTransforms","untransformedDirtyLeaves","untransformedDirtyLeavesLength","untransformedDirtyElements","untransformedDirtyElementsLength","currentUntransformedDirtyElement","intentionallyMarkedAsDirty","$parseSerializedNode","serializedNode","internalSerializedNode","$parseSerializedNodeImpl","nodeClass","name","importJSON","isArray","serializedJSONChildNode","childNode","parseEditorState","serializedEditorState","updateFn","createEmptyEditorState","previousActiveEditorState","previousReadOnlyMode","previousActiveEditor","previousDirtyElements","previousDirtyLeaves","previousCloneNotNeeded","previousDirtyType","handleDEVOnlyPendingUpdateGuarantees","readEditorState","callbackFn","commitPendingUpdates","shouldSkipDOM","_headless","currentSelection","pendingSelection","needsUpdate","previouslyUpdating","_updating","disconnect","_onError","resetEditor","observe","deferred","_deferred","_editable","triggerMutationListeners","triggerListeners","triggerTextContentListeners","triggerDeferredUpdateCallbacks","triggerEnqueuedUpdates","currentTextContent","latestTextContent","updateTags","listeners","listenersLength","listener","isCurrentlyEnqueuingUpdates","apply","returnVal","e","commandListeners","_commands","listenerInPriorityOrder","listenersSet","j","queuedUpdates","_updates","queuedUpdate","options","beginUpdate","processNestedUpdates","initialSkipTransforms","skipTransforms","nextUpdateFn","onUpdate","discrete","editorStateWasCloned","cloneEditorState","_flushSync","startingCompositionKey","endingCompositionKey","pendingNodeMap","shouldUpdate","editorStateHasDirtySelection","removeNode","nodeToRemove","restoreSelection","preserveEmptyParent","selectionMoved","LexicalNode","_data","errorOnTypeKlassMismatch","isSelected","targetSelection","some","n","getTopLevelElement","getParents","parents","self","getPreviousSiblings","getCommonAncestor","aLength","bLength","bSet","ancestor","commonAncestor","indexA","indexB","visited","getLastChild","latestNode","cloneNotNeeded","mutableNode","__detail","_editor","_prevNode","_dom","exportDOM","exportJSON","_serializedNode","replaceWith","includeChildren","toReplaceKey","writableReplaceWith","forEach","nodeToInsert","writableSelf","writableNodeToInsert","elementAnchorSelectionOnNode","elementFocusSelectionOnNode","oldIndex","oldParentKey","insertKey","writableParentKey","isParentRequired","createParentElementNode","editorKlass","DecoratorNode","config","ElementNode","getFormatType","getIndent","parentLastChild","getAllTextNodes","textNodes","subChildrenNodes","firstKey","getFirstChildOrThrow","getLastChildOrThrow","getDirection","_anchorOffset","_focusOffset","childrenCount","nodesToAppend","setDirection","setIndent","indentLevel","deleteCount","nodesToInsert","nodesToInsertLength","oldSize","writableSelfKey","nodesToInsertKeys","nodesToRemoveKeys","nodeAfterRange","nodeBeforeRange","newSize","nodeToDelete","nodeKeyToDelete","writableNodeToDelete","nodeKeyToInsert","writablePrevNode","writableNodeAfterRange","nodesToRemoveKeySet","nodesToInsertKeySet","isPointRemoved","version","canInsertTab","canIndent","excludeFromCopy","destination","canMergeWith","extractWithChild","RootNode","cachedText","$createRootNode","current","EditorState","exportNodeToJSON","serializedChildren","serializedChildNode","toJSON","LineBreakNode","importDOM","br","conversion","convertLineBreakElement","priority","serializedLineBreakNode","getElementOuterTag","getElementInnerTag","setTextThemeClassNames","prevFormat","textClassNames","domClassList","hasUnderlineStrikethrough","prevUnderlineStrikethrough","nextUnderlineStrikethrough","flag","diffComposedText","nextText","suffix","insert","deleteData","insertData","createTextInnerDOM","innerDOM","innerTag","wrapElementWith","el","TextNode","getDetail","getMode","outerTag","cssText","prevOuterTag","nextOuterTag","prevInnerTag","nextInnerTag","prevTag","nextTag","prevInnerDOM","nextInnerDOM","prevStyle","convertTextDOMNode","convertBringAttentionToElement","convertLineBreakToElement","convertTextFormatElement","em","span","convertSpanElement","strong","sub","sup","u","setDetail","setMode","mode","toggleDirectionless","toggleUnmergeable","newText","moveSelection","handledTextLength","updatedText","splitOffsets","offsetsSet","string","partsLength","firstPart","hasReplacedSelf","textSize","partSize","nextTextSize","insertionIndex","targetKey","targetText","isTextEntity","hasBoldFontWeight","fontWeight","hasLinethroughTextDecoration","textDecoration","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","verticalAlign","forChild","lexicalNode","hasNormalFontWeight","_parent","preformatted","nodeNameToTextFormat","toLowerCase","ParagraphNode","p","convertParagraphElement","textAlign","textIndent","_","parseInt","$isParagraphNode","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","COMMAND_PRIORITY_NORMAL","COMMAND_PRIORITY_HIGH","COMMAND_PRIORITY_CRITICAL","prevRootElement","nextRootElement","keyNodeMap","initializeConversionCache","conversionCache","handledConversions","bind","map","keys","currentCache","createEditor","parentEditor","disableEvents","namespace","initialEditorState","onError","editable","replacementClass","replacementKlass","with","withKlass","proto","prototype","method","hasOwnProperty","console","warn","replaceWithKlass","LexicalEditor","htmlConversions","textcontent","_htmlConversions","registerUpdateListener","listenerSetOrMap","registerEditableListener","registerDecoratorListener","registerTextContentListener","registerRootListener","registerCommand","commandsMap","listenersInPriorityOrder","String","registerMutationListener","registerNodeTransformToKlass","registerNodeTransform","registeredReplaceWithNode","hasNodes","getDecorators","setRootElement","userSelect","whiteSpace","wordBreak","setEditorState","maybeStringifiedEditorState","JSON","parse","defaultSelection","blur","setEditable","DEPRECATED_GridCellNode","colSpan","__colSpan","DEPRECATED_GridNode","DEPRECATED_GridRowNode","exports","$normalizeSelection__EXPERIMENTAL"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/lexical/Lexical.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      if (node.canContainTabs()) {\n        const hasTabCharacter = textContent.includes('\\t');\n\n        // At present, this condition is primarily used for code highlights when\n        // grouped together in lines (divs). If a code highlight includes a tab,\n        // the newly typed character may be missing from the DOM's textContent.\n\n        // Let's take an example. If a LinedCodeNode looked roughly like this:\n        // <code><div><codeHighlight /><codeHighlight /></div></code>,\n        // the following could occur when using tabs:\n\n        // a. /tconst --type--> 'd' at offset 1 --get--> /tconst\n        //    - Missing 'd'\n        // b. /tconst --type--> 'd' at offset 3 --get--> /tcondst\n        //    --type--> 'd' at offset 3 --get--> /tcondst\n        //    - Missing second 'd'\n\n        // In these cases, we can fix the problem by manually inserting the\n        // newly typed character where we know it should have been.\n\n        if (data && data.length > 0 && hasTabCharacter) {\n          const selectionOffset = data.length;\n          const insertionOffset = anchorOffset + selectionOffset - 1;\n          const beforeInsertion = textContent.slice(0, insertionOffset);\n          const afterInsertion = textContent.slice(insertionOffset, textContent.length);\n          textContent = `${beforeInsertion}${data}${afterInsertion}`;\n          anchorOffset += selectionOffset;\n          focusOffset += selectionOffset;\n        }\n      }\n\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start, and we need\n      // to clear this input from occurring as that action wasn't\n      // permitted.\n      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesTheme[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode, offset = 0) {\n  if (offset !== 0) {\n    {\n      throw Error(`TODO`);\n    }\n  }\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' ');\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    if (child !== undefined && child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMap.delete(childKey);\n    }\n    child = child.isAttached() ? child.getNextSibling() : null;\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);\n        }\n\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMap.delete(nodeKey);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '20px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' ');\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (domSelection && anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n        domSelection.removeAllRanges();\n        selection.dirty = true;\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction $applyTargetRange(selection, event) {\n  if (event.getTargetRanges) {\n    const targetRange = event.getTargetRanges()[0];\n    if (targetRange) {\n      selection.applyDOMRange(targetRange);\n    }\n  }\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {\n      $applyTargetRange(selection, event);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Some browsers do not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          if (isInsertLineBreak) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      }\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered++;\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--;\n\n    // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes, selectStart);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n    return true;\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  }\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!(anchorCellNode !== null)) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!(focusCellNode !== null)) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const nodesSet = new Set();\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY\n    } = this.getShape();\n    const gridNode = $getNodeByKey(this.gridKey);\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      {\n        throw Error(`getNodes: expected to find GridNode`);\n      }\n    }\n    nodesSet.add(gridNode);\n    const gridRowNodes = gridNode.getChildren();\n    for (let r = fromY; r <= toY; r++) {\n      const gridRowNode = gridRowNodes[r];\n      nodesSet.add(gridRowNode);\n      if (!DEPRECATED_$isGridRowNode(gridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n      const gridCellNodes = gridRowNode.getChildren();\n      for (let c = fromX; c <= toX; c++) {\n        const gridCellNode = gridCellNodes[c];\n        if (!DEPRECATED_$isGridCellNode(gridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n        nodesSet.add(gridCellNode);\n        const children = gridCellNode.getChildren();\n        while (children.length > 0) {\n          const child = children.shift();\n          nodesSet.add(child);\n          if ($isElementNode(child)) {\n            children.unshift(...child.getChildren());\n          }\n        }\n      }\n    }\n    const nodes = Array.from(nodesSet);\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = anchor.getNode();\n    let lastNode = focus.getNode();\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(anchor.offset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(focus.offset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(focus.offset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  insertRawText(text) {\n    const parts = text.split(/\\r?\\n/);\n    if (parts.length === 1) {\n      this.insertText(text);\n    } else {\n      const nodes = [];\n      const length = parts.length;\n      for (let i = 0; i < length; i++) {\n        const part = parts[i];\n        if (part !== '') {\n          nodes.push($createTextNode(part));\n        }\n        if (i !== length - 1) {\n          nodes.push($createLineBreakNode());\n        }\n      }\n      this.insertNodes(nodes);\n    }\n  }\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  removeText() {\n    this.insertText('');\n  }\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText();\n\n      // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n    const siblings = [];\n\n    // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null;\n\n    // Time to insert the nodes!\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          }\n          // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n          const firstDescendant = node.getFirstDescendant();\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n            const children = element.getChildren();\n            const childrenLength = children.length;\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n              target = target.getParentOrThrow();\n            }\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n      didReplaceOrMerge = false;\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          target = target.insertAfter(node, false);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node;\n        // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow();\n        // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n        target = nextTarget;\n        // Re-try again with the target being the parent\n        i--;\n        continue;\n      }\n    }\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && (\n          // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          }\n          // Check if the prev parent is empty, as it might need\n          // removing.\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n    return true;\n  }\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n        return;\n      }\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n    const nodesToMoveLength = nodesToMove.length;\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n      return;\n    }\n    const newElement = currentElement.insertNewAfter(this, false);\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow();\n      // For inline elements, we append the siblings to the parent.\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n          firstChild = nodeToMove;\n        }\n      }\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  deleteCharacter(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n      if (!isBackward && (\n      // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {\n          return;\n        }\n      }\n      // Handle the deletion around decorators.\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n        }\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    const wasCollapsed = this.isCollapsed();\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      }\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // @ts-expect-error Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n    return;\n  }\n  // Multiple nodes selected. We shift or redimension selection\n  const isBackward = selection.isBackward();\n  const firstPoint = isBackward ? focus : anchor;\n  const firstPointNode = firstPoint.getNode();\n  const lastPoint = isBackward ? anchor : focus;\n  const lastPointNode = lastPoint.getNode();\n  if (parentNode.is(firstPointNode)) {\n    const firstPointOffset = firstPoint.offset;\n    if (nodeOffset <= firstPointOffset) {\n      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n    }\n  }\n  if (parentNode.is(lastPointNode)) {\n    const lastPointOffset = lastPoint.offset;\n    if (nodeOffset <= lastPointOffset) {\n      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    // When updating more than 1000 nodes on Chrome, it's actually better to defer\n    // updating the selection till the next frame. This is because Chrome's\n    // Blink engine has hard limit on how many DOM nodes it can redraw in\n    // a single cycle, so keeping it to the next frame improves performance.\n    // The downside is that is makes the computation within Lexical more\n    // complex, as now, we've sync update the DOM, but selection no longer\n    // matches.\n    if (IS_CHROME && nodeCount > 1000) {\n      window.requestAnimationFrame(() => domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset));\n    } else {\n      domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n    }\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      // @ts-ignore Text nodes do have getBoundingClientRect\n      const selectionRect = selectionTarget.getBoundingClientRect();\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  const nodeCount = pendingEditorState._nodeMap.size;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement, nodeCount);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, tags, dirtyLeaves);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, updateTags, dirtyLeaves) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const windowObj = editor._window;\n  const windowEvent = windowObj !== null ? window.event : null;\n  const eventType = windowEvent != null ? windowEvent.type : null;\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor) || editor._blockCursorElement !== null && eventType === 'blur';\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type,\n        // @ts-expect-error\n        this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  getType() {\n    return this.__type;\n  }\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n  isBefore(targetNode) {\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    // @ts-expect-error\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  getTextContent() {\n    return '';\n  }\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /*\n   * This method is called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  // Setters and mutators\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n  isParentRequired() {\n    return false;\n  }\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  // Proxy to mark something as dirty\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    }\n    // Decorator or LineBreak\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    }\n    // Decorator or LineBreak\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n    return this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canInsertTab() {\n    return false;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  canExtractContents() {\n    return true;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  const serializedChildren = serializedNode.children;\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement;\n        // If the <br> is the only child, then skip including it\n        if (parentElement != null && parentElement.firstChild === node && parentElement.lastChild === node) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  // View\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      br: () => ({\n        conversion: convertLineBreakToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (element !== null) {\n      if (this.hasFormat('bold')) {\n        element = wrapElementWith(element, 'b');\n      }\n      if (this.hasFormat('italic')) {\n        element = wrapElementWith(element, 'i');\n      }\n      if (this.hasFormat('strikethrough')) {\n        element = wrapElementWith(element, 's');\n      }\n      if (this.hasFormat('underline')) {\n        element = wrapElementWith(element, 'u');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  canContainTabs() {\n    return false;\n  }\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = span.style.fontWeight === '700';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through';\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = span.style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline';\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertLineBreakToElement() {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertTextDOMNode(domNode, _parent, preformatted) {\n  let textContent = domNode.textContent || '';\n  if (!preformatted && /\\n/.test(textContent)) {\n    textContent = textContent.replace(/\\r?\\n/gm, ' ');\n    if (textContent.trim().length === 0) {\n      return {\n        node: null\n      };\n    }\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM();\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      }\n      // Ensure custom nodes implement required methods.\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms: new Set()\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    // We don't actually make use of the `editable` argument above.\n    // Doing so, causes e2e tests around the lock to fail.\n    this._editable = true;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  hasNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const klass = nodes[i];\n      const type = klass.getType();\n      if (!this._nodes.has(type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  getDecorators() {\n    return this._decorators;\n  }\n  getRootElement() {\n    return this._rootElement;\n  }\n  getKey() {\n    return this._key;\n  }\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  getEditorState() {\n    return this._editorState;\n  }\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        }\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  isEditable() {\n    return this._editable;\n  }\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colSpan: this.__colSpan\n    };\n  }\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$insertNodes = $insertNodes;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}