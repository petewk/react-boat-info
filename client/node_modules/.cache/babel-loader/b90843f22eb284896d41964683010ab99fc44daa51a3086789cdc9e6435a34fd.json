{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from '@tiptap/pm/state';\nimport { EditorView } from '@tiptap/pm/view';\nimport { keymap } from '@tiptap/pm/keymap';\nimport { Schema, Fragment, DOMParser, DOMSerializer, Node as Node$1, Slice } from '@tiptap/pm/model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, joinPoint, Transform, canSplit, canJoin, findWrapping } from '@tiptap/pm/transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinUp as joinUp$1, joinDown as joinDown$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from '@tiptap/pm/commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from '@tiptap/pm/schema-list';\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    var _this = this;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(_ref => {\n      let [name, command] = _ref;\n      const method = function () {\n        const callback = command(...arguments)(props);\n        if (!tr.getMeta('preventDispatch') && !_this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr) {\n    var _this2 = this;\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every(callback => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(_ref2 => {\n        let [name, command] = _ref2;\n        const chainedCommand = function () {\n          const props = _this2.buildProps(tr, shouldDispatch);\n          const callback = command(...arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(_ref3 => {\n      let [name, command] = _ref3;\n      return [name, function () {\n        return command(...arguments)({\n          ...props,\n          dispatch: undefined\n        });\n      }];\n    }));\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr) {\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(_ref4 => {\n          let [name, command] = _ref4;\n          return [name, function () {\n            return command(...arguments)(props);\n          }];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(_ref5 => {\n          let [name, attribute] = _ref5;\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n    if (!addAttributes) {\n      return;\n    }\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(_ref6 => {\n      let [name, attribute] = _ref6;\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes() {\n  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = {\n      ...items\n    };\n    Object.entries(item).forEach(_ref7 => {\n      let [key, value] = _ref7;\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === 'class') {\n        const valueClasses = value ? value.split(' ') : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\n        const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\nfunction callOrReturn(value) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (isFunction(value)) {\n    for (var _len3 = arguments.length, props = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      props[_key3 - 2] = arguments[_key3];\n    }\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return value;\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === undefined) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return {\n        ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n  // @ts-ignore\n  Object.entries(data).filter(_ref8 => {\n    let [key, value] = _ref8;\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== undefined;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, 'renderText', context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = function ($from) {\n  let maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let textBefore = '';\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || '%leaf%';\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n  // check for code node\n  $from.parent.type.spec.code\n  // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n        const {\n          $cursor\n        } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(pasteRuleMatch => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            return false;\n          },\n          paste: (view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule\n        });\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.extensions.forEach(extension => {\n      var _a;\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n      return extension;\n    })\n    // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  get plugins() {\n    const {\n      editor\n    } = this;\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n      let defaultBindings = {};\n      // bind exit handling\n      if (extension.type === 'mark' && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({\n          editor,\n          mark: extension\n        });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(_ref9 => {\n          let [shortcut, method] = _ref9;\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        defaultBindings = {\n          ...defaultBindings,\n          ...bindings\n        };\n      }\n      const keyMapPlugin = keymap(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = {\n    ...target\n  };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Extension(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(_ref10 => {\n    let [, node] = _ref10;\n    return node.spec.toText;\n  }).map(_ref11 => {\n    let [name, node] = _ref11;\n    return [name, node.spec.toText];\n  }));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n});\nconst blur = () => _ref12 => {\n  let {\n    editor,\n    view\n  } = _ref12;\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = function () {\n  let emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return _ref13 => {\n    let {\n      commands\n    } = _ref13;\n    return commands.setContent('', emitUpdate);\n  };\n};\nconst clearNodes = () => _ref14 => {\n  let {\n    state,\n    tr,\n    dispatch\n  } = _ref14;\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(_ref15 => {\n    let {\n      $from,\n      $to\n    } = _ref15;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = liftTarget(nodeRange);\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = fn => props => {\n  return fn(props);\n};\nconst createParagraphNear = () => _ref16 => {\n  let {\n    state,\n    dispatch\n  } = _ref16;\n  return createParagraphNear$1(state, dispatch);\n};\nconst cut = (originRange, targetPos) => _ref17 => {\n  let {\n    editor,\n    tr\n  } = _ref17;\n  const {\n    state\n  } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));\n  return true;\n};\nconst deleteCurrentNode = () => _ref18 => {\n  let {\n    tr,\n    dispatch\n  } = _ref18;\n  const {\n    selection\n  } = tr;\n  const currentNode = selection.$anchor.node();\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteNode = typeOrName => _ref19 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref19;\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = range => _ref20 => {\n  let {\n    tr,\n    dispatch\n  } = _ref20;\n  const {\n    from,\n    to\n  } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => _ref21 => {\n  let {\n    state,\n    dispatch\n  } = _ref21;\n  return deleteSelection$1(state, dispatch);\n};\nconst enter = () => _ref22 => {\n  let {\n    commands\n  } = _ref22;\n  return commands.keyboardShortcut('Enter');\n};\nconst exitCode = () => _ref23 => {\n  let {\n    state,\n    dispatch\n  } = _ref23;\n  return exitCode$1(state, dispatch);\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\nfunction objectIncludes(object1, object2) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    strict: true\n  };\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref24 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref24;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      doc,\n      selection\n    } = tr;\n    const {\n      $from,\n      from,\n      to\n    } = selection;\n    if (dispatch) {\n      const range = getMarkRange($from, type, attributes);\n      if (range && range.from <= from && range.to >= to) {\n        const newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n    return true;\n  };\n};\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof TextSelection;\n}\nfunction minMax() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc) {\n  let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\nconst focus = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref25 => {\n    let {\n      editor,\n      view,\n      tr,\n      dispatch\n    } = _ref25;\n    options = {\n      scrollIntoView: true,\n      ...options\n    };\n    const delayedFocus = () => {\n      // focus within `requestAnimationFrame` breaks focus on iOS\n      // so we have to call this\n      if (isiOS()) {\n        view.dom.focus();\n      }\n      // For React we have to focus asynchronously. Otherwise wild things happen.\n      // see: https://github.com/ueberdosis/tiptap/issues/1520\n      requestAnimationFrame(() => {\n        if (!editor.isDestroyed) {\n          view.focus();\n          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n            editor.commands.scrollIntoView();\n          }\n        }\n      });\n    };\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      delayedFocus();\n      return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n      if (!isSameSelection) {\n        tr.setSelection(selection);\n      }\n      // `tr.setSelection` resets the stored marks\n      // so we’ll restore them if the selection is the same as before\n      if (isSameSelection && tr.storedMarks) {\n        tr.setStoredMarks(tr.storedMarks);\n      }\n      delayedFocus();\n    }\n    return true;\n  };\n};\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, {\n    ...props,\n    index\n  }));\n};\nconst insertContent = (value, options) => _ref26 => {\n  let {\n    tr,\n    commands\n  } = _ref26;\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\nconst insertContentAt = (position, value, options) => _ref27 => {\n  let {\n    tr,\n    dispatch,\n    editor\n  } = _ref27;\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    });\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true;\n    }\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : {\n      from: position.from,\n      to: position.to\n    };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to);\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to);\n      } else {\n        tr.insertText(value, from, to);\n      }\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinUp = () => _ref28 => {\n  let {\n    state,\n    dispatch\n  } = _ref28;\n  return joinUp$1(state, dispatch);\n};\nconst joinDown = () => _ref29 => {\n  let {\n    state,\n    dispatch\n  } = _ref29;\n  return joinDown$1(state, dispatch);\n};\nconst joinBackward = () => _ref30 => {\n  let {\n    state,\n    dispatch\n  } = _ref30;\n  return joinBackward$1(state, dispatch);\n};\nconst joinForward = () => _ref31 => {\n  let {\n    state,\n    dispatch\n  } = _ref31;\n  return joinForward$1(state, dispatch);\n};\nconst joinItemBackward = () => _ref32 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref32;\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\nconst joinItemForward = () => _ref33 => {\n  let {\n    state,\n    dispatch,\n    tr\n  } = _ref33;\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === 'Space') {\n    result = ' ';\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nconst keyboardShortcut = name => _ref34 => {\n  let {\n    editor,\n    view,\n    tr,\n    dispatch\n  } = _ref34;\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref35 => {\n    let {\n      state,\n      dispatch\n    } = _ref35;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n      return false;\n    }\n    return lift$1(state, dispatch);\n  };\n};\nconst liftEmptyBlock = () => _ref36 => {\n  let {\n    state,\n    dispatch\n  } = _ref36;\n  return liftEmptyBlock$1(state, dispatch);\n};\nconst liftListItem = typeOrName => _ref37 => {\n  let {\n    state,\n    dispatch\n  } = _ref37;\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\nconst newlineInCode = () => _ref38 => {\n  let {\n    state,\n    dispatch\n  } = _ref38;\n  return newlineInCode$1(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n  return null;\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => _ref39 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref39;\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => _ref40 => {\n  let {\n    tr,\n    dispatch\n  } = _ref40;\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => _ref41 => {\n  let {\n    tr,\n    commands\n  } = _ref41;\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => _ref42 => {\n  let {\n    state,\n    dispatch\n  } = _ref42;\n  return selectNodeBackward$1(state, dispatch);\n};\nconst selectNodeForward = () => _ref43 => {\n  let {\n    state,\n    dispatch\n  } = _ref43;\n  return selectNodeForward$1(state, dispatch);\n};\nconst selectParentNode = () => _ref44 => {\n  let {\n    state,\n    dispatch\n  } = _ref44;\n  return selectParentNode$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockEnd = () => _ref45 => {\n  let {\n    state,\n    dispatch\n  } = _ref45;\n  return selectTextblockEnd$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockStart = () => _ref46 => {\n  let {\n    state,\n    dispatch\n  } = _ref46;\n  return selectTextblockStart$1(state, dispatch);\n};\nfunction createDocument(content, schema) {\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\nconst setContent = function (content) {\n  let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref47 => {\n    let {\n      tr,\n      editor,\n      dispatch\n    } = _ref47;\n    const {\n      doc\n    } = tr;\n    const document = createDocument(content, editor.schema, parseOptions);\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n    }\n    return true;\n  };\n};\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return {\n    ...mark.attrs\n  };\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return {\n    ...node.attrs\n  };\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\nfunction removeDuplicates(array) {\n  let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.stringify;\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n      if (from === undefined || to === undefined) {\n        return;\n      }\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n    ranges.forEach(_ref48 => {\n      let {\n        from,\n        to\n      } = _ref48;\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node) {\n  let startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = {\n        ...mark.attrs\n      };\n    }\n    return output;\n  });\n  const attrs = {\n    ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\n\n/**\r\n * Finds the first node of a given type or name in the current selection.\r\n * @param state The editor state.\r\n * @param typeOrName The node type or name.\r\n * @param pos The position to start searching from.\r\n * @param maxDepth The maximum depth to search.\r\n * @returns The node and the depth as an array.\r\n */\nconst getNodeAtPosition = function (state, typeOrName, pos) {\n  let maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(_ref49 => {\n    let [name] = _ref49;\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction isMarkActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(_ref50 => {\n    let {\n      $from,\n      $to\n    } = _ref50;\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  // calculate range of matched mark\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nconst isAtEndOfNode = (state, nodeType) => {\n  const {\n    $from,\n    $to,\n    $anchor\n  } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nconst isAtStartOfNode = state => {\n  const {\n    $from,\n    $to\n  } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n  if (typeof group !== 'string') {\n    return false;\n  }\n  return group.split(' ').includes('list');\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const {\n    selection\n  } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    // There can be no current marks that exclude the new mark\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType));\n  }\n  const {\n    ranges\n  } = selection;\n  return ranges.some(_ref51 => {\n    let {\n      $from,\n      $to\n    } = _ref51;\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref52 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref52;\n    const {\n      selection\n    } = tr;\n    const {\n      empty,\n      ranges\n    } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n      if (empty) {\n        const oldAttributes = getMarkAttributes(state, type);\n        tr.addStoredMark(type.create({\n          ...oldAttributes,\n          ...attributes\n        }));\n      } else {\n        ranges.forEach(range => {\n          const from = range.$from.pos;\n          const to = range.$to.pos;\n          state.doc.nodesBetween(from, to, (node, pos) => {\n            const trimmedFrom = Math.max(pos, from);\n            const trimmedTo = Math.min(pos + node.nodeSize, to);\n            const someHasMark = node.marks.find(mark => mark.type === type);\n            // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n            if (someHasMark) {\n              node.marks.forEach(mark => {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  }));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n    return canSetMark(state, tr, type);\n  };\n};\nconst setMeta = (key, value) => _ref53 => {\n  let {\n    tr\n  } = _ref53;\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref54 => {\n    let {\n      state,\n      dispatch,\n      chain\n    } = _ref54;\n    const type = getNodeType(typeOrName, state.schema);\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n      console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n      return false;\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(_ref55 => {\n      let {\n        commands\n      } = _ref55;\n      const canSetBlock = setBlockType(type, attributes)(state);\n      if (canSetBlock) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).command(_ref56 => {\n      let {\n        state: updatedState\n      } = _ref56;\n      return setBlockType(type, attributes)(updatedState, dispatch);\n    }).run();\n  };\n};\nconst setNodeSelection = position => _ref57 => {\n  let {\n    tr,\n    dispatch\n  } = _ref57;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = position => _ref58 => {\n  let {\n    tr,\n    dispatch\n  } = _ref58;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = typeOrName => _ref59 => {\n  let {\n    state,\n    dispatch\n  } = _ref59;\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = function () {\n  let {\n    keepMarks = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref60 => {\n    let {\n      tr,\n      state,\n      dispatch,\n      editor\n    } = _ref60;\n    const {\n      selection,\n      doc\n    } = tr;\n    const {\n      $from,\n      $to\n    } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.split($from.pos).scrollIntoView();\n      }\n      return true;\n    }\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n    if (dispatch) {\n      const atEnd = $to.parentOffset === $to.parent.content.size;\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n      const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      let types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          const first = tr.mapping.map($from.before());\n          const $first = tr.doc.resolve(first);\n          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  };\n};\nconst splitListItem = typeOrName => _ref61 => {\n  let {\n    tr,\n    state,\n    dispatch,\n    editor\n  } = _ref61;\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection;\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      }\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      splittableMarks\n    } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === undefined) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === undefined) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = function (listTypeOrName, itemTypeOrName, keepMarks) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return _ref62 => {\n    let {\n      editor,\n      tr,\n      state,\n      dispatch,\n      chain,\n      commands,\n      can\n    } = _ref62;\n    const {\n      extensions,\n      splittableMarks\n    } = editor.extensionManager;\n    const listType = getNodeType(listTypeOrName, state.schema);\n    const itemType = getNodeType(itemTypeOrName, state.schema);\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    if (!range) {\n      return false;\n    }\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType);\n      }\n      // change list type\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        return chain().command(() => {\n          tr.setNodeMarkup(parentList.pos, listType);\n          return true;\n        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n      }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n      return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes);\n        if (canWrapInList) {\n          return true;\n        }\n        return commands.clearNodes();\n      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n      tr.ensureMarks(filteredMarks);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  };\n};\nconst toggleMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref63 => {\n    let {\n      state,\n      commands\n    } = _ref63;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n      return commands.unsetMark(type, {\n        extendEmptyMarkRange\n      });\n    }\n    return commands.setMark(type, attributes);\n  };\n};\nconst toggleNode = function (typeOrName, toggleTypeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref64 => {\n    let {\n      state,\n      commands\n    } = _ref64;\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n    return commands.setNode(type, attributes);\n  };\n};\nconst toggleWrap = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref65 => {\n    let {\n      state,\n      commands\n    } = _ref65;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n  };\n};\nconst undoInputRule = () => _ref66 => {\n  let {\n    state,\n    dispatch\n  } = _ref66;\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => _ref67 => {\n  let {\n    tr,\n    dispatch\n  } = _ref67;\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = function (typeOrName) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref68 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref68;\n    var _a;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const {\n      selection\n    } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      $from,\n      empty,\n      ranges\n    } = selection;\n    if (!dispatch) {\n      return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n      let {\n        from,\n        to\n      } = selection;\n      const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n      const range = getMarkRange($from, type, attrs);\n      if (range) {\n        from = range.from;\n        to = range.to;\n      }\n      tr.removeMark(from, to, type);\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type);\n      });\n    }\n    tr.removeStoredMark(type);\n    return true;\n  };\n};\nconst updateAttributes = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref69 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref69;\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n      return false;\n    }\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n      tr.selection.ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, {\n              ...node.attrs,\n              ...attributes\n            });\n          }\n          if (markType && node.marks.length) {\n            node.marks.forEach(mark => {\n              if (markType === mark.type) {\n                const trimmedFrom = Math.max(pos, from);\n                const trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          }\n        });\n      });\n    }\n    return true;\n  };\n};\nconst wrapIn = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref70 => {\n    let {\n      state,\n      dispatch\n    } = _ref70;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapIn$1(type, attributes)(state, dispatch);\n  };\n};\nconst wrapInList = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref71 => {\n    let {\n      state,\n      dispatch\n    } = _ref71;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapInList$1(type, attributes)(state, dispatch);\n  };\n};\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n  addCommands() {\n    return {\n      ...commands\n    };\n  }\n});\nconst Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(_ref72 => {\n      let {\n        commands\n      } = _ref72;\n      return [() => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(_ref73 => {\n        let {\n          tr\n        } = _ref73;\n        const {\n          selection,\n          doc\n        } = tr;\n        const {\n          empty,\n          $anchor\n        } = selection;\n        const {\n          pos,\n          parent\n        } = $anchor;\n        const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n        const parentPos = $anchor.pos - $anchor.parentOffset;\n        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc).from === pos;\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false;\n        }\n        return commands.clearNodes();\n      }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()];\n    });\n    const handleDelete = () => this.editor.commands.first(_ref74 => {\n      let {\n        commands\n      } = _ref74;\n      return [() => commands.deleteSelection(), () => commands.deleteCurrentNode(), () => commands.joinForward(), () => commands.selectNodeForward()];\n    });\n    const handleEnter = () => this.editor.commands.first(_ref75 => {\n      let {\n        commands\n      } = _ref75;\n      return [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()];\n    });\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n    // With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n        if (!docChanges) {\n          return;\n        }\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        if (empty || !allWasSelected) {\n          return;\n        }\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n        if (!isEmpty) {\n          return;\n        }\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n        if (!tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    })];\n  }\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`);\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement('style');\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n  setOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n  setEditable(editable) {\n    let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.setOptions({\n      editable\n    });\n    if (emitUpdate) {\n      this.emit('update', {\n        editor: this,\n        transaction: this.state.tr\n      });\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    });\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    this.prependClass();\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\r\n   * Prepend class name to element.\r\n   */\n  prependClass() {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`;\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n  dispatchTransaction(transaction) {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach(step => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n  destroy() {\n    this.emit('destroy');\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n  get isDestroyed() {\n    var _a;\n    // @ts-ignore\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref76 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref76;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref77 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref77;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    }\n  });\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref78 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref78;\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref79 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref79;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref80 => {\n      let {\n        state,\n        range,\n        match,\n        chain\n      } = _ref80;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const {\n          selection,\n          storedMarks\n        } = state;\n        const {\n          splittableMarks\n        } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Mark(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit(_ref81) {\n    let {\n      editor,\n      mark\n    } = _ref81;\n    const {\n      tr\n    } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(' ', currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Node(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction isAndroid() {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      view\n    } = this.editor;\n    const target = event.target;\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith('drag');\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('drop', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    }\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    }\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false;\n    }\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    }\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    }\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(_ref82 => {\n      let {\n        tr\n      } = _ref82;\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref83 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref83;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler(_ref84) {\n      let {\n        match,\n        chain,\n        range\n      } = _ref84;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref85 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref85;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, createChainableState, createDocument, createNodeFromContent, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getAttributesFromExtensions, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAtPosition, getNodeAttributes, getNodeType, getRenderedAttributes, getSchema, getSchemaByResolvedExtensions, getSchemaTypeByName, getSchemaTypeNameByName, getSplittedAttributes, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, injectExtensionAttributesToParseRule, inputRulesPlugin, isActive, isAtEndOfNode, isAtStartOfNode, isEmptyObject, isExtensionRulesEnabled, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, resolveFocusPosition, selectionToInsertionEnd, splitExtensions, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","_this","view","buildProps","Object","fromEntries","entries","map","_ref","name","command","method","callback","arguments","getMeta","dispatch","chain","createChain","can","createCan","startTr","_this2","shouldDispatch","length","undefined","callbacks","hasStartTransaction","run","every","_ref2","chainedCommand","push","formattedCommands","_ref3","_ref4","EventEmitter","on","event","fn","emit","_len","args","Array","_key","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","_ref5","attribute","addAttributes","_ref6","mergedAttr","getNodeType","nameOrType","nodes","Error","mergeAttributes","_len2","objects","_key2","item","reduce","items","mergedAttributes","_ref7","key","exists","valueClasses","split","existingClasses","insertClasses","valueClass","includes","join","getRenderedAttributes","nodeOrMark","attrs","isFunction","callOrReturn","_len3","_key3","isEmptyObject","keys","fromString","match","Number","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","_ref8","getSchemaByResolvedExtensions","allAttributes","topNode","_a","find","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","toDOM","HTMLAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","getSchemaTypeByName","isExtensionRulesEnabled","enabled","isArray","some","enabledExtension","getTextContentFromNodes","$from","maxMatch","textBefore","sliceEndPos","parentOffset","nodesBetween","Math","max","pos","index","chunk","_b","spec","call","textContent","slice","isRegExp","prototype","toString","InputRule","handler","inputRuleMatcherHandler","text","exec","inputRuleMatch","result","input","replaceWith","console","warn","run$1","from","to","rules","plugin","composing","resolve","nodeBefore","nodeAfter","matched","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","splittableMarks","extensionStorage","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","defaultBindings","exitable","ArrowRight","Mark","handleExit","bindings","_ref9","shortcut","keyMapPlugin","keymap","addInputRules","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","addNodeView","nodeview","getPos","decorations","getType","isPlainObject","getPrototypeOf","mergeDeep","source","output","assign","Extension","child","defaultOptions","addOptions","create","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","_ref10","_ref11","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","_ref12","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","_ref13","setContent","clearNodes","_ref14","_ref15","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","_ref16","createParagraphNear$1","cut","originRange","targetPos","_ref17","contentSlice","deleteRange","newPos","insert","setSelection","TextSelection","deleteCurrentNode","_ref18","currentNode","$anchor","$pos","depth","before","after","delete","scrollIntoView","deleteNode","typeOrName","_ref19","_ref20","deleteSelection","_ref21","deleteSelection$1","enter","_ref22","keyboardShortcut","exitCode","_ref23","exitCode$1","objectIncludes","object1","object2","strict","test","findMarkInSet","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","getMarkType","extendMarkRange","_ref24","newSelection","first","i","isTextSelection","minMax","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","isiOS","navigator","platform","userAgent","document","focus","_ref25","delayedFocus","hasFocus","isSameSelection","eq","setStoredMarks","insertContent","_ref26","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","_ref27","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","v","joinUp","_ref28","joinUp$1","joinDown","_ref29","joinDown$1","joinBackward","_ref30","joinBackward$1","joinForward","_ref31","joinForward$1","joinItemBackward","_ref32","point","joinPoint","joinItemForward","_ref33","isMacOS","normalizeKeyName","parts","alt","ctrl","shift","meta","mod","_ref34","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","_ref35","isActive","lift$1","liftEmptyBlock","_ref36","liftEmptyBlock$1","liftListItem","_ref37","liftListItem$1","newlineInCode","_ref38","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes","_ref39","nodeType","markType","schemaType","addMark","_ref40","selectAll","_ref41","setTextSelection","selectNodeBackward","_ref42","selectNodeBackward$1","selectNodeForward","_ref43","selectNodeForward$1","selectParentNode","_ref44","selectParentNode$1","selectTextblockEnd","_ref45","selectTextblockEnd$1","selectTextblockStart","_ref46","selectTextblockStart$1","createDocument","_ref47","getMarkAttributes","$head","markItem","combineTransactionSteps","oldDoc","Transform","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","findChildren","predicate","nodesWithPos","descendants","findChildrenInRange","findParentNodeClosestToPos","findParentNode","getHTMLFromFragment","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","getSchema","generateHTML","contentNode","Node$1","fromJSON","generateJSON","getText","generateText","getNodeAttributes","nodeItem","getAttributes","removeDuplicates","array","by","JSON","stringify","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","_ref48","newStart","newEnd","oldStart","invert","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","getNodeAtPosition","maxDepth","currentDepth","getSplittedAttributes","typeName","_ref49","isMarkActive","markRanges","_ref50","matchedRange","markRange","excludedRange","isAtEndOfNode","parentNode","$parentPos","isAtStartOfNode","isList","isNodeEmpty","defaultContent","createAndFill","isNodeSelection","NodeSelection","posToDOMRect","resolvedEnd","coordsAtPos","top","bottom","left","right","width","height","x","y","canSetMark","newMarkType","cursor","currentMarks","_ref51","someNodeSupportsMark","inlineContent","allowsMarkType","_pos","isInline","parentAllowsMarkType","currentMarksAllowMarkType","otherMark","setMark","_ref52","addStoredMark","trimmedFrom","trimmedTo","someHasMark","_ref53","setNode","_ref54","_ref55","canSetBlock","setBlockType","_ref56","updatedState","setNodeSelection","_ref57","_ref58","sinkListItem","_ref59","sinkListItem$1","ensureMarks","filteredMarks","splitBlock","keepMarks","_ref60","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","_ref61","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","append","replace","Slice","sel","n","newTypeAttributes","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","_ref62","itemType","parentList","validContent","canWrapInList","wrapInList","toggleMark","_ref63","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","_ref64","toggleType","toggleWrap","_ref65","wrapIn","undoInputRule","_ref66","undoable","getState","toUndo","j","docs","unsetAllMarks","_ref67","removeMark","_ref68","removeStoredMark","updateAttributes","_ref69","_ref70","wrapIn$1","_ref71","wrapInList$1","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","_ref72","_ref73","parentIsIsolating","parentPos","isAtStart","handleDelete","_ref74","handleEnter","_ref75","baseKeymap","Enter","Mod-Enter","Backspace","Delete","Mod-a","pcKeymap","macKeymap","Ctrl-a","Ctrl-e","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","createStyleTag","nonce","suffix","tiptapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","prependClass","className","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","markInputRule","_ref76","captureGroup","fullMatch","startSpaces","search","textStart","textEnd","excludedMarks","excluded","markEnd","nodeInputRule","_ref77","newNode","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","_ref78","$start","textInputRule","_ref79","cutOff","wrappingInputRule","_ref80","wrapping","findWrapping","keepAttributes","joinPredicate","_ref81","currentPos","isAtEnd","isInMark","m","Node","isAndroid","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","_c","_d","nativeEvent","offsetY","_e","_f","_g","dataTransfer","setDragImage","isInElement","isDragEvent","isDropEvent","isInput","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","_ref82","markPasteRule","_ref83","escapeForRegEx","string","isString","nodePasteRule","_ref84","textPasteRule","_ref85","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\createChainableState.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\CommandManager.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\EventEmitter.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getExtensionField.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\splitExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributesFromExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeType.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\mergeAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getRenderedAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isFunction.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\callOrReturn.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isEmptyObject.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\fromString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\injectExtensionAttributesToParseRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaByResolvedExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeByName.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isExtensionRulesEnabled.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getTextContentFromNodes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isRegExp.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\InputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isNumber.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\PasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\findDuplicates.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\ExtensionManager.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isPlainObject.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\mergeDeep.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\Extension.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getTextBetween.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getTextSerializersFromSchema.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\clipboardTextSerializer.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\blur.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\clearContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\clearNodes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\command.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\createParagraphNear.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\cut.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\deleteCurrentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\deleteNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\deleteRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\deleteSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\enter.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\exitCode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\objectIncludes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkType.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\extendMarkRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\first.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isTextSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\minMax.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\resolveFocusPosition.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isiOS.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\focus.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\forEach.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\insertContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\elementFromString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\createNodeFromContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\selectionToInsertionEnd.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\insertContentAt.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\join.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\joinItemBackward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\joinItemForward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isMacOS.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\keyboardShortcut.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\lift.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\liftEmptyBlock.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\liftListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\newlineInCode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeNameByName.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\deleteProps.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\resetAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\scrollIntoView.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectAll.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeBackward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeForward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectParentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockEnd.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockStart.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\createDocument.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\combineTransactionSteps.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\defaultBlockAt.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\findChildren.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\findChildrenInRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNodeClosestToPos.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getHTMLFromFragment.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getSchema.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\generateHTML.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\generateJSON.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getText.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\generateText.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\removeDuplicates.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getChangedRanges.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getDebugJSON.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getMarksBetween.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeAtPosition.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\getSplittedAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isMarkActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isAtEndOfNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isAtStartOfNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeEmpty.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\helpers\\posToDOMRect.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setMeta.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setNodeSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\setTextSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\sinkListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\splitBlock.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\splitListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\toggleList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\toggleMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\toggleNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\toggleWrap.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\undoInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\unsetAllMarks.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\unsetMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\updateAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\wrapIn.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\commands\\wrapInList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\commands.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\editable.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\focusEvents.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\keymap.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\extensions\\tabindex.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\style.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\createStyleTag.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\Editor.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\inputRules\\markInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\inputRules\\nodeInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\inputRules\\textblockTypeInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\inputRules\\textInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\inputRules\\wrappingInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\Mark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\Node.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isAndroid.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\NodeView.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\pasteRules\\markPasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\escapeForRegEx.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\utilities\\isString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\pasteRules\\nodePasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\pasteRules\\textPasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\node_modules\\@tiptap\\core\\src\\Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from '@tiptap/pm/state'\n\nexport function createChainableState(config: {\n  transaction: Transaction\n  state: EditorState\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands,\n} from './types.js'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types.js'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension.js'\nimport { Mark } from '../Mark.js'\nimport { Node } from '../Node.js'\nimport { Extensions } from '../types.js'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '../index.js'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { splitExtensions } from './splitExtensions.js'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (typeof mergedAttr?.default === 'function') {\n          mergedAttr.default = mergedAttr.default()\n        }\n\n        if (mergedAttr?.isRequired && mergedAttr?.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\n        `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          const valueClasses: string[] = value ? value.split(' ') : []\n          const existingClasses: string[] = mergedAttributes[key] ? mergedAttributes[key].split(' ') : []\n\n          const insertClasses = valueClasses.filter(\n            valueClass => !existingClasses.includes(valueClass),\n          )\n\n          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { mergeAttributes } from '../utilities/mergeAttributes.js'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types.js'\nimport { isFunction } from './isFunction.js'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { fromString } from '../utilities/fromString.js'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from '@tiptap/pm/model'\n\nimport { Editor, MarkConfig, NodeConfig } from '../index.js'\nimport { AnyConfig, Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { isEmptyObject } from '../utilities/isEmptyObject.js'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { getRenderedAttributes } from './getRenderedAttributes.js'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value as {} | undefined)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions, editor?: Editor): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n          e,\n          'extendNodeSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(\n          getExtensionField<NodeConfig['content']>(extension, 'content', context),\n        ),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(\n          getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context),\n        ),\n        draggable: callOrReturn(\n          getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context),\n        ),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        defining: callOrReturn(\n          getExtensionField<NodeConfig['defining']>(extension, 'defining', context),\n        ),\n        isolating: callOrReturn(\n          getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context),\n        ),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = node => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n        })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(\n        extension,\n        'renderText',\n        context,\n      )\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n          e,\n          'extendMarkSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(\n          getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context),\n        ),\n        excludes: callOrReturn(\n          getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context),\n        ),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(\n          getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context),\n        ),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = mark => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n        })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types.js'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from '@tiptap/pm/model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(\n    Math.max(0, sliceEndPos - maxMatch),\n    sliceEndPos,\n    (node, pos, parent, index) => {\n      const chunk = node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      })\n        || node.textContent\n        || '%leaf%'\n\n      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos))\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (\n  text: string,\n  find: InputRuleFinder,\n): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn(\n        '[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".',\n      )\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const {\n    editor, from, to, text, rules, plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isNumber } from './utilities/isNumber.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn(\n          '[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".',\n        )\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n}): boolean {\n  const {\n    editor, state, from, to, rule,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n\n            return false\n          },\n\n          paste: (view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport { Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\nimport { Plugin } from '@tiptap/pm/state'\nimport { Decoration, EditorView } from '@tiptap/pm/view'\n\nimport { Editor } from './Editor.js'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { getNodeType } from './helpers/getNodeType.js'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes.js'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions.js'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName.js'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled.js'\nimport { splitExtensions } from './helpers/splitExtensions.js'\nimport { Mark, NodeConfig } from './index.js'\nimport { inputRulesPlugin } from './InputRule.js'\nimport { pasteRulesPlugin } from './PasteRule.js'\nimport { AnyConfig, Extensions, RawCommands } from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { findDuplicates } from './utilities/findDuplicates.js'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(\n        `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n          .map(item => `'${item}'`)\n          .join(', ')}]. This can lead to issues.`,\n      )\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return (\n      extensions\n        .map(extension => {\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n          }\n\n          const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n            extension,\n            'addExtensions',\n            context,\n          )\n\n          if (addExtensions) {\n            return [extension, ...this.flatten(addExtensions())]\n          }\n\n          return extension\n        })\n        // `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10)\n    )\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        let defaultBindings: Record<string, () => boolean> = {}\n\n        // bind exit handling\n        if (extension.type === 'mark' && extension.config.exitable) {\n          defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n        }\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n              return [shortcut, () => method({ editor })]\n            }),\n          )\n\n          defaultBindings = { ...defaultBindings, ...bindings }\n        }\n\n        const keyMapPlugin = keymap(defaultBindings)\n\n        plugins.push(keyMapPlugin)\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(\n            attribute => attribute.type === extension.name,\n          )\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n            extension,\n            'addNodeView',\n            context,\n          )\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeview = (\n            node: ProsemirrorNode,\n            view: EditorView,\n            getPos: (() => number) | boolean,\n            decorations: Decoration[],\n          ) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return addNodeView()({\n              editor,\n              node,\n              getPos,\n              decorations,\n              HTMLAttributes,\n              extension,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject.js'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { ExtensionConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Mark } from './Mark.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { Range, TextSerializer } from '../types.js'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\nimport { getTextBetween } from '../helpers/getTextBetween.js'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema.js'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    cut: {\n      /**\n       * Cuts content from a range and inserts it at a given position.\n       */\n      cut: ({ from, to }: { from: number, to: number }, targetPos: number) => ReturnType,\n    }\n  }\n}\n\nexport const cut: RawCommands['cut'] = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor\n\n  const contentSlice = state.doc.slice(originRange.from, originRange.to)\n\n  tr.deleteRange(originRange.from, originRange.to)\n  const newPos = tr.mapping.map(targetPos)\n\n  tr.insert(newPos, contentSlice.content)\n\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)))\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       */\n      deleteCurrentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const currentNode = selection.$anchor.node()\n\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false\n  }\n\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp.js'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Range } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\n        `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport { FocusPosition } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection.js'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition.js'\nimport { FocusPosition, RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt(\n    { from: tr.selection.from, to: tr.selection.to },\n    value,\n    options,\n  )\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent.js'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd.js'\nimport { Content, Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to }\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content) ? content : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to)\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to)\n      } else {\n        tr.insertText(value as string, from, to)\n      }\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join two nodes Up.\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join two nodes Down.\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * Join two nodes Backwards.\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] = () => ({ state, dispatch }) => {\n  return originalJoinUp(state, dispatch)\n}\n\nexport const joinDown: RawCommands['joinDown'] = () => ({ state, dispatch }) => {\n  return originalJoinDown(state, dispatch)\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemBackward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemBackward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemBackward: RawCommands['joinItemBackward'] = () => ({\n  tr, state, dispatch,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemForward: RawCommands['joinItemForward'] = () => ({\n  state,\n  dispatch,\n  tr,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { NodeRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getNodeType } from './getNodeType.js'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\nimport { deleteProps } from '../utilities/deleteProps.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: string | string[],\n      ) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(\n                pos,\n                pos + node.nodeSize,\n                markType.create(deleteProps(mark.attrs, attributes)),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { createNodeFromContent } from './createNodeFromContent.js'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument.js'\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Mark, MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType.js'\n\nexport function getMarkAttributes(\n  state: EditorState,\n  typeOrName: string | MarkType,\n): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(\n  oldDoc: ProseMirrorNode,\n  transactions: Transaction[],\n): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from '@tiptap/pm/model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate } from '../types.js'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate, Range } from '../types.js'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(\n  node: ProseMirrorNode,\n  range: Range,\n  predicate: Predicate,\n): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Predicate } from '../types.js'\n\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from '@tiptap/pm/state'\n\nimport { Predicate } from '../types.js'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos.js'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { DOMSerializer, Fragment, Schema } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { Editor } from '../Editor.js'\nimport { ExtensionManager } from '../ExtensionManager.js'\nimport { Extensions } from '../types.js'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions.js'\n\nexport function getSchema(extensions: Extensions, editor?: Editor): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent } from '../types.js'\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport { Extensions } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\nimport { getTextBetween } from './getTextBetween.js'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types.js'\nimport { getSchema } from './getSchema.js'\nimport { getText } from './getText.js'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema.js'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType.js'\n\nexport function getNodeAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType,\n): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes.js'\nimport { getNodeAttributes } from './getNodeAttributes.js'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from '@tiptap/pm/transform'\n\nimport { Range } from '../types.js'\nimport { removeDuplicates } from '../utilities/removeDuplicates.js'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { JSONContent } from '../types.js'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { MarkRange } from '../types.js'\nimport { getMarkRange } from './getMarkRange.js'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nexport const getNodeAtPosition = (state: EditorState, typeOrName: string | NodeType, pos: number, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos)\n\n  let currentDepth = maxDepth\n  let node: Node | null = null\n\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth)\n\n    if (currentNode?.type.name === typeOrName) {\n      node = currentNode\n    } else {\n      currentDepth -= 1\n    }\n  }\n\n  return [node, currentDepth] as [Node | null, number]\n}\n","import { ExtensionAttribute } from '../types.js'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MarkRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getMarkType } from './getMarkType.js'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\nimport { isMarkActive } from './isMarkActive.js'\nimport { isNodeActive } from './isNodeActive.js'\n\nexport function isActive(\n  state: EditorState,\n  name: string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { findParentNode } from './findParentNode.js'\n\nexport const isAtEndOfNode = (state: EditorState, nodeType?: string) => {\n  const { $from, $to, $anchor } = state.selection\n\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection)\n\n    if (!parentNode) {\n      return false\n    }\n\n    const $parentPos = state.doc.resolve(parentNode.pos + 1)\n\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true\n    }\n\n    return false\n  }\n\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nexport const isAtStartOfNode = (state: EditorState) => {\n  const { $from, $to } = state.selection\n\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { getExtensionField } from '../helpers/getExtensionField.js'\nimport { NodeConfig } from '../index.js'\nimport { Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax.js'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from '../helpers/getMarkAttributes.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isTextSelection } from '../helpers/index.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n\n    // There can be no current marks that exclude the new mark\n    return (\n      !!newMarkType.isInSet(currentMarks)\n      || !currentMarks.some(mark => mark.type.excludes(newMarkType))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0\n      ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n      : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n          || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes,\n        }),\n      )\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes,\n                  }),\n                )\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return canSetMark(state, tr, type)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(({ commands }) => {\n        const canSetBlock = setBlockType(type, attributes)(state)\n\n        if (canSetBlock) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .command(({ state: updatedState }) => {\n        return setBlockType(type, attributes)(updatedState, dispatch)\n      })\n      .run()\n  )\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { Range, RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { EditorState, NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr, state, dispatch, editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [\n        {\n          type: deflt,\n          attrs: newAttributes,\n        },\n      ]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n        && !can\n        && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [\n          {\n            type: deflt,\n            attrs: newAttributes,\n          },\n        ]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment, Node as ProseMirrorNode, NodeType, Slice,\n} from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n        || $from.node(-3).type !== type\n        || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [\n      { type, attrs: newTypeAttributes },\n      { type: nextType, attrs: newNextTypeAttributes },\n    ]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    const { selection, storedMarks } = state\n    const { splittableMarks } = editor.extensionManager\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    tr.split($from.pos, 2, types).scrollIntoView()\n\n    if (!marks || !dispatch) {\n      return true\n    }\n\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n    tr.ensureMarks(filteredMarks)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isList } from '../helpers/isList.js'\nimport { RawCommands } from '../types.js'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType, keepMarks?: boolean, attributes?: Record<string, any>) => ReturnType;\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions, splittableMarks } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection, storedMarks } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n        && listType.validContent(parentList.node.content)\n        && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n\n    return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n        tr.ensureMarks(filteredMarks)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  )\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isMarkActive } from '../helpers/isMarkActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands/index.js'\nimport { Extension } from '../Extension.js'\n\nexport * from '../commands/index.js'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager.js'\nimport { Extension } from '../Extension.js'\nimport { createChainableState } from '../helpers/createChainableState.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating\n\n        const parentPos = $anchor.pos - $anchor.parentOffset\n\n        const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\n          ? parentPos === $anchor.pos\n          : Selection.atStart(doc).from === pos\n\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n\n          if (empty || !allWasSelected) {\n            return\n          }\n\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (!isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string, suffix?: string): HTMLStyleElement {\n  const tiptapStyleTag = (<HTMLStyleElement>document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`))\n\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager.js'\nimport { EventEmitter } from './EventEmitter.js'\nimport { ExtensionManager } from './ExtensionManager.js'\nimport * as extensions from './extensions/index.js'\nimport { createDocument } from './helpers/createDocument.js'\nimport { getAttributes } from './helpers/getAttributes.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport { getText } from './helpers/getText.js'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema.js'\nimport { isActive } from './helpers/isActive.js'\nimport { isNodeEmpty } from './helpers/isNodeEmpty.js'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition.js'\nimport { style } from './style.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types.js'\nimport { createStyleTag } from './utilities/createStyleTag.js'\nimport { isFunction } from './utilities/isFunction.js'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n    this.prependClass()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  /**\n   * Prepend class name to element.\n   */\n  public prependClass(): void {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn(\n      '[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.',\n    )\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        const markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  /**\n   * The regex to match.\n   */\n  find: InputRuleFinder\n\n  /**\n   * The node type to add.\n   */\n  type: NodeType\n\n  /**\n   * A function that returns the attributes for the node\n   * can also be an object of attributes\n   */\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      const newNode = config.type.create(attributes)\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode)\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(\n          tr.mapping.map(start),\n          tr.mapping.map(end),\n        )\n      }\n\n      tr.scrollIntoView()\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule.js'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport { Editor } from '../Editor.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  keepMarks?: boolean,\n  keepAttributes?: boolean,\n  editor?: Editor\n  getAttributes?:\n  | Record<string, any>\n  | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n  | false\n  | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state, range, match, chain,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { MarkConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean)\n\n    /**\n     * Inclusive\n     */\n    inclusive?:\n      | MarkSpec['inclusive']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n          editor?: Editor\n        }) => MarkSpec['inclusive'])\n\n    /**\n     * Excludes\n     */\n    excludes?:\n      | MarkSpec['excludes']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n          editor?: Editor\n        }) => MarkSpec['excludes'])\n\n    /**\n     * Marks this Mark as exitable\n     */\n    exitable?: boolean | (() => boolean)\n\n    /**\n     * Group\n     */\n    group?:\n      | MarkSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => MarkSpec['group'])\n\n    /**\n     * Spanning\n     */\n    spanning?:\n      | MarkSpec['spanning']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n          editor?: Editor\n        }) => MarkSpec['spanning'])\n\n    /**\n     * Code\n     */\n    code?:\n      | boolean\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => boolean)\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => MarkSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            mark: ProseMirrorMark\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n}\n","import {\n  DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { NodeConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema']\n            editor?: Editor\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Node View\n     */\n    addNodeView?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n        }) => NodeViewRenderer)\n      | null\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean\n\n    /**\n     * Content\n     */\n    content?:\n      | NodeSpec['content']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n          editor?: Editor\n        }) => NodeSpec['content'])\n\n    /**\n     * Marks\n     */\n    marks?:\n      | NodeSpec['marks']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n          editor?: Editor\n        }) => NodeSpec['marks'])\n\n    /**\n     * Group\n     */\n    group?:\n      | NodeSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => NodeSpec['group'])\n\n    /**\n     * Inline\n     */\n    inline?:\n      | NodeSpec['inline']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n          editor?: Editor\n        }) => NodeSpec['inline'])\n\n    /**\n     * Atom\n     */\n    atom?:\n      | NodeSpec['atom']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n          editor?: Editor\n        }) => NodeSpec['atom'])\n\n    /**\n     * Selectable\n     */\n    selectable?:\n      | NodeSpec['selectable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n          editor?: Editor\n        }) => NodeSpec['selectable'])\n\n    /**\n     * Draggable\n     */\n    draggable?:\n      | NodeSpec['draggable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n          editor?: Editor\n        }) => NodeSpec['draggable'])\n\n    /**\n     * Code\n     */\n    code?:\n      | NodeSpec['code']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => NodeSpec['code'])\n\n    /**\n     * Whitespace\n     */\n    whitespace?:\n      | NodeSpec['whitespace']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n          editor?: Editor\n        }) => NodeSpec['whitespace'])\n\n    /**\n     * Defining\n     */\n    defining?:\n      | NodeSpec['defining']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n          editor?: Editor\n        }) => NodeSpec['defining'])\n\n    /**\n     * Isolating\n     */\n    isolating?:\n      | NodeSpec['isolating']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n          editor?: Editor\n        }) => NodeSpec['isolating'])\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => NodeSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Render Text\n     */\n    renderText?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            pos: number\n            parent: ProseMirrorNode\n            index: number\n          },\n        ) => string)\n      | null\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","export function isAndroid(): boolean {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeSelection } from '@tiptap/pm/state'\nimport { NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\n\nimport { Editor as CoreEditor } from './Editor.js'\nimport { Node } from './Node.js'\nimport { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types.js'\nimport { isAndroid } from './utilities/isAndroid.js'\nimport { isiOS } from './utilities/isiOS.js'\n\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: DecorationWithType[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && (isiOS() || isAndroid())\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/index.js'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes,\n        })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule.js'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step.getMap().mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}