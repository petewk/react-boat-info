{"ast":null,"code":"import _objectSpread from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { combineTransactionSteps, getChangedRanges, getMarksBetween, findChildrenInRange, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { test, find as _find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: function appendTransaction(transactions, oldState, newState) {\n      var docChanges = transactions.some(function (transaction) {\n        return transaction.docChanged;\n      }) && !oldState.doc.eq(newState.doc);\n      var preventAutolink = transactions.some(function (transaction) {\n        return transaction.getMeta('preventAutolink');\n      });\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      var tr = newState.tr;\n      var transform = combineTransactionSteps(oldState.doc, _toConsumableArray(transactions));\n      var mapping = transform.mapping;\n      var changes = getChangedRanges(transform);\n      changes.forEach(function (_ref) {\n        var oldRange = _ref.oldRange,\n          newRange = _ref.newRange;\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter(function (item) {\n          return item.mark.type === options.type;\n        }).forEach(function (oldMark) {\n          var newFrom = mapping.map(oldMark.from);\n          var newTo = mapping.map(oldMark.to);\n          var newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter(function (item) {\n            return item.mark.type === options.type;\n          });\n          if (!newMarks.length) {\n            return;\n          }\n          var newMark = newMarks[0];\n          var oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ');\n          var newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ');\n          var wasLink = test(oldLinkText);\n          var isLink = test(newLinkText);\n          // remove only the link, if it was a link before too\n          // because we don’t want to remove links that were set manually\n          if (wasLink && !isLink) {\n            tr.removeMark(newMark.from, newMark.to, options.type);\n          }\n        });\n        // now let’s see if we can add new links\n        var nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, function (node) {\n          return node.isTextblock;\n        });\n        var textBlock;\n        var textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          var wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(function (s) {\n            return s !== '';\n          });\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          var lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          var lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          _find(lastWordBeforeSpace).filter(function (link) {\n            return link.isLink;\n          }).filter(function (link) {\n            if (options.validate) {\n              return options.validate(link.value);\n            }\n            return true;\n          })\n          // calculate link position\n          .map(function (link) {\n            return _objectSpread(_objectSpread({}, link), {}, {\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1\n            });\n          })\n          // add link mark\n          .forEach(function (link) {\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: function handleClick(view, pos, event) {\n        var _a, _b, _c;\n        var attrs = getAttributes(view.state, options.type.name);\n        var link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');\n        var href = (_b = link === null || link === void 0 ? void 0 : link.href) !== null && _b !== void 0 ? _b : attrs.href;\n        var target = (_c = link === null || link === void 0 ? void 0 : link.target) !== null && _c !== void 0 ? _c : attrs.target;\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: function handlePaste(view, event, slice) {\n        var state = view.state;\n        var selection = state.selection;\n        var empty = selection.empty;\n        if (empty) {\n          return false;\n        }\n        var textContent = '';\n        slice.content.forEach(function (node) {\n          textContent += node.textContent;\n        });\n        var link = _find(textContent).find(function (item) {\n          return item.isLink && item.value === textContent;\n        });\n        if (!textContent || !link) {\n          return false;\n        }\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\nvar Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  onCreate: function onCreate() {\n    this.options.protocols.forEach(function (protocol) {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol);\n        return;\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy: function onDestroy() {\n    reset();\n  },\n  inclusive: function inclusive() {\n    return this.options.autolink;\n  },\n  addOptions: function addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: undefined\n    };\n  },\n  addAttributes: function addAttributes() {\n    return {\n      href: {\n        default: null\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML: function parseHTML() {\n    return [{\n      tag: 'a[href]:not([href *= \"javascript:\" i])'\n    }];\n  },\n  renderHTML: function renderHTML(_ref2) {\n    var HTMLAttributes = _ref2.HTMLAttributes;\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands: function addCommands() {\n    var _this = this;\n    return {\n      setLink: function setLink(attributes) {\n        return function (_ref3) {\n          var chain = _ref3.chain;\n          return chain().setMark(_this.name, attributes).setMeta('preventAutolink', true).run();\n        };\n      },\n      toggleLink: function toggleLink(attributes) {\n        return function (_ref4) {\n          var chain = _ref4.chain;\n          return chain().toggleMark(_this.name, attributes, {\n            extendEmptyMarkRange: true\n          }).setMeta('preventAutolink', true).run();\n        };\n      },\n      unsetLink: function unsetLink() {\n        return function (_ref5) {\n          var chain = _ref5.chain;\n          return chain().unsetMark(_this.name, {\n            extendEmptyMarkRange: true\n          }).setMeta('preventAutolink', true).run();\n        };\n      }\n    };\n  },\n  addPasteRules: function addPasteRules() {\n    var _this2 = this;\n    return [markPasteRule({\n      find: function find(text) {\n        return _find(text).filter(function (link) {\n          if (_this2.options.validate) {\n            return _this2.options.validate(link.value);\n          }\n          return true;\n        }).filter(function (link) {\n          return link.isLink;\n        }).map(function (link) {\n          return {\n            text: link.value,\n            index: link.start,\n            data: link\n          };\n        });\n      },\n      type: this.type,\n      getAttributes: function getAttributes(match) {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var plugins = [];\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate\n      }));\n    }\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default };","map":{"version":3,"mappings":"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","names":["autolink","options","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","combineTransactionSteps","mapping","changes","getChangedRanges","forEach","oldRange","newRange","getMarksBetween","from","to","filter","item","mark","type","newFrom","map","oldMark","newTo","newMarks","length","newMark","oldLinkText","textBetween","undefined","newLinkText","wasLink","test","isLink","removeMark","nodesInChangedRanges","findChildrenInRange","node","isTextblock","textBlock","textBeforeWhitespace","pos","nodeSize","endsWith","wordsBeforeWhitespace","split","s","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","find","link","validate","value","start","end","addMark","create","href","steps","clickHandler","props","handleClick","view","event","attrs","getAttributes","state","name","target","closest","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","Mark","priority","keepOnSplit","onCreate","protocols","protocol","registerCustomProtocol","scheme","optionalSlashes","onDestroy","reset","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","addAttributes","default","parseHTML","tag","renderHTML","mergeAttributes","addCommands","setLink","chain","attributes","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","text","index","data","addProseMirrorPlugins","plugins","push"],"sources":["C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\autolink.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\clickHandler.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\pasteHandler.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\extension-link\\src\\link.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find, test } from 'linkifyjs'\n\ntype AutolinkOptions = {\n  type: MarkType\n  validate?: (url: string) => boolean\n}\n\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const { mapping } = transform\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ oldRange, newRange }) => {\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc)\n          .filter(item => item.mark.type === options.type)\n          .forEach(oldMark => {\n            const newFrom = mapping.map(oldMark.from)\n            const newTo = mapping.map(oldMark.to)\n            const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter(\n              item => item.mark.type === options.type,\n            )\n\n            if (!newMarks.length) {\n              return\n            }\n\n            const newMark = newMarks[0]\n            const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ')\n            const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ')\n            const wasLink = test(oldLinkText)\n            const isLink = test(newLinkText)\n\n            // remove only the link, if it was a link before too\n            // because we don’t want to remove links that were set manually\n            if (wasLink && !isLink) {\n              tr.removeMark(newMark.from, newMark.to, options.type)\n            }\n          })\n\n        // now let’s see if we can add new links\n        const nodesInChangedRanges = findChildrenInRange(\n          newState.doc,\n          newRange,\n          node => node.isTextblock,\n        )\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          find(lastWordBeforeSpace)\n            .filter(link => link.isLink)\n            .filter(link => {\n              if (options.validate) {\n                return options.validate(link.value)\n              }\n              return true\n            })\n            // calculate link position\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // add link mark\n            .forEach(link => {\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLElement)?.closest('a')\n\n        const href = link?.href ?? attrs.href\n        const target = link?.target ?? attrs.target\n\n        if (link && href) {\n          window.open(href, target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  type: MarkType\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n","import { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink'\nimport { clickHandler } from './helpers/clickHandler'\nimport { pasteHandler } from './helpers/pasteHandler'\n\nexport interface LinkProtocolOptions {\n  scheme: string;\n  optionalSlashes?: boolean;\n}\n\nexport interface LinkOptions {\n  /**\n   * If enabled, it adds links as you type.\n   */\n  autolink: boolean\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   */\n  protocols: Array<LinkProtocolOptions | string>\n  /**\n   * If enabled, links will be opened on click.\n   */\n  openOnClick: boolean\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   */\n  linkOnPaste: boolean\n  /**\n   * A list of HTML attributes to be rendered.\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate?: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       */\n      setLink: (attributes: { href: string; target?: string | null }) => ReturnType\n      /**\n       * Toggle a link mark\n       */\n      toggleLink: (attributes: { href: string; target?: string | null }) => ReturnType\n      /**\n       * Unset a link mark\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{ tag: 'a[href]:not([href *= \"javascript:\" i])' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes => ({ chain }) => {\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes => ({ chain }) => {\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () => ({ chain }) => {\n          return chain()\n            .unsetMark(this.name, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => find(text)\n          .filter(link => {\n            if (this.options.validate) {\n              return this.options.validate(link.value)\n            }\n\n            return true\n          })\n          .filter(link => link.isLink)\n          .map(link => ({\n            text: link.value,\n            index: link.start,\n            data: link,\n          })),\n        type: this.type,\n        getAttributes: match => ({\n          href: match.data?.href,\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          validate: this.options.validate,\n        }),\n      )\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          type: this.type,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}