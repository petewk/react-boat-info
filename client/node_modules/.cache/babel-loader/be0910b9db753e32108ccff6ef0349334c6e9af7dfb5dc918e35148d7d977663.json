{"ast":null,"code":"import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\nvar olDOM = [\"ol\", 0],\n  ulDOM = [\"ul\", 0],\n  liDOM = [\"li\", 0];\n/**\r\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\r\nattribute, `order`, which determines the number at which the list\r\nstarts counting, and defaults to 1. Represented as an `<ol>`\r\nelement.\r\n*/\nvar orderedList = {\n  attrs: {\n    order: {\n      default: 1\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n    getAttrs: function getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n  }],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n};\n/**\r\nA bullet list node spec, represented in the DOM as `<ul>`.\r\n*/\nvar bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n  toDOM: function toDOM() {\n    return ulDOM;\n  }\n};\n/**\r\nA list item (`<li>`) spec.\r\n*/\nvar listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n  toDOM: function toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  for (var _prop in props) copy[_prop] = props[_prop];\n  return copy;\n}\n/**\r\nConvenience function for adding list-related node types to a map\r\nspecifying the nodes for a schema. Adds\r\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\r\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\r\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\r\n\r\n`itemContent` determines the content expression for the list items.\r\nIf you want the commands defined in this module to apply to your\r\nlist structure, it should have a shape like `\"paragraph block*\"` or\r\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\r\ngiven to assign a group name to the list node types, for example\r\n`\"block\"`.\r\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n}\n/**\r\nReturns a command function that wraps the selection in a list with\r\nthe given type an attributes. If `dispatch` is null, only return a\r\nvalue to indicate whether this is possible, but don't actually\r\nperform the change.\r\n*/\nfunction wrapInList(listType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var _state$selection = state.selection,\n      $from = _state$selection.$from,\n      $to = _state$selection.$to;\n    var range = $from.blockRange($to),\n      doJoin = false,\n      outerRange = range;\n    if (!range) return false;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) return false;\n      var $insert = state.doc.resolve(range.start - 2);\n      outerRange = new NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount) range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n      doJoin = true;\n    }\n    var wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap) return false;\n    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n    return true;\n  };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n  var found = 0;\n  for (var _i = 0; _i < wrappers.length; _i++) if (wrappers[_i].type == listType) found = _i + 1;\n  var splitDepth = wrappers.length - found;\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n    parent = range.parent;\n  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(_i2).nodeSize;\n  }\n  return tr;\n}\n/**\r\nBuild a command that splits a non-empty textblock at the top level\r\nof a list item by also splitting that list item.\r\n*/\nfunction splitListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection2 = state.selection,\n      $from = _state$selection2.$from,\n      $to = _state$selection2.$to,\n      node = _state$selection2.node;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n      if (dispatch) {\n        var wrap = Fragment.empty;\n        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap));\n        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        var start = $from.before($from.depth - (depthBefore - 1));\n        var _tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n        var sel = -1;\n        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {\n          if (sel > -1) return false;\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n        });\n        if (sel > -1) _tr.setSelection(Selection.near(_tr.doc.resolve(sel)));\n        dispatch(_tr.scrollIntoView());\n      }\n      return true;\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr.delete($from.pos, $to.pos);\n    var types = nextType ? [null, {\n      type: nextType\n    }] : undefined;\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/**\r\nCreate a command to lift the list item around the selection up into\r\na wrapping list.\r\n*/\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection3 = state.selection,\n      $from = _state$selection3.$from,\n      $to = _state$selection3.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    if (!dispatch) return true;\n    if ($from.node(range.depth - 1).type == itemType)\n      // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range);else\n      // Outer list node\n      return liftOutOfList(state, dispatch, range);\n  };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr,\n    end = range.end,\n    endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  var target = liftTarget(range);\n  if (target == null) return false;\n  tr.lift(range, target);\n  var after = tr.mapping.map(end, -1) - 1;\n  if (canJoin(tr.doc, after)) tr.join(after);\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr,\n    list = range.parent;\n  // Merge the list items into a single big item\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start),\n    item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n  var atStart = range.startIndex == 0,\n    atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1),\n    indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list)))) return false;\n  var start = $start.pos,\n    end = start + item.nodeSize;\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\n/**\r\nCreate a command to sink the list item around the selection down\r\ninto an inner list.\r\n*/\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection4 = state.selection,\n      $from = _state$selection4.$from,\n      $to = _state$selection4.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    var startIndex = range.startIndex;\n    if (startIndex == 0) return false;\n    var parent = range.parent,\n      nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) return false;\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      var before = range.start,\n        after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n    return true;\n  };\n}\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };","map":{"version":3,"names":["findWrapping","ReplaceAroundStep","canSplit","liftTarget","canJoin","NodeRange","Fragment","Slice","Selection","olDOM","ulDOM","liDOM","orderedList","attrs","order","default","parseDOM","tag","getAttrs","dom","hasAttribute","getAttribute","toDOM","node","start","bulletList","listItem","defining","add","obj","props","copy","prop","addListNodes","nodes","itemContent","listGroup","append","ordered_list","content","group","bullet_list","list_item","wrapInList","listType","state","dispatch","selection","$from","$to","range","blockRange","doJoin","outerRange","depth","type","compatibleContent","startIndex","index","$insert","doc","resolve","endIndex","parent","childCount","end","wrap","doWrapInList","tr","scrollIntoView","wrappers","joinBefore","empty","i","length","from","create","step","found","splitDepth","splitPos","e","first","split","child","nodeSize","splitListItem","itemType","isBlock","sameParent","grandParent","size","indexAfter","depthBefore","d","depthAfter","createAndFill","before","replace","after","sel","nodesBetween","pos","isTextblock","setSelection","near","nextType","contentMatchAt","defaultType","delete","types","undefined","liftListItem","firstChild","liftToOuterList","liftOutOfList","endOfList","target","lift","mapping","map","join","list","$start","item","nodeAfter","atStart","atEnd","indexBefore","canReplace","sinkListItem","nodeBefore","nestedBefore","lastChild","inner","slice"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/prosemirror-schema-list/dist/index.js"],"sourcesContent":["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\r\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\r\nimport { Selection } from 'prosemirror-state';\r\n\r\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\r\n/**\r\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\r\nattribute, `order`, which determines the number at which the list\r\nstarts counting, and defaults to 1. Represented as an `<ol>`\r\nelement.\r\n*/\r\nconst orderedList = {\r\n    attrs: { order: { default: 1 } },\r\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\r\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\r\n            } }],\r\n    toDOM(node) {\r\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\r\n    }\r\n};\r\n/**\r\nA bullet list node spec, represented in the DOM as `<ul>`.\r\n*/\r\nconst bulletList = {\r\n    parseDOM: [{ tag: \"ul\" }],\r\n    toDOM() { return ulDOM; }\r\n};\r\n/**\r\nA list item (`<li>`) spec.\r\n*/\r\nconst listItem = {\r\n    parseDOM: [{ tag: \"li\" }],\r\n    toDOM() { return liDOM; },\r\n    defining: true\r\n};\r\nfunction add(obj, props) {\r\n    let copy = {};\r\n    for (let prop in obj)\r\n        copy[prop] = obj[prop];\r\n    for (let prop in props)\r\n        copy[prop] = props[prop];\r\n    return copy;\r\n}\r\n/**\r\nConvenience function for adding list-related node types to a map\r\nspecifying the nodes for a schema. Adds\r\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\r\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\r\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\r\n\r\n`itemContent` determines the content expression for the list items.\r\nIf you want the commands defined in this module to apply to your\r\nlist structure, it should have a shape like `\"paragraph block*\"` or\r\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\r\ngiven to assign a group name to the list node types, for example\r\n`\"block\"`.\r\n*/\r\nfunction addListNodes(nodes, itemContent, listGroup) {\r\n    return nodes.append({\r\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\r\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\r\n        list_item: add(listItem, { content: itemContent })\r\n    });\r\n}\r\n/**\r\nReturns a command function that wraps the selection in a list with\r\nthe given type an attributes. If `dispatch` is null, only return a\r\nvalue to indicate whether this is possible, but don't actually\r\nperform the change.\r\n*/\r\nfunction wrapInList(listType, attrs = null) {\r\n    return function (state, dispatch) {\r\n        let { $from, $to } = state.selection;\r\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\r\n        if (!range)\r\n            return false;\r\n        // This is at the top of an existing list item\r\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\r\n            // Don't do anything if this is the top of the list\r\n            if ($from.index(range.depth - 1) == 0)\r\n                return false;\r\n            let $insert = state.doc.resolve(range.start - 2);\r\n            outerRange = new NodeRange($insert, $insert, range.depth);\r\n            if (range.endIndex < range.parent.childCount)\r\n                range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\r\n            doJoin = true;\r\n        }\r\n        let wrap = findWrapping(outerRange, listType, attrs, range);\r\n        if (!wrap)\r\n            return false;\r\n        if (dispatch)\r\n            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\r\n        return true;\r\n    };\r\n}\r\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\r\n    let content = Fragment.empty;\r\n    for (let i = wrappers.length - 1; i >= 0; i--)\r\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\r\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\r\n    let found = 0;\r\n    for (let i = 0; i < wrappers.length; i++)\r\n        if (wrappers[i].type == listType)\r\n            found = i + 1;\r\n    let splitDepth = wrappers.length - found;\r\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\r\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\r\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\r\n            tr.split(splitPos, splitDepth);\r\n            splitPos += 2 * splitDepth;\r\n        }\r\n        splitPos += parent.child(i).nodeSize;\r\n    }\r\n    return tr;\r\n}\r\n/**\r\nBuild a command that splits a non-empty textblock at the top level\r\nof a list item by also splitting that list item.\r\n*/\r\nfunction splitListItem(itemType) {\r\n    return function (state, dispatch) {\r\n        let { $from, $to, node } = state.selection;\r\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\r\n            return false;\r\n        let grandParent = $from.node(-1);\r\n        if (grandParent.type != itemType)\r\n            return false;\r\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\r\n            // In an empty block. If this is a nested list, the wrapping\r\n            // list item should be split. Otherwise, bail out and let next\r\n            // command handle lifting.\r\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\r\n                $from.index(-2) != $from.node(-2).childCount - 1)\r\n                return false;\r\n            if (dispatch) {\r\n                let wrap = Fragment.empty;\r\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\r\n                // Build a fragment containing empty versions of the structure\r\n                // from the outer list item to the parent node of the cursor\r\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\r\n                    wrap = Fragment.from($from.node(d).copy(wrap));\r\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\r\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\r\n                // Add a second list item with an empty default start node\r\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\r\n                let start = $from.before($from.depth - (depthBefore - 1));\r\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\r\n                let sel = -1;\r\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\r\n                    if (sel > -1)\r\n                        return false;\r\n                    if (node.isTextblock && node.content.size == 0)\r\n                        sel = pos + 1;\r\n                });\r\n                if (sel > -1)\r\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\r\n                dispatch(tr.scrollIntoView());\r\n            }\r\n            return true;\r\n        }\r\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\r\n        let tr = state.tr.delete($from.pos, $to.pos);\r\n        let types = nextType ? [null, { type: nextType }] : undefined;\r\n        if (!canSplit(tr.doc, $from.pos, 2, types))\r\n            return false;\r\n        if (dispatch)\r\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\r\n        return true;\r\n    };\r\n}\r\n/**\r\nCreate a command to lift the list item around the selection up into\r\na wrapping list.\r\n*/\r\nfunction liftListItem(itemType) {\r\n    return function (state, dispatch) {\r\n        let { $from, $to } = state.selection;\r\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\r\n        if (!range)\r\n            return false;\r\n        if (!dispatch)\r\n            return true;\r\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\r\n            return liftToOuterList(state, dispatch, itemType, range);\r\n        else // Outer list node\r\n            return liftOutOfList(state, dispatch, range);\r\n    };\r\n}\r\nfunction liftToOuterList(state, dispatch, itemType, range) {\r\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\r\n    if (end < endOfList) {\r\n        // There are siblings after the lifted items, which must become\r\n        // children of the last item\r\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\r\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\r\n    }\r\n    const target = liftTarget(range);\r\n    if (target == null)\r\n        return false;\r\n    tr.lift(range, target);\r\n    let after = tr.mapping.map(end, -1) - 1;\r\n    if (canJoin(tr.doc, after))\r\n        tr.join(after);\r\n    dispatch(tr.scrollIntoView());\r\n    return true;\r\n}\r\nfunction liftOutOfList(state, dispatch, range) {\r\n    let tr = state.tr, list = range.parent;\r\n    // Merge the list items into a single big item\r\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\r\n        pos -= list.child(i).nodeSize;\r\n        tr.delete(pos - 1, pos + 1);\r\n    }\r\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\r\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\r\n        return false;\r\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\r\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\r\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\r\n        return false;\r\n    let start = $start.pos, end = start + item.nodeSize;\r\n    // Strip off the surrounding list. At the sides where we're not at\r\n    // the end of the list, the existing list is closed. At sides where\r\n    // this is the end, it is overwritten to its end.\r\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\r\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\r\n    dispatch(tr.scrollIntoView());\r\n    return true;\r\n}\r\n/**\r\nCreate a command to sink the list item around the selection down\r\ninto an inner list.\r\n*/\r\nfunction sinkListItem(itemType) {\r\n    return function (state, dispatch) {\r\n        let { $from, $to } = state.selection;\r\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\r\n        if (!range)\r\n            return false;\r\n        let startIndex = range.startIndex;\r\n        if (startIndex == 0)\r\n            return false;\r\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\r\n        if (nodeBefore.type != itemType)\r\n            return false;\r\n        if (dispatch) {\r\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\r\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\r\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\r\n            let before = range.start, after = range.end;\r\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\r\n                .scrollIntoView());\r\n        }\r\n        return true;\r\n    };\r\n}\r\n\r\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}