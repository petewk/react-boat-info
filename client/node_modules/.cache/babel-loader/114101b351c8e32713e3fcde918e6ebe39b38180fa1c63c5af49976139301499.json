{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    const list = this.getParentOrThrow();\n    if ($isListNode(list)) {\n      const childrenKeys = list.getChildrenKeys();\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n      if (includeChildren) {\n        this.getChildren().forEach(child => {\n          replaceWithNode.append(child);\n        });\n      }\n      this.remove();\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    }\n\n    // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n      return child;\n    }\n\n    // Otherwise, split the list\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter(_) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const currentNode = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\r\n * This function normalizes the children of a ListNode after the conversion from HTML,\r\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\r\n * or some other inline content.\r\n */\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;","map":{"version":3,"names":["lexical","require","utils","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","$getListItemValue","value","getStart","siblings","getPreviousSiblings","sibling","insertList","editor","listType","update","selection","$getSelection","$isRangeSelection","DEPRECATED_$isGridSelection","getNodes","anchor","getNode","anchorNodeParent","$createListNode","$isRootOrShadowRoot","replace","$isElementNode","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","Set","isEmpty","has","getKey","createListOrMerge","$isLeafNode","parentKey","newListNode","updateChildrenListItemValue","add","nextParent","nodesToAppend","splice","previousSibling","nextSibling","getListType","getFirstChildOrThrow","insertBefore","removeList","listNodes","$getNearestNodeOfType","ListItemNode","insertionPoint","listItems","paragraph","$createParagraphNode","insertAfter","__key","key","set","focus","children","childrenOrExisting","undefined","child","prevValue","getValue","nextValue","setValue","$handleIndent","removed","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","getLastChild","previousSiblingsListItem","previousSiblingsList","forEach","nextSiblingsListItem","nextSiblingsList","getNextSiblings","$handleListInsertParagraph","isCollapsed","getTextContent","topListNode","grandparent","replacementNode","select","nextSiblings","$isParagraphNode","ElementNode","getType","clone","__value","__checked","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","importDOM","li","conversion","convertListItemElement","priority","importJSON","serializedNode","format","indent","setDirection","direction","exportJSON","getChecked","type","version","canMergeWith","replaceWithNode","includeChildren","childrenKeys","getChildrenKeys","childrenLength","index","indexOf","restoreSelection","after","afterListNode","preserveEmptyParent","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","offset","self","getLatest","getWritable","setChecked","toggleChecked","__indent","indentLevel","currentIndent","nodeToInsert","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","isParentRequired","createParentElementNode","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","listItemClasses","split","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","removeClassNamesFromElement","addClassNamesToElement","prevListItemNode","removeAttribute","setAttribute","domNode","isHTMLElement","getAttribute","$applyNodeReplacement","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","_editor","tag","String","__lexicalListType","setListThemeClassNames","ol","convertListNode","ul","exportDOM","canBeEmpty","canIndent","currentNode","textNode","$createTextNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","normalizeChildren","normalizedListItems","nodeName","toLowerCase","INSERT_UNORDERED_LIST_COMMAND","createCommand","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/list/LexicalList.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\nvar utils = require('@lexical/utils');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $getListDepth(listNode) {\r\n  let depth = 1;\r\n  let parent = listNode.getParent();\r\n  while (parent != null) {\r\n    if ($isListItemNode(parent)) {\r\n      const parentList = parent.getParent();\r\n      if ($isListNode(parentList)) {\r\n        depth++;\r\n        parent = parentList.getParent();\r\n        continue;\r\n      }\r\n      {\r\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n      }\r\n    }\r\n    return depth;\r\n  }\r\n  return depth;\r\n}\r\nfunction $getTopListNode(listItem) {\r\n  let list = listItem.getParent();\r\n  if (!$isListNode(list)) {\r\n    {\r\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n    }\r\n  }\r\n  let parent = list;\r\n  while (parent !== null) {\r\n    parent = parent.getParent();\r\n    if ($isListNode(parent)) {\r\n      list = parent;\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\n// This should probably be $getAllChildrenOfType\r\nfunction $getAllListItems(node) {\r\n  let listItemNodes = [];\r\n  const listChildren = node.getChildren().filter($isListItemNode);\r\n  for (let i = 0; i < listChildren.length; i++) {\r\n    const listItemNode = listChildren[i];\r\n    const firstChild = listItemNode.getFirstChild();\r\n    if ($isListNode(firstChild)) {\r\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\r\n    } else {\r\n      listItemNodes.push(listItemNode);\r\n    }\r\n  }\r\n  return listItemNodes;\r\n}\r\nfunction isNestedListNode(node) {\r\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\r\n}\r\nfunction $removeHighestEmptyListParent(sublist) {\r\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\r\n  // contain just one bullet.\r\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\r\n  // way to do that is crawl back up the tree until we find a node that has siblings\r\n  // (e.g. is actually part of the list contents) and delete that, or delete\r\n  // the root of the list (if no list nodes have siblings.)\r\n  let emptyListPtr = sublist;\r\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\r\n    const parent = emptyListPtr.getParent();\r\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\r\n      break;\r\n    }\r\n    emptyListPtr = parent;\r\n  }\r\n  emptyListPtr.remove();\r\n}\r\nfunction wrapInListItem(node) {\r\n  const listItemWrapper = $createListItemNode();\r\n  return listItemWrapper.append(node);\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\r\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\r\n}\r\nfunction $getListItemValue(listItem) {\r\n  const list = listItem.getParent();\r\n  let value = 1;\r\n  if (list != null) {\r\n    if (!$isListNode(list)) {\r\n      {\r\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\r\n      }\r\n    } else {\r\n      value = list.getStart();\r\n    }\r\n  }\r\n  const siblings = listItem.getPreviousSiblings();\r\n  for (let i = 0; i < siblings.length; i++) {\r\n    const sibling = siblings[i];\r\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\r\n      value++;\r\n    }\r\n  }\r\n  return value;\r\n}\r\nfunction insertList(editor, listType) {\r\n  editor.update(() => {\r\n    const selection = lexical.$getSelection();\r\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\r\n      const nodes = selection.getNodes();\r\n      const anchor = selection.anchor;\r\n      const anchorNode = anchor.getNode();\r\n      const anchorNodeParent = anchorNode.getParent();\r\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\r\n        const list = $createListNode(listType);\r\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\r\n          anchorNode.replace(list);\r\n          const listItem = $createListItemNode();\r\n          if (lexical.$isElementNode(anchorNode)) {\r\n            listItem.setFormat(anchorNode.getFormatType());\r\n            listItem.setIndent(anchorNode.getIndent());\r\n          }\r\n          list.append(listItem);\r\n        } else if ($isListItemNode(anchorNode)) {\r\n          const parent = anchorNode.getParentOrThrow();\r\n          append(list, parent.getChildren());\r\n          parent.replace(list);\r\n        }\r\n        return;\r\n      } else {\r\n        const handled = new Set();\r\n        for (let i = 0; i < nodes.length; i++) {\r\n          const node = nodes[i];\r\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\r\n            createListOrMerge(node, listType);\r\n            continue;\r\n          }\r\n          if (lexical.$isLeafNode(node)) {\r\n            let parent = node.getParent();\r\n            while (parent != null) {\r\n              const parentKey = parent.getKey();\r\n              if ($isListNode(parent)) {\r\n                if (!handled.has(parentKey)) {\r\n                  const newListNode = $createListNode(listType);\r\n                  append(newListNode, parent.getChildren());\r\n                  parent.replace(newListNode);\r\n                  updateChildrenListItemValue(newListNode);\r\n                  handled.add(parentKey);\r\n                }\r\n                break;\r\n              } else {\r\n                const nextParent = parent.getParent();\r\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\r\n                  handled.add(parentKey);\r\n                  createListOrMerge(parent, listType);\r\n                  break;\r\n                }\r\n                parent = nextParent;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction append(node, nodesToAppend) {\r\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\r\n}\r\nfunction createListOrMerge(node, listType) {\r\n  if ($isListNode(node)) {\r\n    return node;\r\n  }\r\n  const previousSibling = node.getPreviousSibling();\r\n  const nextSibling = node.getNextSibling();\r\n  const listItem = $createListItemNode();\r\n  listItem.setFormat(node.getFormatType());\r\n  listItem.setIndent(node.getIndent());\r\n  append(listItem, node.getChildren());\r\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\r\n    previousSibling.append(listItem);\r\n    node.remove();\r\n    // if the same type of list is on both sides, merge them.\r\n\r\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\r\n      append(previousSibling, nextSibling.getChildren());\r\n      nextSibling.remove();\r\n    }\r\n    return previousSibling;\r\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\r\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\r\n    node.remove();\r\n    return nextSibling;\r\n  } else {\r\n    const list = $createListNode(listType);\r\n    list.append(listItem);\r\n    node.replace(list);\r\n    updateChildrenListItemValue(list);\r\n    return list;\r\n  }\r\n}\r\nfunction removeList(editor) {\r\n  editor.update(() => {\r\n    const selection = lexical.$getSelection();\r\n    if (lexical.$isRangeSelection(selection)) {\r\n      const listNodes = new Set();\r\n      const nodes = selection.getNodes();\r\n      const anchorNode = selection.anchor.getNode();\r\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\r\n        listNodes.add($getTopListNode(anchorNode));\r\n      } else {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n          const node = nodes[i];\r\n          if (lexical.$isLeafNode(node)) {\r\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\r\n            if (listItemNode != null) {\r\n              listNodes.add($getTopListNode(listItemNode));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      for (const listNode of listNodes) {\r\n        let insertionPoint = listNode;\r\n        const listItems = $getAllListItems(listNode);\r\n        for (const listItemNode of listItems) {\r\n          const paragraph = lexical.$createParagraphNode();\r\n          append(paragraph, listItemNode.getChildren());\r\n          insertionPoint.insertAfter(paragraph);\r\n          insertionPoint = paragraph;\r\n\r\n          // When the anchor and focus fall on the textNode\r\n          // we don't have to change the selection because the textNode will be appended to\r\n          // the newly generated paragraph.\r\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\r\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\r\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\r\n          if (listItemNode.__key === selection.anchor.key) {\r\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\r\n          }\r\n          if (listItemNode.__key === selection.focus.key) {\r\n            selection.focus.set(paragraph.getKey(), 0, 'element');\r\n          }\r\n          listItemNode.remove();\r\n        }\r\n        listNode.remove();\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction updateChildrenListItemValue(list, children) {\r\n  const childrenOrExisting = children || list.getChildren();\r\n  if (childrenOrExisting !== undefined) {\r\n    for (let i = 0; i < childrenOrExisting.length; i++) {\r\n      const child = childrenOrExisting[i];\r\n      if ($isListItemNode(child)) {\r\n        const prevValue = child.getValue();\r\n        const nextValue = $getListItemValue(child);\r\n        if (prevValue !== nextValue) {\r\n          child.setValue(nextValue);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $handleIndent(listItemNode) {\r\n  // go through each node and decide where to move it.\r\n  const removed = new Set();\r\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\r\n    return;\r\n  }\r\n  const parent = listItemNode.getParent();\r\n\r\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\r\n  const nextSibling = listItemNode.getNextSibling();\r\n  const previousSibling = listItemNode.getPreviousSibling();\r\n  // if there are nested lists on either side, merge them all together.\r\n\r\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\r\n    const innerList = previousSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      innerList.append(listItemNode);\r\n      const nextInnerList = nextSibling.getFirstChild();\r\n      if ($isListNode(nextInnerList)) {\r\n        const children = nextInnerList.getChildren();\r\n        append(innerList, children);\r\n        nextSibling.remove();\r\n        removed.add(nextSibling.getKey());\r\n      }\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else if (isNestedListNode(nextSibling)) {\r\n    // if the ListItemNode is next to a nested ListNode, merge them\r\n    const innerList = nextSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      const firstChild = innerList.getFirstChild();\r\n      if (firstChild !== null) {\r\n        firstChild.insertBefore(listItemNode);\r\n      }\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else if (isNestedListNode(previousSibling)) {\r\n    const innerList = previousSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      innerList.append(listItemNode);\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else {\r\n    // otherwise, we need to create a new nested ListNode\r\n\r\n    if ($isListNode(parent)) {\r\n      const newListItem = $createListItemNode();\r\n      const newList = $createListNode(parent.getListType());\r\n      newListItem.append(newList);\r\n      newList.append(listItemNode);\r\n      if (previousSibling) {\r\n        previousSibling.insertAfter(newListItem);\r\n      } else if (nextSibling) {\r\n        nextSibling.insertBefore(newListItem);\r\n      } else {\r\n        parent.append(newListItem);\r\n      }\r\n    }\r\n  }\r\n  if ($isListNode(parent)) {\r\n    updateChildrenListItemValue(parent);\r\n  }\r\n}\r\nfunction $handleOutdent(listItemNode) {\r\n  // go through each node and decide where to move it.\r\n\r\n  if (isNestedListNode(listItemNode)) {\r\n    return;\r\n  }\r\n  const parentList = listItemNode.getParent();\r\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\r\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\r\n  // If it doesn't have these ancestors, it's not indented.\r\n\r\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\r\n    // if it's the first child in it's parent list, insert it into the\r\n    // great grandparent list before the grandparent\r\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\r\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\r\n    if (listItemNode.is(firstChild)) {\r\n      grandparentListItem.insertBefore(listItemNode);\r\n      if (parentList.isEmpty()) {\r\n        grandparentListItem.remove();\r\n      }\r\n      // if it's the last child in it's parent list, insert it into the\r\n      // great grandparent list after the grandparent.\r\n    } else if (listItemNode.is(lastChild)) {\r\n      grandparentListItem.insertAfter(listItemNode);\r\n      if (parentList.isEmpty()) {\r\n        grandparentListItem.remove();\r\n      }\r\n    } else {\r\n      // otherwise, we need to split the siblings into two new nested lists\r\n      const listType = parentList.getListType();\r\n      const previousSiblingsListItem = $createListItemNode();\r\n      const previousSiblingsList = $createListNode(listType);\r\n      previousSiblingsListItem.append(previousSiblingsList);\r\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\r\n      const nextSiblingsListItem = $createListItemNode();\r\n      const nextSiblingsList = $createListNode(listType);\r\n      nextSiblingsListItem.append(nextSiblingsList);\r\n      append(nextSiblingsList, listItemNode.getNextSiblings());\r\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\r\n      grandparentListItem.insertBefore(previousSiblingsListItem);\r\n      grandparentListItem.insertAfter(nextSiblingsListItem);\r\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\r\n      grandparentListItem.replace(listItemNode);\r\n    }\r\n    updateChildrenListItemValue(parentList);\r\n    updateChildrenListItemValue(greatGrandparentList);\r\n  }\r\n}\r\nfunction $handleListInsertParagraph() {\r\n  const selection = lexical.$getSelection();\r\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\r\n    return false;\r\n  }\r\n  // Only run this code on empty list items\r\n  const anchor = selection.anchor.getNode();\r\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\r\n    return false;\r\n  }\r\n  const topListNode = $getTopListNode(anchor);\r\n  const parent = anchor.getParent();\r\n  if (!$isListNode(parent)) {\r\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n  }\r\n  const grandparent = parent.getParent();\r\n  let replacementNode;\r\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\r\n    replacementNode = lexical.$createParagraphNode();\r\n    topListNode.insertAfter(replacementNode);\r\n  } else if ($isListItemNode(grandparent)) {\r\n    replacementNode = $createListItemNode();\r\n    grandparent.insertAfter(replacementNode);\r\n  } else {\r\n    return false;\r\n  }\r\n  replacementNode.select();\r\n  const nextSiblings = anchor.getNextSiblings();\r\n  if (nextSiblings.length > 0) {\r\n    const newList = $createListNode(parent.getListType());\r\n    if (lexical.$isParagraphNode(replacementNode)) {\r\n      replacementNode.insertAfter(newList);\r\n    } else {\r\n      const newListItem = $createListItemNode();\r\n      newListItem.append(newList);\r\n      replacementNode.insertAfter(newListItem);\r\n    }\r\n    nextSiblings.forEach(sibling => {\r\n      sibling.remove();\r\n      newList.append(sibling);\r\n    });\r\n  }\r\n\r\n  // Don't leave hanging nested empty lists\r\n  $removeHighestEmptyListParent(anchor);\r\n  return true;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ListItemNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'listitem';\r\n  }\r\n  static clone(node) {\r\n    return new ListItemNode(node.__value, node.__checked, node.__key);\r\n  }\r\n  constructor(value, checked, key) {\r\n    super(key);\r\n    this.__value = value === undefined ? 1 : value;\r\n    this.__checked = checked;\r\n  }\r\n  createDOM(config) {\r\n    const element = document.createElement('li');\r\n    const parent = this.getParent();\r\n    if ($isListNode(parent)) {\r\n      updateChildrenListItemValue(parent);\r\n      updateListItemChecked(element, this, null, parent);\r\n    }\r\n    element.value = this.__value;\r\n    $setListItemThemeClassNames(element, config.theme, this);\r\n    return element;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    const parent = this.getParent();\r\n    if ($isListNode(parent)) {\r\n      updateChildrenListItemValue(parent);\r\n      updateListItemChecked(dom, this, prevNode, parent);\r\n    }\r\n    // @ts-expect-error - this is always HTMLListItemElement\r\n    dom.value = this.__value;\r\n    $setListItemThemeClassNames(dom, config.theme, this);\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      li: node => ({\r\n        conversion: convertListItemElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      checked: this.getChecked(),\r\n      type: 'listitem',\r\n      value: this.getValue(),\r\n      version: 1\r\n    };\r\n  }\r\n  append(...nodes) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\r\n        const children = node.getChildren();\r\n        this.append(...children);\r\n        node.remove();\r\n      } else {\r\n        super.append(node);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  replace(replaceWithNode, includeChildren) {\r\n    if ($isListItemNode(replaceWithNode)) {\r\n      return super.replace(replaceWithNode);\r\n    }\r\n    const list = this.getParentOrThrow();\r\n    if ($isListNode(list)) {\r\n      const childrenKeys = list.getChildrenKeys();\r\n      const childrenLength = childrenKeys.length;\r\n      const index = childrenKeys.indexOf(this.__key);\r\n      if (index === 0) {\r\n        list.insertBefore(replaceWithNode);\r\n      } else if (index === childrenLength - 1) {\r\n        list.insertAfter(replaceWithNode);\r\n      } else {\r\n        // Split the list\r\n        const newList = $createListNode(list.getListType());\r\n        const children = list.getChildren();\r\n        for (let i = index + 1; i < childrenLength; i++) {\r\n          const child = children[i];\r\n          newList.append(child);\r\n        }\r\n        list.insertAfter(replaceWithNode);\r\n        replaceWithNode.insertAfter(newList);\r\n      }\r\n      if (includeChildren) {\r\n        this.getChildren().forEach(child => {\r\n          replaceWithNode.append(child);\r\n        });\r\n      }\r\n      this.remove();\r\n      if (childrenLength === 1) {\r\n        list.remove();\r\n      }\r\n    }\r\n    return replaceWithNode;\r\n  }\r\n  insertAfter(node, restoreSelection = true) {\r\n    const listNode = this.getParentOrThrow();\r\n    if (!$isListNode(listNode)) {\r\n      {\r\n        throw Error(`insertAfter: list node is not parent of list item node`);\r\n      }\r\n    }\r\n    const siblings = this.getNextSiblings();\r\n    if ($isListItemNode(node)) {\r\n      const after = super.insertAfter(node, restoreSelection);\r\n      const afterListNode = node.getParentOrThrow();\r\n      if ($isListNode(afterListNode)) {\r\n        updateChildrenListItemValue(afterListNode);\r\n      }\r\n      return after;\r\n    }\r\n\r\n    // Attempt to merge if the list is of the same type.\r\n\r\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\r\n      let child = node;\r\n      const children = node.getChildren();\r\n      for (let i = children.length - 1; i >= 0; i--) {\r\n        child = children[i];\r\n        this.insertAfter(child, restoreSelection);\r\n      }\r\n      return child;\r\n    }\r\n\r\n    // Otherwise, split the list\r\n    // Split the lists and insert the node in between them\r\n    listNode.insertAfter(node, restoreSelection);\r\n    if (siblings.length !== 0) {\r\n      const newListNode = $createListNode(listNode.getListType());\r\n      siblings.forEach(sibling => newListNode.append(sibling));\r\n      node.insertAfter(newListNode, restoreSelection);\r\n    }\r\n    return node;\r\n  }\r\n  remove(preserveEmptyParent) {\r\n    const nextSibling = this.getNextSibling();\r\n    super.remove(preserveEmptyParent);\r\n    if (nextSibling !== null) {\r\n      const parent = nextSibling.getParent();\r\n      if ($isListNode(parent)) {\r\n        updateChildrenListItemValue(parent);\r\n      }\r\n    }\r\n  }\r\n  insertNewAfter(_, restoreSelection = true) {\r\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\r\n    this.insertAfter(newElement, restoreSelection);\r\n    return newElement;\r\n  }\r\n  collapseAtStart(selection) {\r\n    const paragraph = lexical.$createParagraphNode();\r\n    const children = this.getChildren();\r\n    children.forEach(child => paragraph.append(child));\r\n    const listNode = this.getParentOrThrow();\r\n    const listNodeParent = listNode.getParentOrThrow();\r\n    const isIndented = $isListItemNode(listNodeParent);\r\n    if (listNode.getChildrenSize() === 1) {\r\n      if (isIndented) {\r\n        // if the list node is nested, we just want to remove it,\r\n        // effectively unindenting it.\r\n        listNode.remove();\r\n        listNodeParent.select();\r\n      } else {\r\n        listNode.insertBefore(paragraph);\r\n        listNode.remove();\r\n        // If we have selection on the list item, we'll need to move it\r\n        // to the paragraph\r\n        const anchor = selection.anchor;\r\n        const focus = selection.focus;\r\n        const key = paragraph.getKey();\r\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\r\n          anchor.set(key, anchor.offset, 'element');\r\n        }\r\n        if (focus.type === 'element' && focus.getNode().is(this)) {\r\n          focus.set(key, focus.offset, 'element');\r\n        }\r\n      }\r\n    } else {\r\n      listNode.insertBefore(paragraph);\r\n      this.remove();\r\n    }\r\n    return true;\r\n  }\r\n  getValue() {\r\n    const self = this.getLatest();\r\n    return self.__value;\r\n  }\r\n  setValue(value) {\r\n    const self = this.getWritable();\r\n    self.__value = value;\r\n  }\r\n  getChecked() {\r\n    const self = this.getLatest();\r\n    return self.__checked;\r\n  }\r\n  setChecked(checked) {\r\n    const self = this.getWritable();\r\n    self.__checked = checked;\r\n  }\r\n  toggleChecked() {\r\n    this.setChecked(!this.__checked);\r\n  }\r\n  getIndent() {\r\n    // If we don't have a parent, we are likely serializing\r\n    const parent = this.getParent();\r\n    if (parent === null) {\r\n      return this.getLatest().__indent;\r\n    }\r\n    // ListItemNode should always have a ListNode for a parent.\r\n    let listNodeParent = parent.getParentOrThrow();\r\n    let indentLevel = 0;\r\n    while ($isListItemNode(listNodeParent)) {\r\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\r\n      indentLevel++;\r\n    }\r\n    return indentLevel;\r\n  }\r\n  setIndent(indent) {\r\n    let currentIndent = this.getIndent();\r\n    while (currentIndent !== indent) {\r\n      if (currentIndent < indent) {\r\n        $handleIndent(this);\r\n        currentIndent++;\r\n      } else {\r\n        $handleOutdent(this);\r\n        currentIndent--;\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  insertBefore(nodeToInsert) {\r\n    if ($isListItemNode(nodeToInsert)) {\r\n      const parent = this.getParentOrThrow();\r\n      if ($isListNode(parent)) {\r\n        const siblings = this.getNextSiblings();\r\n        updateChildrenListItemValue(parent, siblings);\r\n      }\r\n    }\r\n    return super.insertBefore(nodeToInsert);\r\n  }\r\n  canInsertAfter(node) {\r\n    return $isListItemNode(node);\r\n  }\r\n  canReplaceWith(replacement) {\r\n    return $isListItemNode(replacement);\r\n  }\r\n  canMergeWith(node) {\r\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\r\n  }\r\n  extractWithChild(child, selection) {\r\n    if (!lexical.$isRangeSelection(selection)) {\r\n      return false;\r\n    }\r\n    const anchorNode = selection.anchor.getNode();\r\n    const focusNode = selection.focus.getNode();\r\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\r\n  }\r\n  isParentRequired() {\r\n    return true;\r\n  }\r\n  createParentElementNode() {\r\n    return $createListNode('bullet');\r\n  }\r\n}\r\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\r\n  const classesToAdd = [];\r\n  const classesToRemove = [];\r\n  const listTheme = editorThemeClasses.list;\r\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\r\n  let nestedListItemClassName;\r\n  if (listTheme && listTheme.nested) {\r\n    nestedListItemClassName = listTheme.nested.listitem;\r\n  }\r\n  if (listItemClassName !== undefined) {\r\n    const listItemClasses = listItemClassName.split(' ');\r\n    classesToAdd.push(...listItemClasses);\r\n  }\r\n  if (listTheme) {\r\n    const parentNode = node.getParent();\r\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\r\n    const checked = node.getChecked();\r\n    if (!isCheckList || checked) {\r\n      classesToRemove.push(listTheme.listitemUnchecked);\r\n    }\r\n    if (!isCheckList || !checked) {\r\n      classesToRemove.push(listTheme.listitemChecked);\r\n    }\r\n    if (isCheckList) {\r\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\r\n    }\r\n  }\r\n  if (nestedListItemClassName !== undefined) {\r\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\r\n    if (node.getChildren().some(child => $isListNode(child))) {\r\n      classesToAdd.push(...nestedListItemClasses);\r\n    } else {\r\n      classesToRemove.push(...nestedListItemClasses);\r\n    }\r\n  }\r\n  if (classesToRemove.length > 0) {\r\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\r\n  }\r\n  if (classesToAdd.length > 0) {\r\n    utils.addClassNamesToElement(dom, ...classesToAdd);\r\n  }\r\n}\r\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\r\n  const isCheckList = listNode.getListType() === 'check';\r\n  if (isCheckList) {\r\n    // Only add attributes for leaf list items\r\n    if ($isListNode(listItemNode.getFirstChild())) {\r\n      dom.removeAttribute('role');\r\n      dom.removeAttribute('tabIndex');\r\n      dom.removeAttribute('aria-checked');\r\n    } else {\r\n      dom.setAttribute('role', 'checkbox');\r\n      dom.setAttribute('tabIndex', '-1');\r\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\r\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\r\n      }\r\n    }\r\n  } else {\r\n    // Clean up checked state\r\n    if (listItemNode.getChecked() != null) {\r\n      listItemNode.setChecked(undefined);\r\n    }\r\n  }\r\n}\r\nfunction convertListItemElement(domNode) {\r\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\r\n  return {\r\n    node: $createListItemNode(checked)\r\n  };\r\n}\r\nfunction $createListItemNode(checked) {\r\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\r\n}\r\nfunction $isListItemNode(node) {\r\n  return node instanceof ListItemNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ListNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'list';\r\n  }\r\n  static clone(node) {\r\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\r\n    return new ListNode(listType, node.__start, node.__key);\r\n  }\r\n  constructor(listType, start, key) {\r\n    super(key);\r\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\r\n    this.__listType = _listType;\r\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\r\n    this.__start = start;\r\n  }\r\n  getTag() {\r\n    return this.__tag;\r\n  }\r\n  getListType() {\r\n    return this.__listType;\r\n  }\r\n  getStart() {\r\n    return this.__start;\r\n  }\r\n\r\n  // View\r\n\r\n  createDOM(config, _editor) {\r\n    const tag = this.__tag;\r\n    const dom = document.createElement(tag);\r\n    if (this.__start !== 1) {\r\n      dom.setAttribute('start', String(this.__start));\r\n    }\r\n    // @ts-expect-error Internal field.\r\n    dom.__lexicalListType = this.__listType;\r\n    setListThemeClassNames(dom, config.theme, this);\r\n    return dom;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    if (prevNode.__tag !== this.__tag) {\r\n      return true;\r\n    }\r\n    setListThemeClassNames(dom, config.theme, this);\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      ol: node => ({\r\n        conversion: convertListNode,\r\n        priority: 0\r\n      }),\r\n      ul: node => ({\r\n        conversion: convertListNode,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportDOM(editor) {\r\n    const {\r\n      element\r\n    } = super.exportDOM(editor);\r\n    if (element) {\r\n      if (this.__start !== 1) {\r\n        element.setAttribute('start', String(this.__start));\r\n      }\r\n      if (this.__listType === 'check') {\r\n        element.setAttribute('__lexicalListType', 'check');\r\n      }\r\n    }\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      listType: this.getListType(),\r\n      start: this.getStart(),\r\n      tag: this.getTag(),\r\n      type: 'list',\r\n      version: 1\r\n    };\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  canIndent() {\r\n    return false;\r\n  }\r\n  append(...nodesToAppend) {\r\n    for (let i = 0; i < nodesToAppend.length; i++) {\r\n      const currentNode = nodesToAppend[i];\r\n      if ($isListItemNode(currentNode)) {\r\n        super.append(currentNode);\r\n      } else {\r\n        const listItemNode = $createListItemNode();\r\n        if ($isListNode(currentNode)) {\r\n          listItemNode.append(currentNode);\r\n        } else if (lexical.$isElementNode(currentNode)) {\r\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\r\n          listItemNode.append(textNode);\r\n        } else {\r\n          listItemNode.append(currentNode);\r\n        }\r\n        super.append(listItemNode);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  extractWithChild(child) {\r\n    return $isListItemNode(child);\r\n  }\r\n}\r\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\r\n  const classesToAdd = [];\r\n  const classesToRemove = [];\r\n  const listTheme = editorThemeClasses.list;\r\n  if (listTheme !== undefined) {\r\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\r\n    const listDepth = $getListDepth(node) - 1;\r\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\r\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\r\n    const listClassName = listTheme[node.__tag];\r\n    let nestedListClassName;\r\n    const nestedListTheme = listTheme.nested;\r\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\r\n      nestedListClassName = nestedListTheme.list;\r\n    }\r\n    if (listClassName !== undefined) {\r\n      classesToAdd.push(listClassName);\r\n    }\r\n    if (listLevelClassName !== undefined) {\r\n      const listItemClasses = listLevelClassName.split(' ');\r\n      classesToAdd.push(...listItemClasses);\r\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\r\n        if (i !== normalizedListDepth) {\r\n          classesToRemove.push(node.__tag + i);\r\n        }\r\n      }\r\n    }\r\n    if (nestedListClassName !== undefined) {\r\n      const nestedListItemClasses = nestedListClassName.split(' ');\r\n      if (listDepth > 1) {\r\n        classesToAdd.push(...nestedListItemClasses);\r\n      } else {\r\n        classesToRemove.push(...nestedListItemClasses);\r\n      }\r\n    }\r\n  }\r\n  if (classesToRemove.length > 0) {\r\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\r\n  }\r\n  if (classesToAdd.length > 0) {\r\n    utils.addClassNamesToElement(dom, ...classesToAdd);\r\n  }\r\n}\r\n\r\n/*\r\n * This function normalizes the children of a ListNode after the conversion from HTML,\r\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\r\n * or some other inline content.\r\n */\r\nfunction normalizeChildren(nodes) {\r\n  const normalizedListItems = [];\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if ($isListItemNode(node)) {\r\n      normalizedListItems.push(node);\r\n      const children = node.getChildren();\r\n      if (children.length > 1) {\r\n        children.forEach(child => {\r\n          if ($isListNode(child)) {\r\n            normalizedListItems.push(wrapInListItem(child));\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      normalizedListItems.push(wrapInListItem(node));\r\n    }\r\n  }\r\n  return normalizedListItems;\r\n}\r\nfunction convertListNode(domNode) {\r\n  const nodeName = domNode.nodeName.toLowerCase();\r\n  let node = null;\r\n  if (nodeName === 'ol') {\r\n    node = $createListNode('number');\r\n  } else if (nodeName === 'ul') {\r\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\r\n      node = $createListNode('check');\r\n    } else {\r\n      node = $createListNode('bullet');\r\n    }\r\n  }\r\n  return {\r\n    after: normalizeChildren,\r\n    node\r\n  };\r\n}\r\nconst TAG_TO_LIST_TYPE = {\r\n  ol: 'number',\r\n  ul: 'bullet'\r\n};\r\nfunction $createListNode(listType, start = 1) {\r\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\r\n}\r\nfunction $isListNode(node) {\r\n  return node instanceof ListNode;\r\n}\r\n\r\n/** @module @lexical/list */\r\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\r\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\r\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\r\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\r\n\r\nexports.$createListItemNode = $createListItemNode;\r\nexports.$createListNode = $createListNode;\r\nexports.$getListDepth = $getListDepth;\r\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\r\nexports.$isListItemNode = $isListItemNode;\r\nexports.$isListNode = $isListNode;\r\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\r\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\r\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\r\nexports.ListItemNode = ListItemNode;\r\nexports.ListNode = ListNode;\r\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\r\nexports.insertList = insertList;\r\nexports.removeList = removeList;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}