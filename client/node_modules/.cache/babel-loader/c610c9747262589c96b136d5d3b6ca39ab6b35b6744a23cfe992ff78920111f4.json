{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from '@tiptap/pm/state';\nimport { EditorView } from '@tiptap/pm/view';\nimport { keymap } from '@tiptap/pm/keymap';\nimport { Schema, Fragment, DOMParser, DOMSerializer, Node as Node$1, Slice } from '@tiptap/pm/model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, Transform, canSplit, canJoin, findWrapping } from '@tiptap/pm/transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinUp as joinUp$1, joinDown as joinDown$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from '@tiptap/pm/commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from '@tiptap/pm/schema-list';\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    var _this = this;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(_ref => {\n      let [name, command] = _ref;\n      const method = function () {\n        const callback = command(...arguments)(props);\n        if (!tr.getMeta('preventDispatch') && !_this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr) {\n    var _this2 = this;\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every(callback => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(_ref2 => {\n        let [name, command] = _ref2;\n        const chainedCommand = function () {\n          const props = _this2.buildProps(tr, shouldDispatch);\n          const callback = command(...arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(_ref3 => {\n      let [name, command] = _ref3;\n      return [name, function () {\n        return command(...arguments)({\n          ...props,\n          dispatch: undefined\n        });\n      }];\n    }));\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr) {\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks);\n    }\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(_ref4 => {\n          let [name, command] = _ref4;\n          return [name, function () {\n            return command(...arguments)(props);\n          }];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(_ref5 => {\n          let [name, attribute] = _ref5;\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n    if (!addAttributes) {\n      return;\n    }\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(_ref6 => {\n      let [name, attribute] = _ref6;\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if ((attribute === null || attribute === void 0 ? void 0 : attribute.isRequired) && (attribute === null || attribute === void 0 ? void 0 : attribute.default) === undefined) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes() {\n  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = {\n      ...items\n    };\n    Object.entries(item).forEach(_ref7 => {\n      let [key, value] = _ref7;\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\nfunction callOrReturn(value) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (isFunction(value)) {\n    for (var _len3 = arguments.length, props = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      props[_key3 - 2] = arguments[_key3];\n    }\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return value;\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === undefined) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return {\n        ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(_ref8 => {\n    let [key, value] = _ref8;\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== undefined;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, 'renderText', context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = function ($from) {\n  let maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let textBefore = '';\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || '%leaf%';\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n  // check for code node\n  $from.parent.type.spec.code\n  // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n        const {\n          $cursor\n        } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(pasteRuleMatch => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            return false;\n          },\n          paste: (view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule\n        });\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach(extension => {\n      var _a;\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n      return extension;\n    })\n    // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  get plugins() {\n    const {\n      editor\n    } = this;\n    // With ProseMirror, first plugins within an array are executed first.\n    // In tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n      let defaultBindings = {};\n      // bind exit handling\n      if (extension.type === 'mark' && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({\n          editor,\n          mark: extension\n        });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(_ref9 => {\n          let [shortcut, method] = _ref9;\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        defaultBindings = {\n          ...defaultBindings,\n          ...bindings\n        };\n      }\n      const keyMapPlugin = keymap(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = {\n    ...target\n  };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Extension(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(_ref10 => {\n    let [, node] = _ref10;\n    return node.spec.toText;\n  }).map(_ref11 => {\n    let [name, node] = _ref11;\n    return [name, node.spec.toText];\n  }));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n});\nconst blur = () => _ref12 => {\n  let {\n    editor,\n    view\n  } = _ref12;\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = function () {\n  let emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return _ref13 => {\n    let {\n      commands\n    } = _ref13;\n    return commands.setContent('', emitUpdate);\n  };\n};\nconst clearNodes = () => _ref14 => {\n  let {\n    state,\n    tr,\n    dispatch\n  } = _ref14;\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(_ref15 => {\n    let {\n      $from,\n      $to\n    } = _ref15;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = liftTarget(nodeRange);\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = fn => props => {\n  return fn(props);\n};\nconst createParagraphNear = () => _ref16 => {\n  let {\n    state,\n    dispatch\n  } = _ref16;\n  return createParagraphNear$1(state, dispatch);\n};\nconst deleteCurrentNode = () => _ref17 => {\n  let {\n    tr,\n    dispatch\n  } = _ref17;\n  const {\n    selection\n  } = tr;\n  const currentNode = selection.$anchor.node();\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteNode = typeOrName => _ref18 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref18;\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = range => _ref19 => {\n  let {\n    tr,\n    dispatch\n  } = _ref19;\n  const {\n    from,\n    to\n  } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => _ref20 => {\n  let {\n    state,\n    dispatch\n  } = _ref20;\n  return deleteSelection$1(state, dispatch);\n};\nconst enter = () => _ref21 => {\n  let {\n    commands\n  } = _ref21;\n  return commands.keyboardShortcut('Enter');\n};\nconst exitCode = () => _ref22 => {\n  let {\n    state,\n    dispatch\n  } = _ref22;\n  return exitCode$1(state, dispatch);\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\nfunction objectIncludes(object1, object2) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    strict: true\n  };\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref23 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref23;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      doc,\n      selection\n    } = tr;\n    const {\n      $from,\n      from,\n      to\n    } = selection;\n    if (dispatch) {\n      const range = getMarkRange($from, type, attributes);\n      if (range && range.from <= from && range.to >= to) {\n        const newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n    return true;\n  };\n};\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof TextSelection;\n}\nfunction minMax() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc) {\n  let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\nconst focus = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref24 => {\n    let {\n      editor,\n      view,\n      tr,\n      dispatch\n    } = _ref24;\n    options = {\n      scrollIntoView: true,\n      ...options\n    };\n    const delayedFocus = () => {\n      // focus within `requestAnimationFrame` breaks focus on iOS\n      // so we have to call this\n      if (isiOS()) {\n        view.dom.focus();\n      }\n      // For React we have to focus asynchronously. Otherwise wild things happen.\n      // see: https://github.com/ueberdosis/tiptap/issues/1520\n      requestAnimationFrame(() => {\n        if (!editor.isDestroyed) {\n          view.focus();\n          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n            editor.commands.scrollIntoView();\n          }\n        }\n      });\n    };\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      delayedFocus();\n      return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n      if (!isSameSelection) {\n        tr.setSelection(selection);\n      }\n      // `tr.setSelection` resets the stored marks\n      // so we’ll restore them if the selection is the same as before\n      if (isSameSelection && tr.storedMarks) {\n        tr.setStoredMarks(tr.storedMarks);\n      }\n      delayedFocus();\n    }\n    return true;\n  };\n};\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, {\n    ...props,\n    index\n  }));\n};\nconst insertContent = (value, options) => _ref25 => {\n  let {\n    tr,\n    commands\n  } = _ref25;\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\nconst insertContentAt = (position, value, options) => _ref26 => {\n  let {\n    tr,\n    dispatch,\n    editor\n  } = _ref26;\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    });\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true;\n    }\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to);\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to);\n      } else {\n        tr.insertText(value, from, to);\n      }\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinUp = () => _ref27 => {\n  let {\n    state,\n    dispatch\n  } = _ref27;\n  return joinUp$1(state, dispatch);\n};\nconst joinDown = () => _ref28 => {\n  let {\n    state,\n    dispatch\n  } = _ref28;\n  return joinDown$1(state, dispatch);\n};\nconst joinBackward = () => _ref29 => {\n  let {\n    state,\n    dispatch\n  } = _ref29;\n  return joinBackward$1(state, dispatch);\n};\nconst joinForward = () => _ref30 => {\n  let {\n    state,\n    dispatch\n  } = _ref30;\n  return joinForward$1(state, dispatch);\n};\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === 'Space') {\n    result = ' ';\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nconst keyboardShortcut = name => _ref31 => {\n  let {\n    editor,\n    view,\n    tr,\n    dispatch\n  } = _ref31;\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref32 => {\n    let {\n      state,\n      dispatch\n    } = _ref32;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n      return false;\n    }\n    return lift$1(state, dispatch);\n  };\n};\nconst liftEmptyBlock = () => _ref33 => {\n  let {\n    state,\n    dispatch\n  } = _ref33;\n  return liftEmptyBlock$1(state, dispatch);\n};\nconst liftListItem = typeOrName => _ref34 => {\n  let {\n    state,\n    dispatch\n  } = _ref34;\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\nconst newlineInCode = () => _ref35 => {\n  let {\n    state,\n    dispatch\n  } = _ref35;\n  return newlineInCode$1(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n  return null;\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => _ref36 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref36;\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => _ref37 => {\n  let {\n    tr,\n    dispatch\n  } = _ref37;\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => _ref38 => {\n  let {\n    tr,\n    commands\n  } = _ref38;\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => _ref39 => {\n  let {\n    state,\n    dispatch\n  } = _ref39;\n  return selectNodeBackward$1(state, dispatch);\n};\nconst selectNodeForward = () => _ref40 => {\n  let {\n    state,\n    dispatch\n  } = _ref40;\n  return selectNodeForward$1(state, dispatch);\n};\nconst selectParentNode = () => _ref41 => {\n  let {\n    state,\n    dispatch\n  } = _ref41;\n  return selectParentNode$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockEnd = () => _ref42 => {\n  let {\n    state,\n    dispatch\n  } = _ref42;\n  return selectTextblockEnd$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockStart = () => _ref43 => {\n  let {\n    state,\n    dispatch\n  } = _ref43;\n  return selectTextblockStart$1(state, dispatch);\n};\nfunction createDocument(content, schema) {\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\nconst setContent = function (content) {\n  let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref44 => {\n    let {\n      tr,\n      editor,\n      dispatch\n    } = _ref44;\n    const {\n      doc\n    } = tr;\n    const document = createDocument(content, editor.schema, parseOptions);\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n    }\n    return true;\n  };\n};\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return {\n    ...mark.attrs\n  };\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return {\n    ...node.attrs\n  };\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\nfunction removeDuplicates(array) {\n  let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.stringify;\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n      if (from === undefined || to === undefined) {\n        return;\n      }\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n    ranges.forEach(_ref45 => {\n      let {\n        from,\n        to\n      } = _ref45;\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node) {\n  let startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = {\n        ...mark.attrs\n      };\n    }\n    return output;\n  });\n  const attrs = {\n    ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(_ref46 => {\n    let [name] = _ref46;\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction isMarkActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(_ref47 => {\n    let {\n      $from,\n      $to\n    } = _ref47;\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  // calculate range of matched mark\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n  if (typeof group !== 'string') {\n    return false;\n  }\n  return group.split(' ').includes('list');\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const {\n    selection\n  } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    // There can be no current marks that exclude the new mark\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType));\n  }\n  const {\n    ranges\n  } = selection;\n  return ranges.some(_ref48 => {\n    let {\n      $from,\n      $to\n    } = _ref48;\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref49 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref49;\n    const {\n      selection\n    } = tr;\n    const {\n      empty,\n      ranges\n    } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n      if (empty) {\n        const oldAttributes = getMarkAttributes(state, type);\n        tr.addStoredMark(type.create({\n          ...oldAttributes,\n          ...attributes\n        }));\n      } else {\n        ranges.forEach(range => {\n          const from = range.$from.pos;\n          const to = range.$to.pos;\n          state.doc.nodesBetween(from, to, (node, pos) => {\n            const trimmedFrom = Math.max(pos, from);\n            const trimmedTo = Math.min(pos + node.nodeSize, to);\n            const someHasMark = node.marks.find(mark => mark.type === type);\n            // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n            if (someHasMark) {\n              node.marks.forEach(mark => {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  }));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n    return canSetMark(state, tr, type);\n  };\n};\nconst setMeta = (key, value) => _ref50 => {\n  let {\n    tr\n  } = _ref50;\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref51 => {\n    let {\n      state,\n      dispatch,\n      chain\n    } = _ref51;\n    const type = getNodeType(typeOrName, state.schema);\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n      console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n      return false;\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(_ref52 => {\n      let {\n        commands\n      } = _ref52;\n      const canSetBlock = setBlockType(type, attributes)(state);\n      if (canSetBlock) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).command(_ref53 => {\n      let {\n        state: updatedState\n      } = _ref53;\n      return setBlockType(type, attributes)(updatedState, dispatch);\n    }).run();\n  };\n};\nconst setNodeSelection = position => _ref54 => {\n  let {\n    tr,\n    dispatch\n  } = _ref54;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = position => _ref55 => {\n  let {\n    tr,\n    dispatch\n  } = _ref55;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = typeOrName => _ref56 => {\n  let {\n    state,\n    dispatch\n  } = _ref56;\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = function () {\n  let {\n    keepMarks = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref57 => {\n    let {\n      tr,\n      state,\n      dispatch,\n      editor\n    } = _ref57;\n    const {\n      selection,\n      doc\n    } = tr;\n    const {\n      $from,\n      $to\n    } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.split($from.pos).scrollIntoView();\n      }\n      return true;\n    }\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n    if (dispatch) {\n      const atEnd = $to.parentOffset === $to.parent.content.size;\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n      const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      let types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          const first = tr.mapping.map($from.before());\n          const $first = tr.doc.resolve(first);\n          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  };\n};\nconst splitListItem = typeOrName => _ref58 => {\n  let {\n    tr,\n    state,\n    dispatch,\n    editor\n  } = _ref58;\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection;\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      }\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      splittableMarks\n    } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === undefined) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === undefined) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks) => _ref59 => {\n  let {\n    editor,\n    tr,\n    state,\n    dispatch,\n    chain,\n    commands,\n    can\n  } = _ref59;\n  const {\n    extensions,\n    splittableMarks\n  } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const {\n    selection,\n    storedMarks\n  } = state;\n  const {\n    $from,\n    $to\n  } = selection;\n  const range = $from.blockRange($to);\n  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    }\n    // change list type\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n    return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  }\n  return chain()\n  // try to convert node to default node if needed\n  .command(() => {\n    const canWrapInList = can().wrapInList(listType);\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\nconst toggleMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref60 => {\n    let {\n      state,\n      commands\n    } = _ref60;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n      return commands.unsetMark(type, {\n        extendEmptyMarkRange\n      });\n    }\n    return commands.setMark(type, attributes);\n  };\n};\nconst toggleNode = function (typeOrName, toggleTypeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref61 => {\n    let {\n      state,\n      commands\n    } = _ref61;\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n    return commands.setNode(type, attributes);\n  };\n};\nconst toggleWrap = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref62 => {\n    let {\n      state,\n      commands\n    } = _ref62;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n  };\n};\nconst undoInputRule = () => _ref63 => {\n  let {\n    state,\n    dispatch\n  } = _ref63;\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => _ref64 => {\n  let {\n    tr,\n    dispatch\n  } = _ref64;\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = function (typeOrName) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref65 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref65;\n    var _a;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const {\n      selection\n    } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      $from,\n      empty,\n      ranges\n    } = selection;\n    if (!dispatch) {\n      return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n      let {\n        from,\n        to\n      } = selection;\n      const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n      const range = getMarkRange($from, type, attrs);\n      if (range) {\n        from = range.from;\n        to = range.to;\n      }\n      tr.removeMark(from, to, type);\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type);\n      });\n    }\n    tr.removeStoredMark(type);\n    return true;\n  };\n};\nconst updateAttributes = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref66 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref66;\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n      return false;\n    }\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n      tr.selection.ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, {\n              ...node.attrs,\n              ...attributes\n            });\n          }\n          if (markType && node.marks.length) {\n            node.marks.forEach(mark => {\n              if (markType === mark.type) {\n                const trimmedFrom = Math.max(pos, from);\n                const trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          }\n        });\n      });\n    }\n    return true;\n  };\n};\nconst wrapIn = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref67 => {\n    let {\n      state,\n      dispatch\n    } = _ref67;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapIn$1(type, attributes)(state, dispatch);\n  };\n};\nconst wrapInList = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref68 => {\n    let {\n      state,\n      dispatch\n    } = _ref68;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapInList$1(type, attributes)(state, dispatch);\n  };\n};\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n  addCommands() {\n    return {\n      ...commands\n    };\n  }\n});\nconst Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(_ref69 => {\n      let {\n        commands\n      } = _ref69;\n      return [() => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(_ref70 => {\n        let {\n          tr\n        } = _ref70;\n        const {\n          selection,\n          doc\n        } = tr;\n        const {\n          empty,\n          $anchor\n        } = selection;\n        const {\n          pos,\n          parent\n        } = $anchor;\n        const isAtStart = Selection.atStart(doc).from === pos;\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false;\n        }\n        return commands.clearNodes();\n      }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()];\n    });\n    const handleDelete = () => this.editor.commands.first(_ref71 => {\n      let {\n        commands\n      } = _ref71;\n      return [() => commands.deleteSelection(), () => commands.deleteCurrentNode(), () => commands.joinForward(), () => commands.selectNodeForward()];\n    });\n    const handleEnter = () => this.editor.commands.first(_ref72 => {\n      let {\n        commands\n      } = _ref72;\n      return [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()];\n    });\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n    // With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n        if (!docChanges) {\n          return;\n        }\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n        if (empty || !allWasSelected || !isEmpty) {\n          return;\n        }\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n        if (!tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    })];\n  }\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce) {\n  const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n  const styleNode = document.createElement('style');\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n  setOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n  setEditable(editable) {\n    let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.setOptions({\n      editable\n    });\n    if (emitUpdate) {\n      this.emit('update', {\n        editor: this,\n        transaction: this.state.tr\n      });\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    });\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n  dispatchTransaction(transaction) {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach(step => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n  destroy() {\n    this.emit('destroy');\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n  get isDestroyed() {\n    var _a;\n    // @ts-ignore\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref73 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref73;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref74 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref74;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, config.type.create(attributes));\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes));\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref75 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref75;\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref76 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref76;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref77 => {\n      let {\n        state,\n        range,\n        match,\n        chain\n      } = _ref77;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const {\n          selection,\n          storedMarks\n        } = state;\n        const {\n          splittableMarks\n        } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Mark(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit(_ref78) {\n    let {\n      editor,\n      mark\n    } = _ref78;\n    const {\n      tr\n    } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(' ', currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Node(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      view\n    } = this.editor;\n    const target = event.target;\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith('drag');\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('drop', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    }\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    }\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false;\n    }\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS() && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    }\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    }\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(_ref79 => {\n      let {\n        tr\n      } = _ref79;\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref80 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref80;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler(_ref81) {\n      let {\n        match,\n        chain,\n        range\n      } = _ref81;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref82 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref82;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, createChainableState, createDocument, createNodeFromContent, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getAttributesFromExtensions, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getRenderedAttributes, getSchema, getSchemaByResolvedExtensions, getSchemaTypeByName, getSchemaTypeNameByName, getSplittedAttributes, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, injectExtensionAttributesToParseRule, inputRulesPlugin, isActive, isEmptyObject, isExtensionRulesEnabled, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, resolveFocusPosition, selectionToInsertionEnd, splitExtensions, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"mappings":"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","names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","view","buildProps","Object","fromEntries","entries","map","name","command","method","callback","getMeta","dispatch","chain","createChain","can","createCan","startTr","shouldDispatch","callbacks","hasStartTransaction","run","every","chainedCommand","push","formattedCommands","undefined","setStoredMarks","EventEmitter","on","event","fn","emit","args","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","attribute","addAttributes","mergedAttr","nameOrType","nodes","Error","objects","item","reduce","items","mergedAttributes","key","exists","join","nodeOrMark","attrs","mergeAttributes","isFunction","callOrReturn","keys","length","fromString","match","Number","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","isEmptyObject","getSchemaByResolvedExtensions","allAttributes","topNode","find","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","injectExtensionAttributesToParseRule","toDOM","HTMLAttributes","getRenderedAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","enabled","Array","isArray","some","enabledExtension","$from","maxMatch","textBefore","sliceEndPos","parentOffset","nodesBetween","Math","max","pos","index","chunk","spec","textContent","slice","isRegExp","prototype","toString","call","InputRule","handler","inputRuleMatcherHandler","text","exec","inputRuleMatch","result","input","replaceWith","includes","console","warn","from","to","rules","plugin","composing","resolve","nodeBefore","nodeAfter","matched","getTextContentFromNodes","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","extensionStorage","getSchemaTypeByName","splittableMarks","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","defaultBindings","exitable","ArrowRight","Mark","handleExit","bindings","shortcut","keyMapPlugin","keymap","addInputRules","isExtensionRulesEnabled","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","getNodeType","addNodeView","nodeview","getPos","decorations","getType","isPlainObject","getPrototypeOf","source","output","assign","mergeDeep","Extension","defaultOptions","addOptions","create","configure","extend","extendedConfig","child","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","setContent","clearNodes","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","originalCreateParagraphNear","deleteCurrentNode","currentNode","$anchor","$pos","depth","before","after","delete","scrollIntoView","deleteNode","typeOrName","deleteRange","deleteSelection","originalDeleteSelection","enter","keyboardShortcut","exitCode","originalExitCode","object1","object2","strict","test","findMarkInSet","objectIncludes","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","extendMarkRange","getMarkType","newSelection","TextSelection","setSelection","first","i","isTextSelection","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","minMax","isiOS","navigator","platform","userAgent","document","focus","delayedFocus","hasFocus","isSameSelection","eq","insertContent","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","v","joinUp","originalJoinUp","joinDown","originalJoinDown","joinBackward","originalJoinBackward","joinForward","originalJoinForward","isMacOS","normalizeKeyName","parts","split","alt","ctrl","shift","meta","mod","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","isActive","originalLift","liftEmptyBlock","originalLiftEmptyBlock","liftListItem","originalLiftListItem","newlineInCode","originalNewlineInCode","obj","propOrProps","newObj","prop","resetAttributes","nodeType","markType","schemaType","getSchemaTypeNameByName","deleteProps","addMark","selectAll","setTextSelection","selectNodeBackward","originalSelectNodeBackward","selectNodeForward","originalSelectNodeForward","selectParentNode","originalSelectParentNode","selectTextblockEnd","originalSelectTextblockEnd","selectTextblockStart","originalSelectTextblockStart","createDocument","oldDoc","Transform","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","predicate","nodesWithPos","descendants","findChildrenInRange","findParentNode","findParentNodeClosestToPos","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","getSchema","contentNode","Node","fromJSON","getHTMLFromFragment","generateText","getText","$head","markItem","nodeItem","getNodeAttributes","getMarkAttributes","removeDuplicates","array","by","JSON","stringify","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","newStart","newEnd","oldStart","invert","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","getSplittedAttributes","typeName","isMarkActive","markRanges","matchedRange","markRange","excludedRange","isNodeEmpty","defaultContent","createAndFill","isNodeSelection","NodeSelection","posToDOMRect","resolvedEnd","coordsAtPos","top","bottom","left","right","width","height","x","y","canSetMark","newMarkType","cursor","currentMarks","someNodeSupportsMark","inlineContent","allowsMarkType","_pos","isInline","parentAllowsMarkType","currentMarksAllowMarkType","otherMark","setMark","addStoredMark","trimmedFrom","trimmedTo","someHasMark","setNode","canSetBlock","setBlockType","updatedState","setNodeSelection","sinkListItem","originalSinkListItem","ensureMarks","filteredMarks","splitBlock","keepMarks","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","append","replace","Slice","sel","n","newTypeAttributes","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","itemType","parentList","isList","validContent","canWrapInList","wrapInList","toggleMark","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","toggleType","toggleWrap","wrapIn","undoInputRule","undoable","getState","toUndo","j","docs","unsetAllMarks","removeMark","removeStoredMark","updateAttributes","originalWrapIn","originalWrapInList","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","isAtStart","handleDelete","handleEnter","baseKeymap","Enter","Backspace","Delete","pcKeymap","macKeymap","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","nonce","tipTapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","createStyleTag","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","isCapturingTransaction","selectionHasChanged","getAttributes","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","markInputRule","captureGroup","fullMatch","markEnd","startSpaces","search","textStart","textEnd","excludedMarks","excluded","nodeInputRule","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","$start","textInputRule","insert","cutOff","wrappingInputRule","wrapping","findWrapping","keepAttributes","joinPredicate","currentPos","isAtEnd","isInMark","m","NodeView","component","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","nativeEvent","offsetY","dataTransfer","setDragImage","isInElement","isDragEvent","isDropEvent","isInput","tagName","isContentEditable","isDragging","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","markPasteRule","escapeForRegEx","string","isString","nodePasteRule","textPasteRule","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\createChainableState.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\CommandManager.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\EventEmitter.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getExtensionField.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\splitExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributesFromExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeType.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\mergeAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getRenderedAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isFunction.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\callOrReturn.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isEmptyObject.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\fromString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\injectExtensionAttributesToParseRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaByResolvedExtensions.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeByName.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isExtensionRulesEnabled.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getTextContentFromNodes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isRegExp.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\InputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isNumber.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\PasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\findDuplicates.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\ExtensionManager.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isPlainObject.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\mergeDeep.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\Extension.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getTextBetween.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getTextSerializersFromSchema.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\clipboardTextSerializer.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\blur.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\clearContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\clearNodes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\command.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\createParagraphNear.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\deleteCurrentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\deleteNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\deleteRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\deleteSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\enter.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\exitCode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\objectIncludes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkType.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\extendMarkRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\first.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isTextSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\minMax.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\resolveFocusPosition.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isiOS.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\focus.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\forEach.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\insertContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\elementFromString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\createNodeFromContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\selectionToInsertionEnd.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\insertContentAt.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\join.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isMacOS.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\keyboardShortcut.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\lift.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\liftEmptyBlock.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\liftListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\newlineInCode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getSchemaTypeNameByName.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\deleteProps.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\resetAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\scrollIntoView.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectAll.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeBackward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectNodeForward.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectParentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockEnd.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\selectTextblockStart.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\createDocument.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setContent.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\combineTransactionSteps.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\defaultBlockAt.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\findChildren.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\findChildrenInRange.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNodeClosestToPos.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\findParentNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getHTMLFromFragment.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getSchema.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\generateHTML.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\generateJSON.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getText.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\generateText.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getMarkAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getNodeAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\removeDuplicates.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getChangedRanges.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getDebugJSON.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getMarksBetween.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\getSplittedAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isMarkActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isActive.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeEmpty.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\isNodeSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\helpers\\posToDOMRect.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setMeta.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setNodeSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\setTextSelection.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\sinkListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\splitBlock.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\splitListItem.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\toggleList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\toggleMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\toggleNode.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\toggleWrap.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\undoInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\unsetAllMarks.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\unsetMark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\updateAttributes.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\wrapIn.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\commands\\wrapInList.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\commands.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\editable.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\focusEvents.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\keymap.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\extensions\\tabindex.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\style.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\createStyleTag.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\Editor.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\inputRules\\markInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\inputRules\\nodeInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\inputRules\\textblockTypeInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\inputRules\\textInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\inputRules\\wrappingInputRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\Mark.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\Node.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\NodeView.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\pasteRules\\markPasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\escapeForRegEx.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\utilities\\isString.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\pasteRules\\nodePasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\pasteRules\\textPasteRule.ts","C:\\Users\\petew\\OneDrive\\Desktop\\Web Dev Reboot\\react-boat-info\\client\\node_modules\\@tiptap\\core\\src\\Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from '@tiptap/pm/state'\n\nexport function createChainableState(config: {\n  transaction: Transaction\n  state: EditorState\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands,\n} from './types'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks)\n    }\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension'\nimport { Mark } from '../Mark'\nimport { Node } from '../Node'\nimport { Extensions } from '../types'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '..'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types'\nimport { getExtensionField } from './getExtensionField'\nimport { splitExtensions } from './splitExtensions'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (attribute?.isRequired && attribute?.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\n        `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types'\nimport { mergeAttributes } from '../utilities/mergeAttributes'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types'\nimport { isFunction } from './isFunction'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types'\nimport { fromString } from '../utilities/fromString'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from '@tiptap/pm/model'\n\nimport { MarkConfig, NodeConfig } from '..'\nimport { AnyConfig, Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { isEmptyObject } from '../utilities/isEmptyObject'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions'\nimport { getExtensionField } from './getExtensionField'\nimport { getRenderedAttributes } from './getRenderedAttributes'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule'\nimport { splitExtensions } from './splitExtensions'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n          e,\n          'extendNodeSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(\n          getExtensionField<NodeConfig['content']>(extension, 'content', context),\n        ),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(\n          getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context),\n        ),\n        draggable: callOrReturn(\n          getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context),\n        ),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        defining: callOrReturn(\n          getExtensionField<NodeConfig['defining']>(extension, 'defining', context),\n        ),\n        isolating: callOrReturn(\n          getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context),\n        ),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = node => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n        })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(\n        extension,\n        'renderText',\n        context,\n      )\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n          e,\n          'extendMarkSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(\n          getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context),\n        ),\n        excludes: callOrReturn(\n          getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context),\n        ),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(\n          getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context),\n        ),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = mark => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n        })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from '@tiptap/pm/model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(\n    Math.max(0, sliceEndPos - maxMatch),\n    sliceEndPos,\n    (node, pos, parent, index) => {\n      const chunk = node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      })\n        || node.textContent\n        || '%leaf%'\n\n      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos))\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (\n  text: string,\n  find: InputRuleFinder,\n): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn(\n        '[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".',\n      )\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const {\n    editor, from, to, text, rules, plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isNumber } from './utilities/isNumber'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn(\n          '[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".',\n        )\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n}): boolean {\n  const {\n    editor, state, from, to, rule,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n\n            return false\n          },\n\n          paste: (view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport { Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\nimport { Plugin } from '@tiptap/pm/state'\nimport { Decoration, EditorView } from '@tiptap/pm/view'\n\nimport { Mark, NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { getNodeType } from './helpers/getNodeType'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled'\nimport { splitExtensions } from './helpers/splitExtensions'\nimport { inputRulesPlugin } from './InputRule'\nimport { pasteRulesPlugin } from './PasteRule'\nimport { AnyConfig, Extensions, RawCommands } from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { findDuplicates } from './utilities/findDuplicates'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(\n        `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n          .map(item => `'${item}'`)\n          .join(', ')}]. This can lead to issues.`,\n      )\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return (\n      extensions\n        .map(extension => {\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n          }\n\n          const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n            extension,\n            'addExtensions',\n            context,\n          )\n\n          if (addExtensions) {\n            return [extension, ...this.flatten(addExtensions())]\n          }\n\n          return extension\n        })\n        // `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10)\n    )\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        let defaultBindings: Record<string, () => boolean> = {}\n\n        // bind exit handling\n        if (extension.type === 'mark' && extension.config.exitable) {\n          defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n        }\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n              return [shortcut, () => method({ editor })]\n            }),\n          )\n\n          defaultBindings = { ...defaultBindings, ...bindings }\n        }\n\n        const keyMapPlugin = keymap(defaultBindings)\n\n        plugins.push(keyMapPlugin)\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(\n            attribute => attribute.type === extension.name,\n          )\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n            extension,\n            'addNodeView',\n            context,\n          )\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeview = (\n            node: ProsemirrorNode,\n            view: EditorView,\n            getPos: (() => number) | boolean,\n            decorations: Decoration[],\n          ) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return addNodeView()({\n              editor,\n              node,\n              getPos,\n              decorations,\n              HTMLAttributes,\n              extension,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { ExtensionConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Mark } from './Mark'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { Range, TextSerializer } from '../types'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\nimport { getTextBetween } from '../helpers/getTextBetween'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       */\n      deleteCurrentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const currentNode = selection.$anchor.node()\n\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false\n  }\n\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Range } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\n        `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport { FocusPosition } from '../types'\nimport { minMax } from '../utilities/minMax'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition'\nimport { FocusPosition, RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt(\n    { from: tr.selection.from, to: tr.selection.to },\n    value,\n    options,\n  )\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from '@tiptap/pm/model'\n\nimport { Content } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd'\nimport { Content, Range, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content) ? content : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to)\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to)\n      } else {\n        tr.insertText(value as string, from, to)\n      }\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join two nodes Up.\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join two nodes Down.\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * Join two nodes Backwards.\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] = () => ({ state, dispatch }) => {\n  return originalJoinUp(state, dispatch)\n}\n\nexport const joinDown: RawCommands['joinDown'] = () => ({ state, dispatch }) => {\n  return originalJoinDown(state, dispatch)\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { NodeRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getNodeType } from './getNodeType'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\nimport { deleteProps } from '../utilities/deleteProps'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: string | string[],\n      ) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(\n                pos,\n                pos + node.nodeSize,\n                markType.create(deleteProps(mark.attrs, attributes)),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport { Content } from '../types'\nimport { createNodeFromContent } from './createNodeFromContent'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument'\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(\n  oldDoc: ProseMirrorNode,\n  transactions: Transaction[],\n): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from '@tiptap/pm/model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate } from '../types'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate, Range } from '../types'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(\n  node: ProseMirrorNode,\n  range: Range,\n  predicate: Predicate,\n): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Predicate } from '../types'\n\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from '@tiptap/pm/state'\n\nimport { Predicate } from '../types'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { DOMSerializer, Fragment, Schema } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { ExtensionManager } from '../ExtensionManager'\nimport { Extensions } from '../types'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions'\n\nexport function getSchema(extensions: Extensions): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent } from '../types'\nimport { getHTMLFromFragment } from './getHTMLFromFragment'\nimport { getSchema } from './getSchema'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport { Extensions } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\nimport { getSchema } from './getSchema'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types'\nimport { getTextBetween } from './getTextBetween'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types'\nimport { getSchema } from './getSchema'\nimport { getText } from './getText'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import { Mark, MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType'\n\nexport function getMarkAttributes(\n  state: EditorState,\n  typeOrName: string | MarkType,\n): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType'\n\nexport function getNodeAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType,\n): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes'\nimport { getNodeAttributes } from './getNodeAttributes'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from '@tiptap/pm/transform'\n\nimport { Range } from '../types'\nimport { removeDuplicates } from '../utilities/removeDuplicates'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { JSONContent } from '../types'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { MarkRange } from '../types'\nimport { getMarkRange } from './getMarkRange'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import { ExtensionAttribute } from '../types'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MarkRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getMarkType } from './getMarkType'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\nimport { isMarkActive } from './isMarkActive'\nimport { isNodeActive } from './isNodeActive'\n\nexport function isActive(\n  state: EditorState,\n  name: string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { NodeConfig } from '..'\nimport { getExtensionField } from '../helpers/getExtensionField'\nimport { Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { splitExtensions } from './splitExtensions'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { isTextSelection } from '../helpers'\nimport { getMarkAttributes } from '../helpers/getMarkAttributes'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n\n    // There can be no current marks that exclude the new mark\n    return (\n      !!newMarkType.isInSet(currentMarks)\n      || !currentMarks.some(mark => mark.type.excludes(newMarkType))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0\n      ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n      : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n          || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes,\n        }),\n      )\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes,\n                  }),\n                )\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return canSetMark(state, tr, type)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(({ commands }) => {\n        const canSetBlock = setBlockType(type, attributes)(state)\n\n        if (canSetBlock) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .command(({ state: updatedState }) => {\n        return setBlockType(type, attributes)(updatedState, dispatch)\n      })\n      .run()\n  )\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { Range, RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { EditorState, NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr, state, dispatch, editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [\n        {\n          type: deflt,\n          attrs: newAttributes,\n        },\n      ]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n        && !can\n        && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [\n          {\n            type: deflt,\n            attrs: newAttributes,\n          },\n        ]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment, Node as ProseMirrorNode, NodeType, Slice,\n} from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n        || $from.node(-3).type !== type\n        || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [\n      { type, attrs: newTypeAttributes },\n      { type: nextType, attrs: newNextTypeAttributes },\n    ]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    const { selection, storedMarks } = state\n    const { splittableMarks } = editor.extensionManager\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    tr.split($from.pos, 2, types).scrollIntoView()\n\n    if (!marks || !dispatch) {\n      return true\n    }\n\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n    tr.ensureMarks(filteredMarks)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isList } from '../helpers/isList'\nimport { RawCommands } from '../types'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType, keepMarks?: boolean) => ReturnType;\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName, keepMarks) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions, splittableMarks } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection, storedMarks } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n        && listType.validContent(parentList.node.content)\n        && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n\n    return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType)\n\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n        tr.ensureMarks(filteredMarks)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  )\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { isMarkActive } from '../helpers/isMarkActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands'\nimport { Extension } from '../Extension'\n\nexport * from '../commands'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager'\nimport { Extension } from '../Extension'\nimport { createChainableState } from '../helpers/createChainableState'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const isAtStart = Selection.atStart(doc).from === pos\n\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (empty || !allWasSelected || !isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string): HTMLStyleElement {\n  const tipTapStyleTag = (<HTMLStyleElement>document.querySelector('style[data-tiptap-style]'))\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute('data-tiptap-style', '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager'\nimport { EventEmitter } from './EventEmitter'\nimport { ExtensionManager } from './ExtensionManager'\nimport * as extensions from './extensions'\nimport { createDocument } from './helpers/createDocument'\nimport { getAttributes } from './helpers/getAttributes'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment'\nimport { getText } from './helpers/getText'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema'\nimport { isActive } from './helpers/isActive'\nimport { isNodeEmpty } from './helpers/isNodeEmpty'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition'\nimport { style } from './style'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types'\nimport { createStyleTag } from './utilities/createStyleTag'\nimport { isFunction } from './utilities/isFunction'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn(\n      '[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.',\n    )\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, config.type.create(attributes))\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes))\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport { Editor } from '../Editor'\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  keepMarks?: boolean,\n  keepAttributes?: boolean,\n  editor?: Editor\n  getAttributes?:\n  | Record<string, any>\n  | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n  | false\n  | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state, range, match, chain,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { MarkConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean)\n\n    /**\n     * Inclusive\n     */\n    inclusive?:\n      | MarkSpec['inclusive']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n        }) => MarkSpec['inclusive'])\n\n    /**\n     * Excludes\n     */\n    excludes?:\n      | MarkSpec['excludes']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n        }) => MarkSpec['excludes'])\n\n    /**\n     * Marks this Mark as exitable\n     */\n    exitable?: boolean | (() => boolean)\n\n    /**\n     * Group\n     */\n    group?:\n      | MarkSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n        }) => MarkSpec['group'])\n\n    /**\n     * Spanning\n     */\n    spanning?:\n      | MarkSpec['spanning']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n        }) => MarkSpec['spanning'])\n\n    /**\n     * Code\n     */\n    code?:\n      | boolean\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n        }) => boolean)\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n    }) => MarkSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n          },\n          props: {\n            mark: ProseMirrorMark\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n    }) => Attributes | {}\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n}\n","import {\n  DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Node View\n     */\n    addNodeView?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n        }) => NodeViewRenderer)\n      | null\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean\n\n    /**\n     * Content\n     */\n    content?:\n      | NodeSpec['content']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n        }) => NodeSpec['content'])\n\n    /**\n     * Marks\n     */\n    marks?:\n      | NodeSpec['marks']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n        }) => NodeSpec['marks'])\n\n    /**\n     * Group\n     */\n    group?:\n      | NodeSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n        }) => NodeSpec['group'])\n\n    /**\n     * Inline\n     */\n    inline?:\n      | NodeSpec['inline']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n        }) => NodeSpec['inline'])\n\n    /**\n     * Atom\n     */\n    atom?:\n      | NodeSpec['atom']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n        }) => NodeSpec['atom'])\n\n    /**\n     * Selectable\n     */\n    selectable?:\n      | NodeSpec['selectable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n        }) => NodeSpec['selectable'])\n\n    /**\n     * Draggable\n     */\n    draggable?:\n      | NodeSpec['draggable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n        }) => NodeSpec['draggable'])\n\n    /**\n     * Code\n     */\n    code?:\n      | NodeSpec['code']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n        }) => NodeSpec['code'])\n\n    /**\n     * Whitespace\n     */\n    whitespace?:\n      | NodeSpec['whitespace']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n        }) => NodeSpec['whitespace'])\n\n    /**\n     * Defining\n     */\n    defining?:\n      | NodeSpec['defining']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n        }) => NodeSpec['defining'])\n\n    /**\n     * Isolating\n     */\n    isolating?:\n      | NodeSpec['isolating']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n        }) => NodeSpec['isolating'])\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n    }) => NodeSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n          },\n          props: {\n            node: ProseMirrorNode\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Render Text\n     */\n    renderText?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n          },\n          props: {\n            node: ProseMirrorNode\n            pos: number\n            parent: ProseMirrorNode\n            index: number\n          },\n        ) => string)\n      | null\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n    }) => Attributes | {}\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeSelection } from '@tiptap/pm/state'\nimport { NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\n\nimport { Editor as CoreEditor } from './Editor'\nimport { Node } from './Node'\nimport { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types'\nimport { isiOS } from './utilities/isiOS'\n\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: DecorationWithType[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && isiOS()\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { PasteRule, PasteRuleFinder } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes,\n        })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step.getMap().mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}