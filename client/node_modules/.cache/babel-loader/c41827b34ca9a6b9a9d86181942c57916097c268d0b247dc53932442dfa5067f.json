{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;\n\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n  return styleObject;\n}\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  return value;\n}\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n  return clone;\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const textNodeSize = text.length;\n    const offset = textNodeSize - remaining;\n    const slicedText = text.slice(0, offset);\n    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0) {\n        parent.remove();\n      }\n      remaining -= textNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaniing number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = textNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, _ref) => {\n    let [key, value] = _ref;\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\n\n/**\r\n * Converts all nodes in the selection that are of one block type to another specified by parameter\r\n *\r\n * @param selection\r\n * @param createElement\r\n * @returns\r\n */\nfunction $setBlocksType_experimental(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) firstChild.replace(element, true);else root.append(element);\n    return;\n  }\n  const nodes = selection.getNodes();\n  if (selection.anchor.type === 'text') {\n    let firstBlock = selection.anchor.getNode().getParent();\n    firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;\n    if (nodes.indexOf(firstBlock) === -1) nodes.push(firstBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!isBlock(node)) continue;\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isBlock(node) {\n  return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\nfunction $wrapNodes(selection, createElement) {\n  let wrappingElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement) {\n  let wrappingElement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty) {\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType_experimental = $setBlocksType_experimental;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;","map":{"version":3,"names":["lexical","require","CSS_TO_STYLES","Map","getDOMTextNode","element","node","nodeType","Node","TEXT_NODE","firstChild","getDOMIndexWithinParent","parent","parentNode","Error","Array","from","childNodes","indexOf","createDOMRange","editor","anchorNode","_anchorOffset","focusNode","_focusOffset","anchorKey","getKey","focusKey","range","document","createRange","anchorDOM","getElementByKey","focusDOM","anchorOffset","focusOffset","$isTextNode","undefined","nodeName","setStart","setEnd","e","collapsed","createRectsFromDOMRange","rootElement","getRootElement","rootRect","getBoundingClientRect","computedStyle","getComputedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","length","prevRect","i","selectionRect","isDuplicateRect","top","left","width","height","selectionSpansElement","splice","getStyleObjectFromRawCSS","css","styleObject","styles","split","style","key","value","trim","getStyleObjectFromCSS","get","set","getCSSFromStyleObject","$updateElementNodeProperties","target","source","__first","__last","__size","__format","__indent","__dir","$updateTextNodeProperties","__style","__mode","__detail","$cloneWithProperties","latest","getLatest","constructor","clone","__parent","__next","__prev","$isElementNode","$sliceSelectedTextNodeContent","selection","textNode","isSelected","isSegmented","isToken","$isRangeSelection","DEPRECATED_$isGridSelection","anchor","getNode","focus","isAnchor","is","isFocus","isBackward","getCharacterOffsets","isSame","isFirst","isLast","startOffset","endOffset","offset","__text","slice","$isAtNodeEnd","point","type","getTextContentSize","getChildrenSize","trimTextContentFromAnchor","delCount","currentNode","remaining","descendantNode","getDescendantByIndex","nextNode","getPreviousSibling","additionalElementWhitespace","getParentOrThrow","parentSibling","getParent","isInline","getLastDescendant","text","getTextContent","textNodeSize","slicedText","remove","prevTextContent","getEditorState","read","prevNode","$getNodeByKey","isSimpleText","prevSelection","$getPreviousSelection","$createTextNode","replace","setTextContent","isCollapsed","prevOffset","select","splitStart","splitEnd","excessNode","splitText","$addNodeStyle","CSSText","getStyle","$patchStyle","patch","prevStyles","newStyles","Object","entries","reduce","newCSSText","setStyle","$patchStyleText","selectedNodes","getNodes","selectedNodesLength","lastIndex","firstNode","lastNode","firstNodeText","firstNodeTextLength","isBefore","startType","endType","endKey","nextSibling","getNextSibling","splitNodes","replacement","lastNodeText","lastNodeTextLength","__key","selectedNode","selectedNodeKey","$setBlocksType_experimental","createElement","root","$getRoot","getFirstChild","append","nodes","firstBlock","push","isBlock","targetElement","setFormat","getFormatType","setIndent","getIndent","$isRootOrShadowRoot","isPointAttached","isAttached","$removeParentEmptyElements","startingNode","$wrapNodes","wrappingElement","nodesLength","children","getChildren","forEach","child","topLevelNode","descendants","$wrapNodesImpl","$hasAncestor","elementMapping","elements","targetIsPrevSibling","prevSibling","emptyElements","Set","add","movedNodes","$isLeafNode","has","parentKey","getChildrenKeys","lastElement","insertAfter","insertBefore","$setSelection","selectEnd","dirty","$shouldOverrideDefaultCharacterSelection","possibleNode","$getAdjacentNode","$isDecoratorNode","isIsolated","canBeEmpty","$moveCaretSelection","isHoldingShift","granularity","modify","$isParentElementRTL","$isRootNode","getDirection","$moveCharacter","isRTL","$selectAll","topParent","getTopLevelElementOrThrow","getFirstDescendant","firstType","lastType","lastOffset","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","exports"],"sources":["C:/Users/petew/OneDrive/Desktop/Web Dev Reboot/react-boat-info/client/node_modules/@lexical/selection/LexicalSelection.dev.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst CSS_TO_STYLES = new Map();\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction getDOMTextNode(element) {\r\n  let node = element;\r\n  while (node != null) {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n      return node;\r\n    }\r\n    node = node.firstChild;\r\n  }\r\n  return null;\r\n}\r\nfunction getDOMIndexWithinParent(node) {\r\n  const parent = node.parentNode;\r\n  if (parent == null) {\r\n    throw new Error('Should never happen');\r\n  }\r\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\r\n}\r\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\r\n  const anchorKey = anchorNode.getKey();\r\n  const focusKey = focusNode.getKey();\r\n  const range = document.createRange();\r\n  let anchorDOM = editor.getElementByKey(anchorKey);\r\n  let focusDOM = editor.getElementByKey(focusKey);\r\n  let anchorOffset = _anchorOffset;\r\n  let focusOffset = _focusOffset;\r\n  if (lexical.$isTextNode(anchorNode)) {\r\n    anchorDOM = getDOMTextNode(anchorDOM);\r\n  }\r\n  if (lexical.$isTextNode(focusNode)) {\r\n    focusDOM = getDOMTextNode(focusDOM);\r\n  }\r\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\r\n    return null;\r\n  }\r\n  if (anchorDOM.nodeName === 'BR') {\r\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\r\n  }\r\n  if (focusDOM.nodeName === 'BR') {\r\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\r\n  }\r\n  const firstChild = anchorDOM.firstChild;\r\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\r\n    focusOffset = 1;\r\n  }\r\n  try {\r\n    range.setStart(anchorDOM, anchorOffset);\r\n    range.setEnd(focusDOM, focusOffset);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\r\n    // Range is backwards, we need to reverse it\r\n    range.setStart(focusDOM, focusOffset);\r\n    range.setEnd(anchorDOM, anchorOffset);\r\n  }\r\n  return range;\r\n}\r\nfunction createRectsFromDOMRange(editor, range) {\r\n  const rootElement = editor.getRootElement();\r\n  if (rootElement === null) {\r\n    return [];\r\n  }\r\n  const rootRect = rootElement.getBoundingClientRect();\r\n  const computedStyle = getComputedStyle(rootElement);\r\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\r\n  const selectionRects = Array.from(range.getClientRects());\r\n  let selectionRectsLength = selectionRects.length;\r\n  let prevRect;\r\n  for (let i = 0; i < selectionRectsLength; i++) {\r\n    const selectionRect = selectionRects[i];\r\n    // Exclude a rect that is the exact same as the last rect. getClientRects() can return\r\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\r\n    // merge all the rects together into a set of rects that don't overlap, so we don't\r\n    // generate backgrounds that are too dark.\r\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;\r\n\r\n    // Exclude selections that span the entire element\r\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\r\n    if (isDuplicateRect || selectionSpansElement) {\r\n      selectionRects.splice(i--, 1);\r\n      selectionRectsLength--;\r\n      continue;\r\n    }\r\n    prevRect = selectionRect;\r\n  }\r\n  return selectionRects;\r\n}\r\nfunction getStyleObjectFromRawCSS(css) {\r\n  const styleObject = {};\r\n  const styles = css.split(';');\r\n  for (const style of styles) {\r\n    if (style !== '') {\r\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\r\n      styleObject[key.trim()] = value.trim();\r\n    }\r\n  }\r\n  return styleObject;\r\n}\r\nfunction getStyleObjectFromCSS(css) {\r\n  let value = CSS_TO_STYLES.get(css);\r\n  if (value === undefined) {\r\n    value = getStyleObjectFromRawCSS(css);\r\n    CSS_TO_STYLES.set(css, value);\r\n  }\r\n  return value;\r\n}\r\nfunction getCSSFromStyleObject(styles) {\r\n  let css = '';\r\n  for (const style in styles) {\r\n    if (style) {\r\n      css += `${style}: ${styles[style]};`;\r\n    }\r\n  }\r\n  return css;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $updateElementNodeProperties(target, source) {\r\n  target.__first = source.__first;\r\n  target.__last = source.__last;\r\n  target.__size = source.__size;\r\n  target.__format = source.__format;\r\n  target.__indent = source.__indent;\r\n  target.__dir = source.__dir;\r\n  return target;\r\n}\r\nfunction $updateTextNodeProperties(target, source) {\r\n  target.__format = source.__format;\r\n  target.__style = source.__style;\r\n  target.__mode = source.__mode;\r\n  target.__detail = source.__detail;\r\n  return target;\r\n}\r\nfunction $cloneWithProperties(node) {\r\n  const latest = node.getLatest();\r\n  const constructor = latest.constructor;\r\n  // @ts-expect-error\r\n  const clone = constructor.clone(latest);\r\n  clone.__parent = latest.__parent;\r\n  clone.__next = latest.__next;\r\n  clone.__prev = latest.__prev;\r\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\r\n    return $updateElementNodeProperties(clone, latest);\r\n  }\r\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\r\n    return $updateTextNodeProperties(clone, latest);\r\n  }\r\n  return clone;\r\n}\r\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\r\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\r\n    const anchorNode = selection.anchor.getNode();\r\n    const focusNode = selection.focus.getNode();\r\n    const isAnchor = textNode.is(anchorNode);\r\n    const isFocus = textNode.is(focusNode);\r\n    if (isAnchor || isFocus) {\r\n      const isBackward = selection.isBackward();\r\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\r\n      const isSame = anchorNode.is(focusNode);\r\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\r\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\r\n      let startOffset = 0;\r\n      let endOffset = undefined;\r\n      if (isSame) {\r\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\r\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\r\n      } else if (isFirst) {\r\n        const offset = isBackward ? focusOffset : anchorOffset;\r\n        startOffset = offset;\r\n        endOffset = undefined;\r\n      } else if (isLast) {\r\n        const offset = isBackward ? anchorOffset : focusOffset;\r\n        startOffset = 0;\r\n        endOffset = offset;\r\n      }\r\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\r\n      return textNode;\r\n    }\r\n  }\r\n  return textNode;\r\n}\r\nfunction $isAtNodeEnd(point) {\r\n  if (point.type === 'text') {\r\n    return point.offset === point.getNode().getTextContentSize();\r\n  }\r\n  return point.offset === point.getNode().getChildrenSize();\r\n}\r\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\r\n  // Work from the current selection anchor point\r\n  let currentNode = anchor.getNode();\r\n  let remaining = delCount;\r\n  if (lexical.$isElementNode(currentNode)) {\r\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\r\n    if (descendantNode !== null) {\r\n      currentNode = descendantNode;\r\n    }\r\n  }\r\n  while (remaining > 0 && currentNode !== null) {\r\n    let nextNode = currentNode.getPreviousSibling();\r\n    let additionalElementWhitespace = 0;\r\n    if (nextNode === null) {\r\n      let parent = currentNode.getParentOrThrow();\r\n      let parentSibling = parent.getPreviousSibling();\r\n      while (parentSibling === null) {\r\n        parent = parent.getParent();\r\n        if (parent === null) {\r\n          nextNode = null;\r\n          break;\r\n        }\r\n        parentSibling = parent.getPreviousSibling();\r\n      }\r\n      if (parent !== null) {\r\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\r\n        if (lexical.$isElementNode(parentSibling)) {\r\n          nextNode = parentSibling.getLastDescendant();\r\n        } else {\r\n          nextNode = parentSibling;\r\n        }\r\n      }\r\n    }\r\n    let text = currentNode.getTextContent();\r\n    // If the text is empty, we need to consider adding in two line breaks to match\r\n    // the content if we were to get it from its parent.\r\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\r\n      // TODO: should this be handled in core?\r\n      text = '\\n\\n';\r\n    }\r\n    const textNodeSize = text.length;\r\n    const offset = textNodeSize - remaining;\r\n    const slicedText = text.slice(0, offset);\r\n    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\r\n      const parent = currentNode.getParent();\r\n      currentNode.remove();\r\n      if (parent != null && parent.getChildrenSize() === 0) {\r\n        parent.remove();\r\n      }\r\n      remaining -= textNodeSize + additionalElementWhitespace;\r\n      currentNode = nextNode;\r\n    } else {\r\n      const key = currentNode.getKey();\r\n      // See if we can just revert it to what was in the last editor state\r\n      const prevTextContent = editor.getEditorState().read(() => {\r\n        const prevNode = lexical.$getNodeByKey(key);\r\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\r\n          return prevNode.getTextContent();\r\n        }\r\n        return null;\r\n      });\r\n      if (prevTextContent !== null && prevTextContent !== text) {\r\n        const prevSelection = lexical.$getPreviousSelection();\r\n        let target = currentNode;\r\n        if (!currentNode.isSimpleText()) {\r\n          const textNode = lexical.$createTextNode(prevTextContent);\r\n          currentNode.replace(textNode);\r\n          target = textNode;\r\n        } else {\r\n          currentNode.setTextContent(prevTextContent);\r\n        }\r\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\r\n          const prevOffset = prevSelection.anchor.offset;\r\n          target.select(prevOffset, prevOffset);\r\n        }\r\n      } else if (currentNode.isSimpleText()) {\r\n        // Split text\r\n        const isSelected = anchor.key === key;\r\n        let anchorOffset = anchor.offset;\r\n        // Move offset to end if it's less than the remaniing number, otherwise\r\n        // we'll have a negative splitStart.\r\n        if (anchorOffset < remaining) {\r\n          anchorOffset = textNodeSize;\r\n        }\r\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\r\n        const splitEnd = isSelected ? anchorOffset : offset;\r\n        if (isSelected && splitStart === 0) {\r\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\r\n          excessNode.remove();\r\n        } else {\r\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\r\n          excessNode.remove();\r\n        }\r\n      } else {\r\n        const textNode = lexical.$createTextNode(slicedText);\r\n        currentNode.replace(textNode);\r\n      }\r\n      remaining = 0;\r\n    }\r\n  }\r\n}\r\nfunction $addNodeStyle(node) {\r\n  const CSSText = node.getStyle();\r\n  const styles = getStyleObjectFromRawCSS(CSSText);\r\n  CSS_TO_STYLES.set(CSSText, styles);\r\n}\r\nfunction $patchStyle(target, patch) {\r\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\r\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\r\n    if (value === null) {\r\n      delete styles[key];\r\n    } else {\r\n      styles[key] = value;\r\n    }\r\n    return styles;\r\n  }, {\r\n    ...prevStyles\r\n  } || {});\r\n  const newCSSText = getCSSFromStyleObject(newStyles);\r\n  target.setStyle(newCSSText);\r\n  CSS_TO_STYLES.set(newCSSText, newStyles);\r\n}\r\nfunction $patchStyleText(selection, patch) {\r\n  const selectedNodes = selection.getNodes();\r\n  const selectedNodesLength = selectedNodes.length;\r\n  const lastIndex = selectedNodesLength - 1;\r\n  let firstNode = selectedNodes[0];\r\n  let lastNode = selectedNodes[lastIndex];\r\n  if (selection.isCollapsed()) {\r\n    $patchStyle(selection, patch);\r\n    return;\r\n  }\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const firstNodeText = firstNode.getTextContent();\r\n  const firstNodeTextLength = firstNodeText.length;\r\n  const focusOffset = focus.offset;\r\n  let anchorOffset = anchor.offset;\r\n  const isBefore = anchor.isBefore(focus);\r\n  let startOffset = isBefore ? anchorOffset : focusOffset;\r\n  let endOffset = isBefore ? focusOffset : anchorOffset;\r\n  const startType = isBefore ? anchor.type : focus.type;\r\n  const endType = isBefore ? focus.type : anchor.type;\r\n  const endKey = isBefore ? focus.key : anchor.key;\r\n\r\n  // This is the case where the user only selected the very end of the\r\n  // first node so we don't want to include it in the formatting change.\r\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\r\n    const nextSibling = firstNode.getNextSibling();\r\n    if (lexical.$isTextNode(nextSibling)) {\r\n      // we basically make the second node the firstNode, changing offsets accordingly\r\n      anchorOffset = 0;\r\n      startOffset = 0;\r\n      firstNode = nextSibling;\r\n    }\r\n  }\r\n\r\n  // This is the case where we only selected a single node\r\n  if (firstNode.is(lastNode)) {\r\n    if (lexical.$isTextNode(firstNode)) {\r\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\r\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\r\n\r\n      // No actual text is selected, so do nothing.\r\n      if (startOffset === endOffset) {\r\n        return;\r\n      }\r\n\r\n      // The entire node is selected, so just format it\r\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\r\n        $patchStyle(firstNode, patch);\r\n        firstNode.select(startOffset, endOffset);\r\n      } else {\r\n        // The node is partially selected, so split it into two nodes\r\n        // and style the selected one.\r\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\r\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\r\n        $patchStyle(replacement, patch);\r\n        replacement.select(0, endOffset - startOffset);\r\n      }\r\n    } // multiple nodes selected.\r\n  } else {\r\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\r\n      if (startOffset !== 0) {\r\n        // the entire first node isn't selected, so split it\r\n        firstNode = firstNode.splitText(startOffset)[1];\r\n        startOffset = 0;\r\n      }\r\n      $patchStyle(firstNode, patch);\r\n    }\r\n    if (lexical.$isTextNode(lastNode)) {\r\n      const lastNodeText = lastNode.getTextContent();\r\n      const lastNodeTextLength = lastNodeText.length;\r\n\r\n      // The last node might not actually be the end node\r\n      //\r\n      // If not, assume the last node is fully-selected unless the end offset is\r\n      // zero.\r\n      if (lastNode.__key !== endKey && endOffset !== 0) {\r\n        endOffset = lastNodeTextLength;\r\n      }\r\n\r\n      // if the entire last node isn't selected, split it\r\n      if (endOffset !== lastNodeTextLength) {\r\n        [lastNode] = lastNode.splitText(endOffset);\r\n      }\r\n      if (endOffset !== 0) {\r\n        $patchStyle(lastNode, patch);\r\n      }\r\n    }\r\n\r\n    // style all the text nodes in between\r\n    for (let i = 1; i < lastIndex; i++) {\r\n      const selectedNode = selectedNodes[i];\r\n      const selectedNodeKey = selectedNode.getKey();\r\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\r\n        $patchStyle(selectedNode, patch);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/**\r\n * Converts all nodes in the selection that are of one block type to another specified by parameter\r\n *\r\n * @param selection\r\n * @param createElement\r\n * @returns\r\n */\r\nfunction $setBlocksType_experimental(selection, createElement) {\r\n  if (selection.anchor.key === 'root') {\r\n    const element = createElement();\r\n    const root = lexical.$getRoot();\r\n    const firstChild = root.getFirstChild();\r\n    if (firstChild) firstChild.replace(element, true);else root.append(element);\r\n    return;\r\n  }\r\n  const nodes = selection.getNodes();\r\n  if (selection.anchor.type === 'text') {\r\n    let firstBlock = selection.anchor.getNode().getParent();\r\n    firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;\r\n    if (nodes.indexOf(firstBlock) === -1) nodes.push(firstBlock);\r\n  }\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if (!isBlock(node)) continue;\r\n    const targetElement = createElement();\r\n    targetElement.setFormat(node.getFormatType());\r\n    targetElement.setIndent(node.getIndent());\r\n    node.replace(targetElement, true);\r\n  }\r\n}\r\nfunction isBlock(node) {\r\n  return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();\r\n}\r\nfunction isPointAttached(point) {\r\n  return point.getNode().isAttached();\r\n}\r\nfunction $removeParentEmptyElements(startingNode) {\r\n  let node = startingNode;\r\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\r\n    const latest = node.getLatest();\r\n    const parentNode = node.getParent();\r\n    if (latest.getChildrenSize() === 0) {\r\n      node.remove(true);\r\n    }\r\n    node = parentNode;\r\n  }\r\n}\r\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\r\n  const nodes = selection.getNodes();\r\n  const nodesLength = nodes.length;\r\n  const anchor = selection.anchor;\r\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\r\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\r\n    const children = target.getChildren();\r\n    let element = createElement();\r\n    element.setFormat(target.getFormatType());\r\n    element.setIndent(target.getIndent());\r\n    children.forEach(child => element.append(child));\r\n    if (wrappingElement) {\r\n      element = wrappingElement.append(element);\r\n    }\r\n    target.replace(element);\r\n    return;\r\n  }\r\n  let topLevelNode = null;\r\n  let descendants = [];\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\r\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\r\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\r\n    // of each of the cell nodes.\r\n    if (lexical.$isRootOrShadowRoot(node)) {\r\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n      descendants = [];\r\n      topLevelNode = node;\r\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\r\n      descendants.push(node);\r\n    } else {\r\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n      descendants = [node];\r\n    }\r\n  }\r\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n}\r\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\r\n  if (nodes.length === 0) {\r\n    return;\r\n  }\r\n  const firstNode = nodes[0];\r\n  const elementMapping = new Map();\r\n  const elements = [];\r\n  // The below logic is to find the right target for us to\r\n  // either insertAfter/insertBefore/append the corresponding\r\n  // elements to. This is made more complicated due to nested\r\n  // structures.\r\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\r\n  if (target.isInline()) {\r\n    target = target.getParentOrThrow();\r\n  }\r\n  let targetIsPrevSibling = false;\r\n  while (target !== null) {\r\n    const prevSibling = target.getPreviousSibling();\r\n    if (prevSibling !== null) {\r\n      target = prevSibling;\r\n      targetIsPrevSibling = true;\r\n      break;\r\n    }\r\n    target = target.getParentOrThrow();\r\n    if (lexical.$isRootOrShadowRoot(target)) {\r\n      break;\r\n    }\r\n  }\r\n  const emptyElements = new Set();\r\n\r\n  // Find any top level empty elements\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\r\n      emptyElements.add(node.getKey());\r\n    }\r\n  }\r\n  const movedNodes = new Set();\r\n\r\n  // Move out all leaf nodes into our elements array.\r\n  // If we find a top level empty element, also move make\r\n  // an element for that.\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    let parent = node.getParent();\r\n    if (parent !== null && parent.isInline()) {\r\n      parent = parent.getParent();\r\n    }\r\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\r\n      const parentKey = parent.getKey();\r\n      if (elementMapping.get(parentKey) === undefined) {\r\n        const targetElement = createElement();\r\n        targetElement.setFormat(parent.getFormatType());\r\n        targetElement.setIndent(parent.getIndent());\r\n        elements.push(targetElement);\r\n        elementMapping.set(parentKey, targetElement);\r\n        // Move node and its siblings to the new\r\n        // element.\r\n        parent.getChildren().forEach(child => {\r\n          targetElement.append(child);\r\n          movedNodes.add(child.getKey());\r\n          if (lexical.$isElementNode(child)) {\r\n            // Skip nested leaf nodes if the parent has already been moved\r\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\r\n          }\r\n        });\r\n        $removeParentEmptyElements(parent);\r\n      }\r\n    } else if (emptyElements.has(node.getKey())) {\r\n      const targetElement = createElement();\r\n      targetElement.setFormat(node.getFormatType());\r\n      targetElement.setIndent(node.getIndent());\r\n      elements.push(targetElement);\r\n      node.remove(true);\r\n    }\r\n  }\r\n  if (wrappingElement !== null) {\r\n    for (let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      wrappingElement.append(element);\r\n    }\r\n  }\r\n  let lastElement = null;\r\n\r\n  // If our target is Root-like, let's see if we can re-adjust\r\n  // so that the target is the first child instead.\r\n  if (lexical.$isRootOrShadowRoot(target)) {\r\n    if (targetIsPrevSibling) {\r\n      if (wrappingElement !== null) {\r\n        target.insertAfter(wrappingElement);\r\n      } else {\r\n        for (let i = elements.length - 1; i >= 0; i--) {\r\n          const element = elements[i];\r\n          target.insertAfter(element);\r\n        }\r\n      }\r\n    } else {\r\n      const firstChild = target.getFirstChild();\r\n      if (lexical.$isElementNode(firstChild)) {\r\n        target = firstChild;\r\n      }\r\n      if (firstChild === null) {\r\n        if (wrappingElement) {\r\n          target.append(wrappingElement);\r\n        } else {\r\n          for (let i = 0; i < elements.length; i++) {\r\n            const element = elements[i];\r\n            target.append(element);\r\n            lastElement = element;\r\n          }\r\n        }\r\n      } else {\r\n        if (wrappingElement !== null) {\r\n          firstChild.insertBefore(wrappingElement);\r\n        } else {\r\n          for (let i = 0; i < elements.length; i++) {\r\n            const element = elements[i];\r\n            firstChild.insertBefore(element);\r\n            lastElement = element;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    if (wrappingElement) {\r\n      target.insertAfter(wrappingElement);\r\n    } else {\r\n      for (let i = elements.length - 1; i >= 0; i--) {\r\n        const element = elements[i];\r\n        target.insertAfter(element);\r\n        lastElement = element;\r\n      }\r\n    }\r\n  }\r\n  const prevSelection = lexical.$getPreviousSelection();\r\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\r\n    lexical.$setSelection(prevSelection.clone());\r\n  } else if (lastElement !== null) {\r\n    lastElement.selectEnd();\r\n  } else {\r\n    selection.dirty = true;\r\n  }\r\n}\r\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\r\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\r\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\r\n}\r\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\r\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\r\n}\r\nfunction $isParentElementRTL(selection) {\r\n  const anchorNode = selection.anchor.getNode();\r\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\r\n  return parent.getDirection() === 'rtl';\r\n}\r\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\r\n  const isRTL = $isParentElementRTL(selection);\r\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\r\n}\r\nfunction $selectAll(selection) {\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const anchorNode = anchor.getNode();\r\n  const topParent = anchorNode.getTopLevelElementOrThrow();\r\n  const root = topParent.getParentOrThrow();\r\n  let firstNode = root.getFirstDescendant();\r\n  let lastNode = root.getLastDescendant();\r\n  let firstType = 'element';\r\n  let lastType = 'element';\r\n  let lastOffset = 0;\r\n  if (lexical.$isTextNode(firstNode)) {\r\n    firstType = 'text';\r\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\r\n    firstNode = firstNode.getParentOrThrow();\r\n  }\r\n  if (lexical.$isTextNode(lastNode)) {\r\n    lastType = 'text';\r\n    lastOffset = lastNode.getTextContentSize();\r\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\r\n    lastNode = lastNode.getParentOrThrow();\r\n  }\r\n  if (firstNode && lastNode) {\r\n    anchor.set(firstNode.getKey(), 0, firstType);\r\n    focus.set(lastNode.getKey(), lastOffset, lastType);\r\n  }\r\n}\r\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\r\n  const css = node.getStyle();\r\n  const styleObject = getStyleObjectFromCSS(css);\r\n  if (styleObject !== null) {\r\n    return styleObject[styleProperty] || defaultValue;\r\n  }\r\n  return defaultValue;\r\n}\r\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\r\n  let styleValue = null;\r\n  const nodes = selection.getNodes();\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const isBackward = selection.isBackward();\r\n  const endOffset = isBackward ? focus.offset : anchor.offset;\r\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\r\n  if (selection.style !== '') {\r\n    const css = selection.style;\r\n    const styleObject = getStyleObjectFromCSS(css);\r\n    if (styleObject !== null && styleProperty in styleObject) {\r\n      return styleObject[styleProperty];\r\n    }\r\n  }\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n\r\n    // if no actual characters in the end node are selected, we don't\r\n    // include it in the selection for purposes of determining style\r\n    // value\r\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\r\n      continue;\r\n    }\r\n    if (lexical.$isTextNode(node)) {\r\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\r\n      if (styleValue === null) {\r\n        styleValue = nodeStyleValue;\r\n      } else if (styleValue !== nodeStyleValue) {\r\n        // multiple text nodes are in the selection and they don't all\r\n        // have the same style.\r\n        styleValue = '';\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return styleValue === null ? defaultValue : styleValue;\r\n}\r\n\r\nexports.$addNodeStyle = $addNodeStyle;\r\nexports.$cloneWithProperties = $cloneWithProperties;\r\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\r\nexports.$isAtNodeEnd = $isAtNodeEnd;\r\nexports.$isParentElementRTL = $isParentElementRTL;\r\nexports.$moveCaretSelection = $moveCaretSelection;\r\nexports.$moveCharacter = $moveCharacter;\r\nexports.$patchStyleText = $patchStyleText;\r\nexports.$selectAll = $selectAll;\r\nexports.$setBlocksType_experimental = $setBlocksType_experimental;\r\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\r\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\r\nexports.$wrapNodes = $wrapNodes;\r\nexports.createDOMRange = createDOMRange;\r\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\r\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\r\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}